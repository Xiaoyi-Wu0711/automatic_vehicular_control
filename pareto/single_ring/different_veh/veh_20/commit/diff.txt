diff --git a/README.md b/README.md
index b591747..127f484 100644
--- a/README.md
+++ b/README.md
@@ -39,7 +39,7 @@ conda env create -f environment.yml
 ### 1.2 Set the environmental variables
 ```
 # Code directory
-export F=automatic_vehicular_control/automatic_vehicular_control
+export F=automatic_vehicular_control
 
 # Results directory extracted from the zip file
 export R=results
@@ -48,10 +48,8 @@ export R=results
 ## 2. Directory Structure
 
 The code directory structure is
-```
+``` 
 automatic_vehicular_control/
-│
-├── automatic_vehicular_control/
 │   ├── __pycache__/                # Compiled Python files
 │   ├── evaluations/                # Evaluation results and metrics
 │   ├── models/                     # Model checkpoints
diff --git a/env.py b/env.py
index 4ab3d95..c83a674 100644
--- a/env.py
+++ b/env.py
@@ -724,9 +724,11 @@ class TrafficState:
         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
 
         segments = {}
+        
         def add_from_to(from_, to):
             from_.tos.add(to)
             to.froms.add(from_)
+            
         for con in map(values_str_to_val, net.children('connection')):
             from_lane = edges[con['from']].lanes[int(con.fromLane)]
             to_lane = edges[con.to].lanes[int(con.toLane)]
@@ -888,89 +890,109 @@ class TrafficState:
 
     def step(self):
         """
-        Take a simulation step and update state
+        Take a simulation step and update state.
         """
-        c = self.c
-        tc = self.tc
-        subscribes = self.subscribes
+        c = self.c  # Configuration object for the simulation
+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
+        subscribes = self.subscribes  # Subscription definitions to get simulation data
 
         # Actual SUMO step
-        tc.simulationStep()
-        sim_res = subscribes.sim.get()
+        tc.simulationStep()  # Advances the SUMO simulation by one step
+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
 
+        # Clear references to current vehicle edges and lanes for the next update
         for veh in self.vehicles:
-            veh.unvar('edge', 'lane')
+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
+
+        # Clear current vehicle data from edges and lanes
         for ent in itertools.chain(self.edges, self.lanes):
-            ent.vehicles.clear()
-            ent.positions.clear()
+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
+            ent.positions.clear()  # Clear vehicle positions
 
+        # Update traffic light states
         for tl_id, tl in self.traffic_lights.items():
-            tl.update(subscribes.tl.get(tl_id))
+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
 
+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
         for veh_id in sim_res.loaded_vehicles_ids:
-            flow_id, _ = veh_id.rsplit('.')
-            flow = self.flows[flow_id]
-            flow.backlog.add(veh_id)
+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
+            flow = self.flows[flow_id]  # Get the corresponding flow object
+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
 
+        # Initialize a set for newly departed vehicles
         self.new_departed = set()
+
+        # Handle vehicles that have departed (entered the network)
         for veh_id in sim_res.departed_vehicles_ids:
-            subscribes.veh.subscribe(veh_id)
-            type_id = tc.vehicle.getTypeID(veh_id)
-            # import pdb; pdb.set_trace()
+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
+            # If vehicle type is 'generic', compute specific type
             if type_id == 'generic':
                 type_id = self.compute_type(veh_id)
-            type_ = self.types[type_id]
-            route = self.routes[tc.vehicle.getRouteID(veh_id)]
-            length = tc.vehicle.getLength(veh_id)
-            road_id = tc.vehicle.getRoadID(veh_id)
-            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
-            type_.vehicles.add(veh)
+            type_ = self.types[type_id]  # Get vehicle type object
+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
+
+            # Create a new vehicle object and add it to the list of vehicles
+            self.vehicles[veh_id] = veh = Vehicle(
+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
+            )
+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
 
+            # Set color if rendering is enabled
             if c.render:
                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
-                self.set_color(veh, color_fn(veh))
+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
 
+            # Set vehicle speed mode and lane change mode using SUMO settings
             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
+
+            # Add to new_departed set
             self.new_departed.add(veh)
+
+            # Remove vehicle from backlog if necessary
             if '.' in veh_id:
                 flow_id, _ = veh_id.rsplit('.')
                 if flow_id in self.flows:
                     flow = self.flows[flow_id]
                     flow.backlog.remove(veh_id)
 
+        # Handle newly arrived and collided vehicles
         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+        
+        # Remove newly arrived vehicles from tracking if they collided
         for veh in self.new_arrived:
-            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
-        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
 
+        # Update vehicle positions on edges and lanes
         for veh_id, veh in self.vehicles.items():
-            veh.prev_speed = veh.get('speed', None)
-            veh.update(subscribes.veh.get(veh_id))
+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
             if veh_id not in sim_res.colliding_vehicles_ids:
-                edge = self.edges[veh.road_id]
-                edge.vehicles.append(veh)
-                veh.edge = edge
-            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
-            # edge = self.edges[veh.road_id]
-            # edge.vehicles.append(veh)
-            # veh.edge = edge
+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
+                veh.edge = edge  # Set vehicle's edge attribute
 
+        # Update vehicle sorting and lane positions
         for edge in self.edges:
-            edge.vehicles.sort(key=lambda veh: veh.laneposition)
-            edge.positions = [veh.laneposition for veh in edge.vehicles]
+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
             for edge_i, veh in enumerate(edge.vehicles):
-                veh.edge_i = edge_i
-                veh.lane = lane = edge.lanes[veh.lane_index]
-                veh.lane_i = len(lane.vehicles)
-                lane.vehicles.append(veh)
-                lane.positions.append(veh.laneposition)
+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
 
+        # Record sets of vehicles that have arrived, departed, or collided during this step
         self.all_arrived.append(self.new_arrived)
         self.all_departed.append(self.new_departed)
         self.all_collided.append(self.new_collided)
-
+            
     def reset(self, tc):
         self.tc = tc
         self.subscribes.clear()
@@ -1043,6 +1065,7 @@ class Env:
     """
     Offers a similar reinforcement learning environment interface as gym.Env
     Wraps around a TrafficState (ts) and the SUMO traci (tc)
+    c: Ring class
     """
     def __init__(self, c):
         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
@@ -1056,6 +1079,7 @@ class Env:
             if c.get('save_agent'):
                 self._agent_info = []
         self._step = 0
+        self.mean_speed = 0
 
     def def_sumo(self, *args, **kwargs):
         """ Override this with code defining the SUMO network """
@@ -1094,49 +1118,91 @@ class Env:
         """
         return True
 
+   # Method to reset or initialize the SUMO traffic simulation environment
     def reset_sumo(self):
+        # Shortcuts for configuration and SUMO definition objects
         c = self.c
         sumo_def = self.sumo_def
-
-        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+        
+        # Determine if new SUMO definitions need to be generated
+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
+        
         if generate_def:
-            kwargs = self.def_sumo()
-            kwargs['net'] = sumo_def.generate_net(**kwargs)
-            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
+            # Generate new definitions if necessary
+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
+        
+        # Start SUMO with the current traffic controller (tc)
         self.tc = sumo_def.start_sumo(self.tc)
+        
         if generate_def:
+            # If new definitions were generated, store relevant SUMO file paths
             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
+            
+            # Load SUMO definitions from the generated file paths and initialize the traffic state
             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
-            self.ts = TrafficState(c, self.tc, **defs)
+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
         else:
+            # If not generating new definitions, simply reset the existing traffic state
             self.ts.reset(self.tc)
+        
+        # Set up the traffic state (e.g., initialize the simulation settings)
         self.ts.setup()
+        
+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
         success = self.init_vehicles()
+        
+        # Return whether the SUMO reset and vehicle initialization were successful
         return success
 
+    # Method to initialize the environment after SUMO reset
     def init_env(self):
+        # Reference to the traffic state
         ts = self.ts
+    
+        # Create an empty data structure to store rollout information
         self.rollout_info = NamedArrays()
+        
+        # Turn off all traffic lights in the network
         for tl in ts.traffic_lights:
-            ts.set_program(tl, 'off')
+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
+        
+        # Reset the step counter to 0
         self._step = 0
+        
+        # Take the first step in the simulation
         ret = self.step()
+        
+        # Run the simulation for a number of warmup steps
         for _ in range(self.c.warmup_steps):
-            ret = self.step()
+            ret = self.step()  # Advance the simulation one step
+            
+            # If the simulation ends during the warmup phase, return None to indicate failure
             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
                 return None
+        
+        # After warmup, turn traffic lights back on (set to a defined program '1')
         for tl in ts.traffic_lights:
-            ts.set_program(tl, '1')
+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
+        
+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
         if isinstance(ret, tuple):
-            return ret[0]
-        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
-
+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
+        
+    # Reset the entire environment, retrying until successful
     def reset(self):
-        while True:
+        self.mean_speed = 0
+        while True:  # Infinite loop until the environment is successfully reset
+            # Attempt to reset the SUMO simulation
             if not self.reset_sumo():
-                continue
+                continue  # If reset_sumo fails, retry the loop
+            
+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
             if (obs := self.init_env()) is not None:
-                return obs
+                return obs  # Successfully initialized, return the observation
+
 
     def append_step_info(self):
         """
@@ -1231,6 +1297,8 @@ class Env:
 class NormEnv(gym.Env):
     """
     Reward normalization with running average https://github.com/joschu/modular_rl
+    self.c: Ring parameters 
+    self.env: RingEnv class
     """
     def __init__(self, c, env):
         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
diff --git a/exp.py b/exp.py
index ead4652..7f7cee5 100644
--- a/exp.py
+++ b/exp.py
@@ -169,9 +169,9 @@ class Main(Config):
 
     def on_train_start(c):
         # Initialize training: environment, algorithm, model, optimizer, and logging
-        c.setdefaults(alg='Algorithm')
-        c._env = c.create_env()
-
+        c.setdefaults(alg='Algorithm') 
+        c._env = c.create_env() # Create NormEnv
+ 
         # Instantiate the algorithm (e.g., PPO, DQN)
         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
         c.set_model()
@@ -222,8 +222,8 @@ class Main(Config):
 
     def on_step_start(c, stats={}):
         # Update the learning rate and log stats at the start of a training step
-        lr = c._lr
-        for g in c._opt.param_groups:
+        lr = c._lr # Update Learning Rate
+        for g in c._opt.param_groups: # Log Statistics
             g['lr'] = float(lr)
         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
 
@@ -285,10 +285,14 @@ class Main(Config):
             ret = dict(obs=ret)
         rollout = NamedArrays()
         rollout.append(**ret)
-
+        rollout_flow_each_step = []
         done = False
         a_space = c.action_space
         step = 0
+        density = 20/(250*1e-3)
+        vehicle_flow = c._env.mean_speed * 3.6 * density 
+        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+
         while step < c.horizon + c.skip_stat_steps and not done:
             # Generate an action from the model's policy
             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
@@ -309,6 +313,12 @@ class Main(Config):
             rollout.append(**ret)
             step += 1
         # Collect stats from the environment
+        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+        density = 20/(250 * 1e-3)
+        vehicle_flow = c._env.mean_speed * density 
+        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+
         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
         return rollout, stats
 
@@ -398,10 +408,10 @@ class Main(Config):
         # Main training loop
         c.on_train_start()
         while c._i < c.n_steps:
-            c.on_step_start()
+            c.on_step_start() # save stat 
             with torch.no_grad():
                 # Collect rollouts without computing gradients
-                rollouts = c.rollouts()
+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
             gd_stats = {}
             if len(rollouts.obs):
                 t_start = time()
@@ -410,7 +420,7 @@ class Main(Config):
                 gd_stats.update(gd_time=time() - t_start)
             c.on_step_end(gd_stats)
             c._i += 1
-        c.on_step_start()  # last step
+        c.on_step_start()  # save stat
         gd_stats = {}
         with torch.no_grad():
             rollouts = c.rollouts()
@@ -450,6 +460,8 @@ class Main(Config):
         if hasattr(c._env, 'close'):
             c._env.close()
 
+  
+
     def run(c):
         # Determine whether to train or evaluate based on configuration
         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
diff --git a/ring.py b/ring.py
index 94d632d..ee1372b 100644
--- a/ring.py
+++ b/ring.py
@@ -15,7 +15,6 @@ class RingEnv(Env):
             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
         )
-
         # Function to generate the shape of the edges (circular arcs)
         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
 
@@ -88,6 +87,17 @@ class RingEnv(Env):
         if c.circumference_range:  # Check if the circumference should be randomized
             # Randomly set the circumference within the specified range
             c.circumference = np.random.randint(*c.circumference_range)
+        
+        if self.flow_log:
+            average_flow = sum(self.flow_log) / len(self.flow_log)
+            self.episode_flow.append(average_flow)
+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
+        
+        # Reset flow counters for the new episode
+        self.flow_counter = 0
+        self.flow_log = []
+        self.last_vehicle_times = {}
+        
         return super().reset_sumo()  # Reset the simulation
 
     @property
@@ -101,8 +111,37 @@ class RingEnv(Env):
         }
         stats['circumference'] = c.circumference  # Add the current circumference to the stats
         stats['beta'] = c.beta                    # Add the beta parameter
+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
         return stats
-
+    
+    def calculate_flow(self):
+        """
+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+        """
+        current_time = self.ts.time
+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+
+        for vehicle in vehicles_on_edge:
+            # Check if vehicle has passed the observation point since the last timestep
+            if vehicle.id not in self.last_vehicle_times:
+                # If the vehicle was not previously recorded, count it as a new passage
+                self.flow_counter += 1
+            else:
+                # If recorded, ensure sufficient time has passed to consider it as a new count
+                last_time = self.last_vehicle_times[vehicle.id]
+                if current_time - last_time > self.c.sim_step:
+                    self.flow_counter += 1
+
+            # Update the last time the vehicle passed the point
+            self.last_vehicle_times[vehicle.id] = current_time
+
+        # Calculate flow as vehicles per hour equivalent based on timestep
+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
+        self.flow_log.append(flow_per_hour)
+        return flow_per_hour
+    
     def step(self, action=None):
         c = self.c  # Configuration object
         ts = self.ts  # Time step object
@@ -181,6 +220,10 @@ class RingEnv(Env):
                     # Change to a specific lane
                     ts.lane_change_to(rl, lc)
 
+        # Calculate flow at the end of each step
+        flow = self.calculate_flow()
+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
+        
         super().step()  # Advance the simulation by one step
 
         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
diff --git a/ring_different_veh.py b/ring_different_veh.py
index 127f673..878e4c8 100644
--- a/ring_different_veh.py
+++ b/ring_different_veh.py
@@ -5,8 +5,15 @@
 from exp import *  # Import all from experimental utilities
 from env import *  # Import all from environment utilities
 from u import *    # Import all from utility functions
+import os
 
-# Define the RingEnv class which inherits from the Env class
+os.environ['F'] = 'automatic_vehicular_control'
+
+
+'''
+    RingEnv is a subclass of the Env class and represents the simulation environment 
+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
+'''
 class RingEnv(Env):
     def def_sumo(self):
         c = self.c  # Access configuration object
@@ -15,7 +22,6 @@ class RingEnv(Env):
             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
         )
-
         # Function to generate the shape of the edges (circular arcs)
         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
 
@@ -102,7 +108,20 @@ class RingEnv(Env):
         stats['circumference'] = c.circumference  # Add the current circumference to the stats
         stats['beta'] = c.beta                    # Add the beta parameter
         return stats
-
+    
+    def calculate_flow(self):
+        """
+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+        """
+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+        if len(vehicles_on_edge) != 0:     
+            if vehicles_on_edge[0] != self.last_vehicle:
+                self.last_vehicle = vehicles_on_edge[0]
+                self.passed_vehicle.append(self.last_vehicle)
+
+
+                    
     def step(self, action=None):
         c = self.c  # Configuration object
         ts = self.ts  # Time step object
@@ -181,6 +200,7 @@ class RingEnv(Env):
                     # Change to a specific lane
                     ts.lane_change_to(rl, lc)
 
+        
         super().step()  # Advance the simulation by one step
 
         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
@@ -267,6 +287,9 @@ class RingEnv(Env):
 
         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
 
+        # Calculate flow at the end of each step
+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+        
         # Calculate safety surrogate measures
         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
@@ -340,7 +363,14 @@ class RingEnv(Env):
         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
         return fleet_pet
 
-# Define the Ring class which inherits from the Main class
+
+'''
+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
+    It defines how the environment is created and configured, 
+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
+'''
 class Ring(Main):
     # Method to create and return the environment
     def create_env(c):
@@ -391,7 +421,7 @@ class Ring(Main):
 
 if __name__ == '__main__':
     # Run the test with different numbers of vehicles
-    for n_veh in range(40, 100, 10):
+    for n_veh in range(20, 40, 10):
         print(f"Running simulation with {n_veh} vehicles")
         # Set up the configuration for a one-lane ring road with different vehicle counts
         c = Ring.from_args(globals(), locals()).setdefaults(
diff --git a/u.py b/u.py
index 09845aa..8e11a17 100644
--- a/u.py
+++ b/u.py
@@ -11,6 +11,8 @@ import warnings
 warnings.filterwarnings('ignore')
 
 from io import StringIO
+import os
+os.environ['F'] = 'automatic_vehicular_control'
 
 def lrange(*args, **kwargs):
     return list(range(*args, **kwargs))