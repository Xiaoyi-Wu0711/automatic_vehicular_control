diff --git a/env.py b/env.py
index c83a674..0bcfb8e 100644
--- a/env.py
+++ b/env.py
@@ -852,12 +852,15 @@ class TrafficState:
         subscribes.sim = SubscribeDef(tc.simulation, [
             V.departed_vehicles_ids, V.arrived_vehicles_ids,
             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
+        
         subscribes.tl = SubscribeDef(tc.trafficlight, [
             TL.red_yellow_green_state])
+        
         subscribes.veh = SubscribeDef(tc.vehicle, [
             V.road_id, V.lane_index, V.laneposition,
             V.speed, V.position, V.angle,
             V.fuelconsumption, V.noxemission])
+        
         for tl_id in self.traffic_lights.keys():
             subscribes.tl.subscribe(tl_id)
 
@@ -1109,6 +1112,26 @@ class Env:
         if self._vehicle_info is not None:
             self.extend_vehicle_info()
         self._step += 1
+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+        return c.observation_space.low, 0, False, None
+    
+    
+    def step_2(self, *args):
+        """
+        Override this with additional code which applies acceleration and measures observation and reward
+        """
+        c, ts = self.c, self.ts
+        if c.get('custom_idm'):
+            idm = c.custom_idm
+            for veh in ts.types.human.vehicles:
+                leader, headway = veh.leader()
+                v = veh.speed
+                s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
+                a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
+                noise = np.random.normal(0, idm.sigma)
+                ts.accel(veh, a + noise)
+        self._step += 1
+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
         return c.observation_space.low, 0, False, None
 
     def init_vehicles(self):
@@ -1197,6 +1220,7 @@ class Env:
         while True:  # Infinite loop until the environment is successfully reset
             # Attempt to reset the SUMO simulation
             if not self.reset_sumo():
+                
                 continue  # If reset_sumo fails, retry the loop
             
             # Initialize the environment. If initialization is successful (obs is not None), return the observation
diff --git a/exp.py b/exp.py
index 7f7cee5..43481b1 100644
--- a/exp.py
+++ b/exp.py
@@ -285,11 +285,10 @@ class Main(Config):
             ret = dict(obs=ret)
         rollout = NamedArrays()
         rollout.append(**ret)
-        rollout_flow_each_step = []
         done = False
         a_space = c.action_space
         step = 0
-        density = 20/(250*1e-3)
+        density = c.var().n_veh/(c.var().circumference*1e-3)
         vehicle_flow = c._env.mean_speed * 3.6 * density 
         print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
 
@@ -315,8 +314,7 @@ class Main(Config):
         # Collect stats from the environment
         # rollout_flow_each_step.append(len(c._env.passed_vehicle))
         # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
-        density = 20/(250 * 1e-3)
-        vehicle_flow = c._env.mean_speed * density 
+        vehicle_flow = c._env.mean_speed * density  * 3.6
         print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
 
         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
@@ -406,9 +404,8 @@ class Main(Config):
 
     def train(c):
         # Main training loop
-        c.on_train_start()
+        c.on_train_start() # Ring Env
         while c._i < c.n_steps:
-            c.on_step_start() # save stat 
             with torch.no_grad():
                 # Collect rollouts without computing gradients
                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
@@ -497,3 +494,31 @@ class Main(Config):
             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
             c.train()
         c.log('job done!')
+
+    def run_2(c):
+        # Determine whether to train or evaluate based on configuration
+        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
+        c.on_train_start()
+        c._env = c.create_env() # Create NormEnv
+        ret = c._env.reset()
+        c.set_model()
+        step = 0
+        density = 20/(250*1e-3)
+        vehicle_flow = c._env.mean_speed * 3.6 * density 
+        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+        done = False
+        while step < c.horizon + c.skip_stat_steps and not done:
+            # Take a step in the environment
+            ret = c._env.step()
+            if isinstance(ret, tuple):
+                obs, reward, done, info = ret
+                ret = dict(obs=obs, reward=reward, done=done, info=info)
+            done = ret.setdefault('done', False)
+            step += 1
+        # Collect stats from the environment
+        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+        density = 20/(250 * 1e-3)
+        vehicle_flow = c._env.mean_speed * density 
+        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
diff --git a/highway_bottleneck.py b/highway_bottleneck.py
deleted file mode 100644
index 6b9ba52..0000000
--- a/highway_bottleneck.py
+++ /dev/null
@@ -1,381 +0,0 @@
-from automatic_vehicular_control.exp import *
-from automatic_vehicular_control.env import *
-from automatic_vehicular_control.u import *
-
-class BNeckEnv(Env):
-    def def_sumo(self):
-        c = self.c
-        nodes = E('nodes',
-            E('node', id='n_0', x=0, y=0), *(
-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
-        ))
-        edges = E('edges', *(
-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
-                'numLanes': n_lane,
-                'speed': c.max_speed
-            }) for i, n_lane in enumerate(c.n_lanes)
-        ))
-        connections = E('connections', *(
-            E('connection', **{
-                'from': prev.id,
-                'to': curr.id,
-                'fromLane': i,
-                'toLane': int(i / prev.numLanes * curr.numLanes)
-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
-        ))
-
-        if c.split_flow:
-            n_inflow_lanes = c.n_lanes[0]
-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
-                for i in range(n_inflow_lanes)
-            ]
-        else:
-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
-            ]
-        routes = E('routes',
-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
-            *flows
-        )
-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
-        additional = E('additional',
-            E('vType', id='generic', **idm_params),
-            E('vType', id='rl', **idm_params),
-            E('vType', id='human', **idm_params),
-        )
-        sumo_args = {'collision.action': COLLISION.remove}
-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
-
-    def reset_sumo(self):
-        c = self.c
-        if c.flow_rate_range:
-            c.flow_rate = np.random.randint(*c.flow_rate_range)
-        ret = super().reset_sumo()
-        if c.vinitsky:
-            self.obs_lanes = [(lane, i_start * c.piece_length)
-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
-                for i_start in range(round(edge.length) // c.piece_length)
-                for lane in edge.lanes
-            ]
-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
-            self.last_outflows = []
-        return ret
-
-    def step(self, action=[]):
-        c = self.c
-        ts = self.ts
-        max_dist = 100
-        max_speed = c.max_speed
-        human_type = ts.types.human
-        rl_type = ts.types.rl
-
-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
-        if c.vinitsky:
-            if len(action):
-                assert len(action) == len(self.control_lanes)
-                for (lane, piece_start), act in zip(self.control_lanes, action):
-                    self.control_lanes[lane, piece_start] = np.clip(
-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
-                        0.1, max_speed
-                    )
-                for veh in prev_rls:
-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
-        else:
-            for veh, act in zip(prev_rls, action):
-                if c.handcraft:
-                    route, edge, lane = veh.route, veh.edge, veh.lane
-                    next_lane = lane.next(veh.route)
-                    level = 1
-                    if next_lane and next_lane.get('junction'):
-                        merge_dist = lane.length - veh.laneposition
-                        if merge_dist < c.handcraft:
-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
-                                level = 0
-                    if c.act_type.startswith('accel'):
-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
-                    else:
-                        ts.set_max_speed(veh, max_speed * level)
-                    continue
-                if not isinstance(act, (int, np.integer)):
-                    act = (act - c.low) / (1 - c.low)
-                if c.act_type.startswith('accel'):
-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
-                else:
-                    if c.act_type == 'continuous':
-                        level = act[0]
-                    elif c.act_type == 'discretize':
-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
-                    elif c.act_type == 'discrete':
-                        level = act / (c.n_actions - 1)
-                    ts.set_max_speed(veh, max_speed * level)
-
-                if c.lc_av == 'binary' and act[1] > 0.5:
-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
-
-        super().step()
-
-        if c.vinitsky:
-            n_last_outflows = 20
-            max_vehs = 4
-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
-            obs = []
-            for lane, piece_start in self.obs_lanes:
-                piece_end = piece_start + c.piece_length
-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
-                lane_humans = [v for v in lane_vehs if v.type is human_type]
-                obs.extend([
-                    len(lane_humans) / max_vehs,
-                    len(lane_avs) / max_vehs,
-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
-                ])
-            if len(self.last_outflows) == n_last_outflows:
-                self.last_outflows = self.last_outflows[1:]
-            self.last_outflows.append(len(ts.new_arrived))
-            reward = np.mean(self.last_outflows)
-            obs.append(reward / max_veh_outflows)
-            obs = np.array(obs, dtype=np.float32)
-            assert 0 <= obs.min() and obs.max() <= 1
-            return obs, reward, False, None
-        route = nexti(ts.routes)
-        obs, ids = [], []
-        default_close = [0, max_speed]
-        default_far = [max_dist, 0]
-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
-            speed, edge, lane = veh.speed, veh.edge, veh.lane
-            merge_dist = max_dist
-            default_human = default_far
-
-            other_info = {}
-            next_lane = lane.next(veh.route)
-            if next_lane and next_lane.get('junction'):
-                merge_dist = lane.length - veh.laneposition
-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
-                pos = other_lane.length if c.veh_junction else veh.laneposition
-                # Look for veh on other lane but do not extend past that lane
-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
-                    if other_veh.type is rl_type:
-                        default_human = default_close
-                        break
-
-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
-            ids.append(veh.id)
-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
-        
-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
-
-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
-        ttc = np.clip(ttc/7, -1, 1)
-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
-        drac = np.clip(drac/10, -1, 1)
-
-        raw_pet = self.calc_pet()
-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
-        pet = np.clip(pet, -1, 1)
-
-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
-        
-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
-        return returned
-        
-        # return Namespace(obs=obs, id=ids, reward=reward)
-    
-    def calc_ttc(self):
-        cur_veh_list = self.ts.vehicles
-        ttcs = []
-        for v in cur_veh_list:
-            leader, headway = v.leader()
-            v_speed = v.speed
-            leader_speed = leader.speed
-            if leader_speed < v_speed:
-                ttc =  headway/(v_speed-leader_speed)
-            else:
-                ttc = np.nan
-            ttcs.append(ttc)
-        fleet_ttc = np.nanmean(np.array(ttcs))
-        return fleet_ttc
-    
-    def calc_drac(self):
-        cur_veh_list = self.ts.vehicles
-        dracs = []
-        for v in cur_veh_list:
-            leader, headway = v.leader()
-            v_speed = v.speed
-            leader_speed = leader.speed
-            drac = 0.5*np.square(v_speed-leader_speed)/headway
-            dracs.append(drac)
-        fleet_drac = np.nanmean(np.array(dracs))
-        return fleet_drac
-
-    def calc_pet(self):
-        cur_veh_list = self.ts.vehicles
-        pets = []
-        for v in cur_veh_list:
-            leader, headway = v.leader()
-            v_speed = v.speed
-            if v_speed > 1e-16:
-                pet = headway/(v_speed)
-                pets.append(pet)
-        fleet_pet = np.nanmean(np.array(pets))
-        return fleet_pet
-
-class BNeck(Main):
-    def create_env(c):
-        return BNeckEnv(c)
-
-    @property
-    def observation_space(c):
-        low = np.full(c._n_obs, c.low)
-        return Box(low, np.ones_like(low))
-
-    @property
-    def action_space(c):
-        if c.vinitsky:
-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
-        if c.act_type in ['discretize', 'continuous', 'accel']:
-            assert c.lc_av in [False, 'binary']
-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
-        elif c.act_type in ['discrete', 'accel_discrete']:
-            return Discrete(c.n_actions)
-
-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
-        if c.vinitsky:
-            return super().on_rollout_end(rollout, stats, ii=n_ii)
-        log = c.get_log_ii(ii, n_ii)
-        step_obs_ = rollout.obs
-        step_obs = step_obs_[:-1]
-
-        ret, _ = calc_adv(rollout.reward, c.gamma)
-
-        n_veh = np.array([len(o) for o in step_obs])
-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
-        rollout.update(obs=step_obs, ret=step_ret)
-
-        step_id_ = rollout.pop('id')
-        id = np.concatenate(step_id_[:-1])
-        id_unique = np.unique(id)
-
-        reward = np.array(rollout.pop('reward'))
-
-        log(**stats)
-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
-        log(
-            n_veh_step_mean=n_veh.mean(), 
-            n_veh_step_sum=n_veh.sum(), 
-            n_veh_unique=len(id_unique),
-            
-            reward_mean=np.mean(reward),
-            reward_std=np.std(reward),        
-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
-            ssm_mean=np.mean(rollout.ssm),
-            ssm_std=np.std(rollout.ssm),
-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
-            drac_std=np.std(rollout.drac) if rollout.drac else None,
-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
-            pet_std=np.std(rollout.pet) if rollout.pet else None,
-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
-
-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
-            # nom_action = np.mean(rollout.nom_action),
-            # res_action = np.mean(rollout.res_action),
-            )
-        return rollout
-
-if __name__ == '__main__':
-    c = BNeck.from_args(globals(), locals()).setdefaults(
-        warmup_steps=1000,
-        horizon=2000,
-        n_steps=100,
-        step_save=5,
-
-        av_frac=0.2,
-        sim_step=0.5,
-        depart_speed=0,
-        edge_lengths=[100, 100, 50],
-        n_lanes=[4, 2, 1],
-        max_speed=30,
-
-        lc_av=False,
-        flow_rate=2300,
-        flow_rate_range=None,
-        split_flow=True,
-        generic_type='rand',
-        speed_mode=SPEED_MODE.all_checks,
-        lc_mode=LC_MODE.off,
-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
-
-        veh_junction=False,
-        act_type='accel_discrete',
-        max_accel=2.6,
-        max_decel=4.5,
-        tau=1.0,
-        min_gap=2.5,
-        delta=4,
-        n_actions=3,
-        low=-1,
-        handcraft=False,
-        vinitsky=False,
-
-        render=False,
-
-        alg=PG,
-        lr=1e-3,
-
-        gamma=0.99,
-        adv_norm=False,
-        batch_concat=True,
-
-        beta=0,
-        scale_ttc=1,
-        scale_drac=1,
-        seed_np=False,
-        seed_torch = False,
-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
-        mrtl=False, # this flag deals with adding beta to observation vector
-
-    )
-    
-    if c.seed_torch:
-        # Set seed for PyTorch CPU operations
-        torch.manual_seed(c.seed_torch)
-        # Set seed for PyTorch CUDA operations (if available)
-        if torch.cuda.is_available():
-            torch.cuda.manual_seed_all(c.seed_torch)
-    if c.seed_np:
-        np.random.seed(c.seed_np)
-        
-    if c.vinitsky:
-        c.piece_length = 20
-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
-        c._n_action = sum(n_actions[:-1])
-        c._n_obs = sum(n_actions) * 4 + 1
-        c.batch_concat = False
-    else:
-        c._n_obs = 2 + 2 + 2
-        
-    if c.mrtl:
-        c._n_obs += 1 # modified for mrtl related
-        
-    c.redef_sumo = bool(c.flow_rate_range)
-    c.run()
\ No newline at end of file
diff --git a/highway_ramp.py b/highway_ramp.py
deleted file mode 100644
index ef0358f..0000000
--- a/highway_ramp.py
+++ /dev/null
@@ -1,325 +0,0 @@
-from automatic_vehicular_control.exp import *
-from automatic_vehicular_control.env import *
-from automatic_vehicular_control.u import *
-
-class RampEnv(Env):
-    # https://flow-project.github.io/papers/08569485.pdf
-    def def_sumo(self):
-        c = self.c
-        builder = NetBuilder()
-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
-            (0, 0),
-            (c.premerge_distance, 0),
-            (c.premerge_distance + c.merge_distance, 0),
-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
-        ])
-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
-            {}, {'numLanes': 2}, {}
-        ], lane_maps=[
-            {0: 1}, {0: 0, 1: 0}
-        ], route_id='highway')
-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
-            {}, {'numLanes': 2}, {}
-        ], lane_maps=[
-            {0: 0}, {0: 0, 1: 0}
-        ], route_id='ramp')
-        nodes, edges, connections, routes = builder.build()
-        nodes[2].type = 'zipper'
-
-        routes = E('routes',
-            *routes,
-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
-        )
-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
-        additional = E('additional',
-            E('vType', id='generic', **idm),
-            E('vType', id='rl', **idm),
-            E('vType', id='human', **idm),
-        )
-        sumo_args = {'collision.action': COLLISION.remove}
-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
-
-    def step(self, action=[]):
-        c = self.c
-        ts = self.ts
-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
-        max_speed = c.max_speed
-        human_type = ts.types.human
-        rl_type = ts.types.rl
-
-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
-        for rl, act in zip(prev_rls, action):
-            if c.handcraft:
-                route, edge, lane = rl.route, rl.edge, rl.lane
-                leader, dist = rl.leader()
-                level = 1
-                if edge.id == 'e_n_0.0_n_400.0':
-                    if rl.laneposition < 100:
-                        leaders = list(rl.leaders())
-                        if len(leaders) > 20:
-                            level = 0
-                        else:
-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
-                continue
-            if not isinstance(act, (int, np.integer)):
-                act = (act - c.low) / (1 - c.low)
-            if c.act_type.startswith('accel'):
-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
-            else:
-                if c.act_type == 'continuous':
-                    level = act[0]
-                elif c.act_type == 'discretize':
-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
-                elif c.act_type == 'discrete':
-                    level = act / (c.n_actions - 1)
-                ts.set_max_speed(rl, max_speed * level)
-
-        super().step()
-
-        route = ts.routes.highway
-        obs, ids = [], []
-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
-            if hasattr(veh, 'edge'):
-                speed, edge, lane = veh.speed, veh.edge, veh.lane
-                merge_dist = max_dist
-
-                lead_speed = follow_speed = other_speed = 0
-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
-
-                leader, dist = veh.leader()
-                if leader: lead_speed, lead_dist = leader.speed, dist
-
-                follower, dist = veh.follower()
-                if follower: follow_speed, follow_dist = follower.speed, dist
-
-                if c.global_obs:
-                    jun_edge = edge.next(route)
-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
-                        jun_edge = jun_edge.next(route)
-                    if jun_edge:
-                        merge_dist = lane.length - veh.laneposition
-                        next_edge = edge.next(route)
-                        while next_edge is not jun_edge:
-                            merge_dist += next_edge.length
-                            next_edge = next_edge.next(route)
-
-                        other_lane = jun_edge.lanes[0]
-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
-                            other_speed = other_veh.speed
-                            break
-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
-                else:
-                    next_lane = lane.next(route)
-                    if next_lane and next_lane.get('junction'):
-                        if len(edge.lanes) == 2:
-                            other_lane = edge.lanes[0]
-                            pos = veh.laneposition
-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
-                                other_speed = other_veh.speed
-                                break
-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
-                ids.append(veh.id)
-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
-        if c.mrtl:
-            obs = np.concatenate([obs, np.array([c.beta])])
-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
-        
-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
-
-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
-        ttc = np.clip(ttc/7, -1, 1)
-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
-        drac = np.clip(drac/10, -1, 1)
-
-        raw_pet = self.calc_pet()
-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
-        pet = np.clip(pet, -1, 1)
-
-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
-        
-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
-        return returned
-        
-        # return Namespace(obs=obs, id=ids, reward=reward)
-    
-    def calc_ttc(self):
-        cur_veh_list = self.ts.vehicles
-        ttcs = []
-        for v in cur_veh_list:
-            if hasattr(v, 'edge'):
-                leader, headway = v.leader()
-                if leader:
-                    v_speed = v.speed
-                    leader_speed = leader.speed
-                    if leader_speed < v_speed:
-                        ttc =  headway/(v_speed-leader_speed)
-                    else:
-                        ttc = np.nan
-                    ttcs.append(ttc)
-        fleet_ttc = np.nanmean(np.array(ttcs))
-        return fleet_ttc
-    
-    def calc_drac(self):
-        cur_veh_list = self.ts.vehicles
-        dracs = []
-        for v in cur_veh_list:
-            if hasattr(v, 'edge'):
-                leader, headway = v.leader()
-                if leader:
-                    v_speed = v.speed
-                    leader_speed = leader.speed
-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
-                    dracs.append(drac)
-        fleet_drac = np.nanmean(np.array(dracs))
-        return fleet_drac
-
-    def calc_pet(self):
-        cur_veh_list = self.ts.vehicles
-        pets = []
-        for v in cur_veh_list:
-            if hasattr(v, 'edge'):
-                leader, headway = v.leader()
-                if leader:
-                    v_speed = v.speed
-                    if v_speed > 1e-16:
-                        pet = headway/(v_speed)
-                        pets.append(pet)
-        fleet_pet = np.nanmean(np.array(pets))
-        # return fleet_pet if not np.isnan(fleet_pet) else 1
-        return fleet_pet
-
-class Ramp(Main):
-    def create_env(c):
-        return RampEnv(c)
-
-    @property
-    def observation_space(c):
-        low = np.full(c._n_obs, c.low)
-        return Box(low, np.ones_like(low))
-
-    @property
-    def action_space(c):
-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
-        if c.act_type in ['discretize', 'continuous', 'accel']:
-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
-        elif c.act_type in ['discrete', 'accel_discrete']:
-            return Discrete(c.n_actions)
-
-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
-        log = c.get_log_ii(ii, n_ii)
-        step_obs_ = rollout.obs
-        step_obs = step_obs_[:-1]
-
-        ret, _ = calc_adv(rollout.reward, c.gamma)
-
-        n_veh = np.array([len(o) for o in step_obs])
-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
-        rollout.update(obs=step_obs, ret=step_ret)
-
-        step_id_ = rollout.pop('id')
-        id = np.concatenate(step_id_[:-1])
-        id_unique = np.unique(id)
-
-        reward = np.array(rollout.pop('reward'))
-
-        log(**stats)
-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
-        log(
-            n_veh_step_mean=n_veh.mean(), 
-            n_veh_step_sum=n_veh.sum(), 
-            n_veh_unique=len(id_unique),
-            
-            reward_mean=np.mean(reward),
-            reward_std=np.std(reward),        
-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
-            ssm_mean=np.mean(rollout.ssm),
-            ssm_std=np.std(rollout.ssm),
-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
-            drac_std=np.std(rollout.drac) if rollout.drac else None,
-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
-            pet_std=np.std(rollout.pet) if rollout.pet else None,
-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
-
-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
-            # nom_action = np.mean(rollout.nom_action),
-            # res_action = np.mean(rollout.res_action),
-            )
-        return rollout
-
-if __name__ == '__main__':
-    c = Ramp.from_args(globals(), locals()).setdefaults(
-        warmup_steps=100,
-        horizon=2000,
-        n_steps=100,
-        step_save=5,
-
-        premerge_distance=400,
-        merge_distance=100,
-        postmerge_distance=30,
-        av_frac=0.1,
-        sim_step=0.5,
-        max_speed=30,
-        highway_depart_speed=10,
-        ramp_depart_speed=0,
-        highway_flow_rate=2000,
-        ramp_flow_rate=300,
-        global_obs=False,
-        handcraft=False,
-
-        generic_type='default',
-        speed_mode=SPEED_MODE.all_checks,
-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
-
-        act_type='accel_discrete',
-        max_accel=1,
-        max_decel=1.5,
-        n_actions=3,
-        low=-1,
-
-        render=False,
-
-        alg=PG,
-        lr=1e-3,
-
-        gamma=0.99,
-        adv_norm=False,
-        batch_concat=True,
-
-        beta=0,
-        scale_ttc=1,
-        scale_drac=1,
-        seed_np=False,
-        seed_torch = False,
-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
-        mrtl=False, # this flag deals with adding beta to observation vector
-
-    )
-    
-    if c.seed_torch:
-        # Set seed for PyTorch CPU operations
-        torch.manual_seed(c.seed_torch)
-        # Set seed for PyTorch CUDA operations (if available)
-        if torch.cuda.is_available():
-            torch.cuda.manual_seed_all(c.seed_torch)
-    if c.seed_np:
-        np.random.seed(c.seed_np)
-        
-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
-    if c.mrtl:
-        c._n_obs += 1 # modified for mrtl related
-    c.run()
\ No newline at end of file
diff --git a/intersection.py b/intersection.py
deleted file mode 100644
index e38a84f..0000000
--- a/intersection.py
+++ /dev/null
@@ -1,489 +0,0 @@
-from automatic_vehicular_control.u import *
-from automatic_vehicular_control.exp import *
-from automatic_vehicular_control.env import *
-
-class Platoon(Entity):
-    pass
-
-class IntersectionEnv(Env):
-    def def_sumo(self):
-        c = self.c
-
-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
-        ] if params.get('vehsPerHour')]
-
-        builder = NetBuilder()
-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
-        if c.enter_length:
-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
-            xys[1:, :, 0] += c.enter_length - c.length
-            xys[:, 1:, 1] += c.enter_length - c.length
-            xys = xys.reshape(-1, 2)
-        if c.short_exit:
-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
-            xys[-1, :, 0] += c.short_exit - c.length
-            xys[:, -1, 1] += c.short_exit - c.length
-            xys = xys.reshape(-1, 2)
-        nodes = builder.add_nodes(
-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
-        ).reshape(c.n_rows + 2, c.n_cols + 2)
-        # import pdb; pdb.set_trace()
-
-        tl = c.setdefault('tl', False)
-        if tl:
-            c.av_frac = 0
-            c.pop('av_range', None)
-            c.speed_mode = SPEED_MODE.all_checks
-
-        flows = []
-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
-        for direction in c.directions:
-            chains = nodes if direction in ['left', 'right'] else nodes.T
-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
-
-            edge_attrs = dict(priority=int(direction in priority))
-            if c.get('set_edge_speed', True):
-                edge_attrs['speed'] = c.max_speed
-
-            for i, chain in enumerate(chains[1:-1]):
-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
-                flows.extend(default_flows(flow_id, route_id, flow_rate))
-
-        tls = []
-        if tl:
-            tl = 1000000 if tl == 'MaxPressure' else tl
-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
-            tl_offset = c.get('tl_offset', 'auto')
-            yellow = c.get('yellow', 0.5)
-            if tl_offset == 'auto':
-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
-            elif tl_offset == 'same':
-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
-                node.type = 'traffic_light'
-                phase_multiple = len(c.directions) // 2
-                tls.append(E('tlLogic',
-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
-                id=node.id, offset=offset, type='static', programID='1'))
-
-        nodes, edges, connections, routes = builder.build()
-        additional = E('additional', *types, *routes, *flows, *tls)
-        return super().def_sumo(nodes, edges, connections, additional)
-
-    def build_platoon(self):
-        ts = self.ts
-        rl_type = ts.types.rl
-        for route in ts.routes:
-            vehs = []
-            route_offset = 0
-            for edge in route.edges:
-                for veh in edge.vehicles:
-                    veh.route_position = route_offset + veh.laneposition
-                    vehs.append(veh)
-                route_offset += edge.length
-
-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
-            rl_idxs, = rl_mask.nonzero()
-            split_idxs = 1 + rl_idxs
-
-            prev = None
-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
-                if not len(vehs_i):
-                    continue # Last vehicle is RL, so the last split is empty
-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
-                )
-                if prev is not None:
-                    prev.next = platoon
-                prev = platoon
-                for veh in vehs_i:
-                    veh.platoon = platoon
-            if prev is not None:
-                prev.next = None
-
-    def reset(self):
-        c = self.c
-        if c.e is False:
-            if 'length_range' in c:
-                min_, max_ = c.length_range
-                c.setdefaults(max_length=max_)
-                c.length = np.random.randint(min_, max_ + 1)
-            if 'av_range' in c:
-                min_, max_ = c.av_range
-                c.av_frac = np.random.uniform(min_, max_)
-        self.mp_tlast = 0
-        while not self.reset_sumo():
-            pass
-        ret = super().init_env()
-        return ret
-
-    def step(self, action=[]):
-        c = self.c
-        ts = self.ts
-        max_dist = c.max_dist
-        depart_speed = c.depart_speed
-        max_speed = c.max_speed
-
-        rl_type = ts.types.rl
-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
-
-        for rl, act in zip(prev_rls, action):
-            if c.handcraft or c.handcraft_tl:
-                route, lane = rl.route, rl.lane
-                junction = lane.next_junction
-                level = 1
-                if junction is not ts.sentinel_junction:
-                    dist = junction.route_position[route] - rl.route_position
-                    if c.handcraft:
-                        for cross_lane in lane.next_cross_lanes:
-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
-                    elif c.handcraft_tl and dist < 15:
-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
-                        yellow_time = 0
-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
-                        horizontal_go = 0 <= rem < t_h
-                        vertical_go = t_h + yellow_time <= rem
-                        horizontal_lane = 'left' in route.id or 'right' in route.id
-                        human_remain = False
-                        for cross_lane in lane.next_cross_lanes:
-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
-                            human_remain = cross_veh and cross_veh.type is not rl_type
-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
-            elif c.act_type == 'accel':
-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
-            else:
-                level = act / (c.n_actions - 1)
-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
-
-        if c.tl == 'MaxPressure':
-            self.mp_tlast += c.sim_step
-            tmin = c.get('mp_tmin', 0)
-            if self.mp_tlast >= tmin:
-                for tl in ts.traffic_lights:
-                    if ts.get_program(tl) == 'off':
-                        break
-                    jun = tl.junction
-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
-
-                    total_pressures = []
-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
-
-                    ts.set_phase(tl, np.argmax(total_pressures))
-                self.mp_tlast = 0
-
-        super().step()
-        self.build_platoon()
-
-        obs = {}
-
-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
-        for veh in rl_type.vehicles:
-            if hasattr(veh, 'lane'):
-                route, lane, platoon = veh.route, veh.lane, veh.platoon
-                junction = lane.next_junction
-
-                head, tail = veh, platoon.tail
-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
-
-                if junction is ts.sentinel_junction:
-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
-                else:
-                    for jun_lane in lane.next_junction_lanes:
-                        # Defaults for jun_lane
-                        jun_headtails = vehs_default()
-
-                        jun_lane_route = nexti(jun_lane.from_routes)
-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
-
-                        if jun_veh:
-                            if jun_veh.type is rl_type:
-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
-                                platoon = jun_veh.platoon.prev
-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
-                                    if platoon is None: break
-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
-                                    platoon = platoon.prev
-                            else:
-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
-                                jun_headtails[0] = jun_veh.platoon.tail
-                                next_cross_platoon = jun_veh.platoon.prev
-                                if next_cross_platoon:
-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
-                                    platoon = next_cross_platoon.prev
-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
-                                        if platoon is None: break
-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
-                                        platoon = platoon.prev
-                        route_vehs.append((jun_lane_route, jun_headtails))
-
-                dist_features, speed_features = [], []
-                for route, vehs in route_vehs:
-                    j_pos = junction.route_position[route]
-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
-                    speed_features.extend([v.speed / max_speed for v in vehs])
-
-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
-
-        sort_id = lambda d: [v for k, v in sorted(d.items())]
-        ids = sorted(obs)
-        if c.mrtl:
-            obs = np.concatenate([obs, np.array([c.beta])])
-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
-        if c.rew_type == 'outflow':
-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
-        elif c.rew_type == 'time_penalty':
-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
-        
-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
-
-        raw_drac = self.calc_drac()
-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
-        drac = np.clip(drac/10, -1, 1)
-        raw_pet = self.calc_pet()
-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
-        pet = np.clip(pet/6, -1, 1)
-
-        raw_ttc = self.calc_ttc()
-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
-        ttc = np.clip(ttc/7, -1, 1)
-
-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
-
-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
-        return returned
-        # return Namespace(obs=obs, id=ids, reward=reward)
-        
-    def calc_drac(self):
-        cur_veh_list = self.ts.vehicles
-        dracs = []
-        for v in cur_veh_list:
-            if hasattr(v, 'lane'):
-                leader, headway = v.leader()
-                v_speed = v.speed
-                leader_speed = leader.speed
-                drac = 0.5*np.square(v_speed-leader_speed)/headway
-                dracs.append(drac)
-        fleet_drac = np.nanmean(np.array(dracs))
-        return fleet_drac
-    
-    def calc_pet(self):
-        cur_veh_list = self.ts.vehicles
-        pets = []
-        for v in cur_veh_list:
-            if hasattr(v, 'lane'):
-                leader, headway = v.leader()
-                v_speed = v.speed
-                if v_speed > 1e-16:
-                    pet = headway/(v_speed)
-                    pets.append(pet)
-        fleet_pet = np.nanmean(np.array(pets))
-        return fleet_pet
-
-    def calc_ttc(self):
-        cur_veh_list = self.ts.vehicles
-        ttcs = []
-        for v in cur_veh_list:
-            if hasattr(v, 'lane'):
-                leader, headway = v.leader()
-                v_speed = v.speed
-                leader_speed = leader.speed
-                if leader_speed < v_speed:
-                    ttc =  headway/(v_speed-leader_speed)
-                else:
-                    ttc = np.nan
-                ttcs.append(ttc)
-        fleet_ttc = np.nanmean(np.array(ttcs))
-        return fleet_ttc
-
-    def append_step_info(self):
-        super().append_step_info()
-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
-
-    @property
-    def stats(self):
-        c = self.c
-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
-        mean = lambda L: np.mean(L) if len(L) else np.nan
-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
-        stats['backlog_step'] = mean(info['backlog'])
-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
-
-        stats['beta'] = c.beta
-
-        if c.multi_flowrate:
-            stats['flow_horizontal'] = c.flow_rate_h
-            stats['flow_vertical'] = c.flow_rate_v
-        return stats
-
-class Intersection(Main):
-    def create_env(c):
-        if c.multi_flowrate:
-            return NormEnv(c, IntersectionEnv(c))
-        else:
-            c._norm = NormEnv(c, None)
-            return IntersectionEnv(c)
-
-    @property
-    def observation_space(c):
-        low = np.full(c._n_obs, c.low)
-        return Box(low, np.ones_like(low))
-
-    @property
-    def action_space(c):
-        if c.act_type == 'accel':
-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
-        else:
-            return Discrete(c.n_actions)
-
-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
-        log = c.get_log_ii(ii, n_ii)
-        step_obs_ = rollout.obs
-        step_obs = step_obs_[:-1]
-
-        if not c.multi_flowrate:
-            rollout.raw_reward = rollout.reward
-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
-
-        ret, _ = calc_adv(rollout.reward, c.gamma)
-
-        n_veh = np.array([len(o) for o in step_obs])
-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
-        rollout.update(obs=step_obs, ret=step_ret)
-
-        step_id_ = rollout.pop('id')
-        id = np.concatenate(step_id_[:-1])
-        id_unique = np.unique(id)
-
-        reward = np.array(rollout.pop('reward'))
-        raw_reward = np.array(rollout.pop('raw_reward'))
-
-        log(**stats)
-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
-        log(
-            n_veh_step_mean=n_veh.mean(), 
-            n_veh_step_sum=n_veh.sum(), 
-            n_veh_unique=len(id_unique),
-            
-            reward_mean=np.mean(reward),
-            reward_std=np.std(reward),        
-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
-            ssm_mean=np.mean(rollout.ssm),
-            ssm_std=np.std(rollout.ssm),
-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
-            drac_std=np.std(rollout.drac) if rollout.drac else None,
-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
-            pet_std=np.std(rollout.pet) if rollout.pet else None,
-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
-
-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
-            # nom_action = np.mean(rollout.nom_action),
-            # res_action = np.mean(rollout.res_action),
-            )
-        
-        return rollout
-
-if __name__ == '__main__':
-    c = Intersection.from_args(globals(), locals())
-    c.setdefaults(
-        n_steps=200,
-        step_save=5,
-
-        depart_speed=0,
-        max_speed=13,
-        max_dist=100,
-        max_accel=1.5,
-        max_decel=3.5,
-        sim_step=0.5,
-        generic_type=True,
-        n_actions=3,
-
-        adv_norm=False,
-        batch_concat=True,
-
-        render=False,
-
-        warmup_steps=100,
-        horizon=2000,
-        directions='4way',
-        av_frac=0.15,
-        handcraft=False,
-        handcraft_tl=None,
-        flow_rate=700,
-        length=100,
-        n_rows=1,
-        n_cols=1,
-        speed_mode=SPEED_MODE.obey_safe_speed,
-
-        act_type='accel_discrete',
-        low=-1,
-
-        alg=PG,
-        n_gds=1,
-        lr=1e-3,
-        gamma=0.99,
-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
-
-        enter_length=False,
-        short_exit=False,
-
-        rew_type='outflow',
-        norm_reward=True,
-        center_reward=True,
-        multi_flowrate=False,
-        opt='RMSprop',
-
-        obs_tail=True,
-        obs_next_cross_platoons=1,
-
-        beta=0,
-        scale_pet=1,
-        scale_drac=1,
-        seed_np=False,
-        seed_torch = False,
-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
-        mrtl=False, # this flag deals with adding beta to observation vector
-    )
-
-    if c.seed_torch:
-        # Set seed for PyTorch CPU operations
-        torch.manual_seed(c.seed_torch)
-        # Set seed for PyTorch CUDA operations (if available)
-        if torch.cuda.is_available():
-            torch.cuda.manual_seed_all(c.seed_torch)
-    if c.seed_np:
-        np.random.seed(c.seed_np)
-
-    if c.directions == '4way':
-        c.directions = ['up', 'right', 'down', 'left']
-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
-    if c.mrtl:
-        c._n_obs += 1
-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
-    c.redef_sumo = 'length_range' in c
-    c.run()
\ No newline at end of file
diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
index d4c3dac..6d655b1 100644
--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
@@ -1,600 +1,26696 @@
-diff --git a/README.md b/README.md
-index b591747..127f484 100644
---- a/README.md
-+++ b/README.md
-@@ -39,7 +39,7 @@ conda env create -f environment.yml
- ### 1.2 Set the environmental variables
- ```
- # Code directory
--export F=automatic_vehicular_control/automatic_vehicular_control
-+export F=automatic_vehicular_control
- 
- # Results directory extracted from the zip file
- export R=results
-@@ -48,10 +48,8 @@ export R=results
- ## 2. Directory Structure
- 
- The code directory structure is
--```
-+``` 
- automatic_vehicular_control/
--│
--├── automatic_vehicular_control/
- │   ├── __pycache__/                # Compiled Python files
- │   ├── evaluations/                # Evaluation results and metrics
- │   ├── models/                     # Model checkpoints
 diff --git a/env.py b/env.py
-index 4ab3d95..c83a674 100644
+index c83a674..0bcfb8e 100644
 --- a/env.py
 +++ b/env.py
-@@ -724,9 +724,11 @@ class TrafficState:
-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
- 
-         segments = {}
+@@ -852,12 +852,15 @@ class TrafficState:
+         subscribes.sim = SubscribeDef(tc.simulation, [
+             V.departed_vehicles_ids, V.arrived_vehicles_ids,
+             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
 +        
-         def add_from_to(from_, to):
-             from_.tos.add(to)
-             to.froms.add(from_)
-+            
-         for con in map(values_str_to_val, net.children('connection')):
-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
-             to_lane = edges[con.to].lanes[int(con.toLane)]
-@@ -888,89 +890,109 @@ class TrafficState:
- 
-     def step(self):
-         """
--        Take a simulation step and update state
-+        Take a simulation step and update state.
-         """
--        c = self.c
--        tc = self.tc
--        subscribes = self.subscribes
-+        c = self.c  # Configuration object for the simulation
-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
- 
-         # Actual SUMO step
--        tc.simulationStep()
--        sim_res = subscribes.sim.get()
-+        tc.simulationStep()  # Advances the SUMO simulation by one step
-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
- 
-+        # Clear references to current vehicle edges and lanes for the next update
-         for veh in self.vehicles:
--            veh.unvar('edge', 'lane')
-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
-+
-+        # Clear current vehicle data from edges and lanes
-         for ent in itertools.chain(self.edges, self.lanes):
--            ent.vehicles.clear()
--            ent.positions.clear()
-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
-+            ent.positions.clear()  # Clear vehicle positions
- 
-+        # Update traffic light states
-         for tl_id, tl in self.traffic_lights.items():
--            tl.update(subscribes.tl.get(tl_id))
-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
- 
-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
-         for veh_id in sim_res.loaded_vehicles_ids:
--            flow_id, _ = veh_id.rsplit('.')
--            flow = self.flows[flow_id]
--            flow.backlog.add(veh_id)
-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
-+            flow = self.flows[flow_id]  # Get the corresponding flow object
-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
- 
-+        # Initialize a set for newly departed vehicles
-         self.new_departed = set()
-+
-+        # Handle vehicles that have departed (entered the network)
-         for veh_id in sim_res.departed_vehicles_ids:
--            subscribes.veh.subscribe(veh_id)
--            type_id = tc.vehicle.getTypeID(veh_id)
--            # import pdb; pdb.set_trace()
-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
-+            # If vehicle type is 'generic', compute specific type
-             if type_id == 'generic':
-                 type_id = self.compute_type(veh_id)
--            type_ = self.types[type_id]
--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
--            length = tc.vehicle.getLength(veh_id)
--            road_id = tc.vehicle.getRoadID(veh_id)
--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
--            type_.vehicles.add(veh)
-+            type_ = self.types[type_id]  # Get vehicle type object
-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
-+
-+            # Create a new vehicle object and add it to the list of vehicles
-+            self.vehicles[veh_id] = veh = Vehicle(
-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
-+            )
-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
- 
-+            # Set color if rendering is enabled
-             if c.render:
-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
--                self.set_color(veh, color_fn(veh))
-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
- 
-+            # Set vehicle speed mode and lane change mode using SUMO settings
-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
-+
-+            # Add to new_departed set
-             self.new_departed.add(veh)
-+
-+            # Remove vehicle from backlog if necessary
-             if '.' in veh_id:
-                 flow_id, _ = veh_id.rsplit('.')
-                 if flow_id in self.flows:
-                     flow = self.flows[flow_id]
-                     flow.backlog.remove(veh_id)
- 
-+        # Handle newly arrived and collided vehicles
-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+         subscribes.tl = SubscribeDef(tc.trafficlight, [
+             TL.red_yellow_green_state])
 +        
-+        # Remove newly arrived vehicles from tracking if they collided
-         for veh in self.new_arrived:
--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
- 
-+        # Update vehicle positions on edges and lanes
-         for veh_id, veh in self.vehicles.items():
--            veh.prev_speed = veh.get('speed', None)
--            veh.update(subscribes.veh.get(veh_id))
-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
-             if veh_id not in sim_res.colliding_vehicles_ids:
--                edge = self.edges[veh.road_id]
--                edge.vehicles.append(veh)
--                veh.edge = edge
--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
--            # edge = self.edges[veh.road_id]
--            # edge.vehicles.append(veh)
--            # veh.edge = edge
-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
-+                veh.edge = edge  # Set vehicle's edge attribute
- 
-+        # Update vehicle sorting and lane positions
-         for edge in self.edges:
--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
--            edge.positions = [veh.laneposition for veh in edge.vehicles]
-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
-             for edge_i, veh in enumerate(edge.vehicles):
--                veh.edge_i = edge_i
--                veh.lane = lane = edge.lanes[veh.lane_index]
--                veh.lane_i = len(lane.vehicles)
--                lane.vehicles.append(veh)
--                lane.positions.append(veh.laneposition)
-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
- 
-+        # Record sets of vehicles that have arrived, departed, or collided during this step
-         self.all_arrived.append(self.new_arrived)
-         self.all_departed.append(self.new_departed)
-         self.all_collided.append(self.new_collided)
--
-+            
-     def reset(self, tc):
-         self.tc = tc
-         self.subscribes.clear()
-@@ -1043,6 +1065,7 @@ class Env:
-     """
-     Offers a similar reinforcement learning environment interface as gym.Env
-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
-+    c: Ring class
-     """
-     def __init__(self, c):
-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
-@@ -1056,6 +1079,7 @@ class Env:
-             if c.get('save_agent'):
-                 self._agent_info = []
-         self._step = 0
-+        self.mean_speed = 0
- 
-     def def_sumo(self, *args, **kwargs):
-         """ Override this with code defining the SUMO network """
-@@ -1094,49 +1118,91 @@ class Env:
-         """
-         return True
- 
-+   # Method to reset or initialize the SUMO traffic simulation environment
-     def reset_sumo(self):
-+        # Shortcuts for configuration and SUMO definition objects
-         c = self.c
-         sumo_def = self.sumo_def
--
--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
-+        
-+        # Determine if new SUMO definitions need to be generated
-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
-+        
-         if generate_def:
--            kwargs = self.def_sumo()
--            kwargs['net'] = sumo_def.generate_net(**kwargs)
--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
-+            # Generate new definitions if necessary
-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
-+        
-+        # Start SUMO with the current traffic controller (tc)
-         self.tc = sumo_def.start_sumo(self.tc)
+         subscribes.veh = SubscribeDef(tc.vehicle, [
+             V.road_id, V.lane_index, V.laneposition,
+             V.speed, V.position, V.angle,
+             V.fuelconsumption, V.noxemission])
 +        
-         if generate_def:
-+            # If new definitions were generated, store relevant SUMO file paths
-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
-+            
-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
--            self.ts = TrafficState(c, self.tc, **defs)
-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
-         else:
-+            # If not generating new definitions, simply reset the existing traffic state
-             self.ts.reset(self.tc)
-+        
-+        # Set up the traffic state (e.g., initialize the simulation settings)
-         self.ts.setup()
-+        
-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
-         success = self.init_vehicles()
-+        
-+        # Return whether the SUMO reset and vehicle initialization were successful
-         return success
+         for tl_id in self.traffic_lights.keys():
+             subscribes.tl.subscribe(tl_id)
  
-+    # Method to initialize the environment after SUMO reset
-     def init_env(self):
-+        # Reference to the traffic state
-         ts = self.ts
+@@ -1109,6 +1112,26 @@ class Env:
+         if self._vehicle_info is not None:
+             self.extend_vehicle_info()
+         self._step += 1
++        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++        return c.observation_space.low, 0, False, None
 +    
-+        # Create an empty data structure to store rollout information
-         self.rollout_info = NamedArrays()
-+        
-+        # Turn off all traffic lights in the network
-         for tl in ts.traffic_lights:
--            ts.set_program(tl, 'off')
-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
-+        
-+        # Reset the step counter to 0
-         self._step = 0
-+        
-+        # Take the first step in the simulation
-         ret = self.step()
-+        
-+        # Run the simulation for a number of warmup steps
-         for _ in range(self.c.warmup_steps):
--            ret = self.step()
-+            ret = self.step()  # Advance the simulation one step
-+            
-+            # If the simulation ends during the warmup phase, return None to indicate failure
-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
-                 return None
-+        
-+        # After warmup, turn traffic lights back on (set to a defined program '1')
-         for tl in ts.traffic_lights:
--            ts.set_program(tl, '1')
-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
-+        
-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
-         if isinstance(ret, tuple):
--            return ret[0]
--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
--
-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
-+        
-+    # Reset the entire environment, retrying until successful
-     def reset(self):
--        while True:
-+        self.mean_speed = 0
-+        while True:  # Infinite loop until the environment is successfully reset
-+            # Attempt to reset the SUMO simulation
-             if not self.reset_sumo():
--                continue
-+                continue  # If reset_sumo fails, retry the loop
-+            
-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
-             if (obs := self.init_env()) is not None:
--                return obs
-+                return obs  # Successfully initialized, return the observation
-+
++    
++    def step_2(self, *args):
++        """
++        Override this with additional code which applies acceleration and measures observation and reward
++        """
++        c, ts = self.c, self.ts
++        if c.get('custom_idm'):
++            idm = c.custom_idm
++            for veh in ts.types.human.vehicles:
++                leader, headway = veh.leader()
++                v = veh.speed
++                s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
++                a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
++                noise = np.random.normal(0, idm.sigma)
++                ts.accel(veh, a + noise)
++        self._step += 1
++        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+         return c.observation_space.low, 0, False, None
  
-     def append_step_info(self):
-         """
-@@ -1231,6 +1297,8 @@ class Env:
- class NormEnv(gym.Env):
-     """
-     Reward normalization with running average https://github.com/joschu/modular_rl
-+    self.c: Ring parameters 
-+    self.env: RingEnv class
-     """
-     def __init__(self, c, env):
-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
+     def init_vehicles(self):
+@@ -1197,6 +1220,7 @@ class Env:
+         while True:  # Infinite loop until the environment is successfully reset
+             # Attempt to reset the SUMO simulation
+             if not self.reset_sumo():
++                
+                 continue  # If reset_sumo fails, retry the loop
+             
+             # Initialize the environment. If initialization is successful (obs is not None), return the observation
 diff --git a/exp.py b/exp.py
-index ead4652..7f7cee5 100644
+index 7f7cee5..43481b1 100644
 --- a/exp.py
 +++ b/exp.py
-@@ -169,9 +169,9 @@ class Main(Config):
- 
-     def on_train_start(c):
-         # Initialize training: environment, algorithm, model, optimizer, and logging
--        c.setdefaults(alg='Algorithm')
--        c._env = c.create_env()
--
-+        c.setdefaults(alg='Algorithm') 
-+        c._env = c.create_env() # Create NormEnv
-+ 
-         # Instantiate the algorithm (e.g., PPO, DQN)
-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
-         c.set_model()
-@@ -222,8 +222,8 @@ class Main(Config):
- 
-     def on_step_start(c, stats={}):
-         # Update the learning rate and log stats at the start of a training step
--        lr = c._lr
--        for g in c._opt.param_groups:
-+        lr = c._lr # Update Learning Rate
-+        for g in c._opt.param_groups: # Log Statistics
-             g['lr'] = float(lr)
-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
- 
-@@ -285,10 +285,14 @@ class Main(Config):
+@@ -285,11 +285,10 @@ class Main(Config):
              ret = dict(obs=ret)
          rollout = NamedArrays()
          rollout.append(**ret)
--
-+        rollout_flow_each_step = []
+-        rollout_flow_each_step = []
          done = False
          a_space = c.action_space
          step = 0
-+        density = 20/(250*1e-3)
-+        vehicle_flow = c._env.mean_speed * 3.6 * density 
-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
-+
-         while step < c.horizon + c.skip_stat_steps and not done:
-             # Generate an action from the model's policy
-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
-@@ -309,6 +313,12 @@ class Main(Config):
-             rollout.append(**ret)
-             step += 1
+-        density = 20/(250*1e-3)
++        density = c.var().n_veh/(c.var().circumference*1e-3)
+         vehicle_flow = c._env.mean_speed * 3.6 * density 
+         print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+ 
+@@ -315,8 +314,7 @@ class Main(Config):
          # Collect stats from the environment
-+        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
-+        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
-+        density = 20/(250 * 1e-3)
-+        vehicle_flow = c._env.mean_speed * density 
-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
-+
+         # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+         # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+-        density = 20/(250 * 1e-3)
+-        vehicle_flow = c._env.mean_speed * density 
++        vehicle_flow = c._env.mean_speed * density  * 3.6
+         print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+ 
          stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
-         return rollout, stats
+@@ -406,9 +404,8 @@ class Main(Config):
  
-@@ -398,10 +408,10 @@ class Main(Config):
+     def train(c):
          # Main training loop
-         c.on_train_start()
+-        c.on_train_start()
++        c.on_train_start() # Ring Env
          while c._i < c.n_steps:
--            c.on_step_start()
-+            c.on_step_start() # save stat 
+-            c.on_step_start() # save stat 
              with torch.no_grad():
                  # Collect rollouts without computing gradients
--                rollouts = c.rollouts()
-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
-             gd_stats = {}
-             if len(rollouts.obs):
-                 t_start = time()
-@@ -410,7 +420,7 @@ class Main(Config):
-                 gd_stats.update(gd_time=time() - t_start)
-             c.on_step_end(gd_stats)
-             c._i += 1
--        c.on_step_start()  # last step
-+        c.on_step_start()  # save stat
-         gd_stats = {}
-         with torch.no_grad():
-             rollouts = c.rollouts()
-@@ -450,6 +460,8 @@ class Main(Config):
-         if hasattr(c._env, 'close'):
-             c._env.close()
- 
-+  
+                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+@@ -497,3 +494,31 @@ class Main(Config):
+             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
+             c.train()
+         c.log('job done!')
 +
-     def run(c):
-         # Determine whether to train or evaluate based on configuration
-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
-diff --git a/ring.py b/ring.py
-index 94d632d..ee1372b 100644
---- a/ring.py
-+++ b/ring.py
-@@ -15,7 +15,6 @@ class RingEnv(Env):
-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
-         )
++    def run_2(c):
++        # Determine whether to train or evaluate based on configuration
++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
++        c.on_train_start()
++        c._env = c.create_env() # Create NormEnv
++        ret = c._env.reset()
++        c.set_model()
++        step = 0
++        density = 20/(250*1e-3)
++        vehicle_flow = c._env.mean_speed * 3.6 * density 
++        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++        done = False
++        while step < c.horizon + c.skip_stat_steps and not done:
++            # Take a step in the environment
++            ret = c._env.step()
++            if isinstance(ret, tuple):
++                obs, reward, done, info = ret
++                ret = dict(obs=obs, reward=reward, done=done, info=info)
++            done = ret.setdefault('done', False)
++            step += 1
++        # Collect stats from the environment
++        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++        density = 20/(250 * 1e-3)
++        vehicle_flow = c._env.mean_speed * density 
++        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+diff --git a/highway_bottleneck.py b/highway_bottleneck.py
+deleted file mode 100644
+index 6b9ba52..0000000
+--- a/highway_bottleneck.py
++++ /dev/null
+@@ -1,381 +0,0 @@
+-from automatic_vehicular_control.exp import *
+-from automatic_vehicular_control.env import *
+-from automatic_vehicular_control.u import *
 -
-         # Function to generate the shape of the edges (circular arcs)
-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
- 
-@@ -88,6 +87,17 @@ class RingEnv(Env):
-         if c.circumference_range:  # Check if the circumference should be randomized
-             # Randomly set the circumference within the specified range
-             c.circumference = np.random.randint(*c.circumference_range)
-+        
-+        if self.flow_log:
-+            average_flow = sum(self.flow_log) / len(self.flow_log)
-+            self.episode_flow.append(average_flow)
-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
-+        
-+        # Reset flow counters for the new episode
-+        self.flow_counter = 0
-+        self.flow_log = []
-+        self.last_vehicle_times = {}
-+        
-         return super().reset_sumo()  # Reset the simulation
- 
-     @property
-@@ -101,8 +111,37 @@ class RingEnv(Env):
-         }
-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
-         stats['beta'] = c.beta                    # Add the beta parameter
-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
-         return stats
+-class BNeckEnv(Env):
+-    def def_sumo(self):
+-        c = self.c
+-        nodes = E('nodes',
+-            E('node', id='n_0', x=0, y=0), *(
+-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
+-        ))
+-        edges = E('edges', *(
+-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
+-                'numLanes': n_lane,
+-                'speed': c.max_speed
+-            }) for i, n_lane in enumerate(c.n_lanes)
+-        ))
+-        connections = E('connections', *(
+-            E('connection', **{
+-                'from': prev.id,
+-                'to': curr.id,
+-                'fromLane': i,
+-                'toLane': int(i / prev.numLanes * curr.numLanes)
+-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
+-        ))
 -
-+    
-+    def calculate_flow(self):
-+        """
-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
-+        """
-+        current_time = self.ts.time
-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
-+
-+        for vehicle in vehicles_on_edge:
-+            # Check if vehicle has passed the observation point since the last timestep
-+            if vehicle.id not in self.last_vehicle_times:
-+                # If the vehicle was not previously recorded, count it as a new passage
-+                self.flow_counter += 1
-+            else:
-+                # If recorded, ensure sufficient time has passed to consider it as a new count
-+                last_time = self.last_vehicle_times[vehicle.id]
-+                if current_time - last_time > self.c.sim_step:
-+                    self.flow_counter += 1
-+
-+            # Update the last time the vehicle passed the point
-+            self.last_vehicle_times[vehicle.id] = current_time
-+
-+        # Calculate flow as vehicles per hour equivalent based on timestep
-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
-+        self.flow_log.append(flow_per_hour)
-+        return flow_per_hour
-+    
-     def step(self, action=None):
-         c = self.c  # Configuration object
-         ts = self.ts  # Time step object
-@@ -181,6 +220,10 @@ class RingEnv(Env):
-                     # Change to a specific lane
-                     ts.lane_change_to(rl, lc)
+-        if c.split_flow:
+-            n_inflow_lanes = c.n_lanes[0]
+-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
+-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
+-                for i in range(n_inflow_lanes)
+-            ]
+-        else:
+-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
+-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
+-            ]
+-        routes = E('routes',
+-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
+-            *flows
+-        )
+-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
+-        additional = E('additional',
+-            E('vType', id='generic', **idm_params),
+-            E('vType', id='rl', **idm_params),
+-            E('vType', id='human', **idm_params),
+-        )
+-        sumo_args = {'collision.action': COLLISION.remove}
+-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+-
+-    def reset_sumo(self):
+-        c = self.c
+-        if c.flow_rate_range:
+-            c.flow_rate = np.random.randint(*c.flow_rate_range)
+-        ret = super().reset_sumo()
+-        if c.vinitsky:
+-            self.obs_lanes = [(lane, i_start * c.piece_length)
+-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
+-                for i_start in range(round(edge.length) // c.piece_length)
+-                for lane in edge.lanes
+-            ]
+-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
+-            self.last_outflows = []
+-        return ret
+-
+-    def step(self, action=[]):
+-        c = self.c
+-        ts = self.ts
+-        max_dist = 100
+-        max_speed = c.max_speed
+-        human_type = ts.types.human
+-        rl_type = ts.types.rl
+-
+-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+-        if c.vinitsky:
+-            if len(action):
+-                assert len(action) == len(self.control_lanes)
+-                for (lane, piece_start), act in zip(self.control_lanes, action):
+-                    self.control_lanes[lane, piece_start] = np.clip(
+-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
+-                        0.1, max_speed
+-                    )
+-                for veh in prev_rls:
+-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
+-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
+-        else:
+-            for veh, act in zip(prev_rls, action):
+-                if c.handcraft:
+-                    route, edge, lane = veh.route, veh.edge, veh.lane
+-                    next_lane = lane.next(veh.route)
+-                    level = 1
+-                    if next_lane and next_lane.get('junction'):
+-                        merge_dist = lane.length - veh.laneposition
+-                        if merge_dist < c.handcraft:
+-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
+-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
+-                                level = 0
+-                    if c.act_type.startswith('accel'):
+-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+-                    else:
+-                        ts.set_max_speed(veh, max_speed * level)
+-                    continue
+-                if not isinstance(act, (int, np.integer)):
+-                    act = (act - c.low) / (1 - c.low)
+-                if c.act_type.startswith('accel'):
+-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+-                else:
+-                    if c.act_type == 'continuous':
+-                        level = act[0]
+-                    elif c.act_type == 'discretize':
+-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+-                    elif c.act_type == 'discrete':
+-                        level = act / (c.n_actions - 1)
+-                    ts.set_max_speed(veh, max_speed * level)
+-
+-                if c.lc_av == 'binary' and act[1] > 0.5:
+-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
+-
+-        super().step()
+-
+-        if c.vinitsky:
+-            n_last_outflows = 20
+-            max_vehs = 4
+-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
+-            obs = []
+-            for lane, piece_start in self.obs_lanes:
+-                piece_end = piece_start + c.piece_length
+-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
+-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
+-                lane_humans = [v for v in lane_vehs if v.type is human_type]
+-                obs.extend([
+-                    len(lane_humans) / max_vehs,
+-                    len(lane_avs) / max_vehs,
+-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
+-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
+-                ])
+-            if len(self.last_outflows) == n_last_outflows:
+-                self.last_outflows = self.last_outflows[1:]
+-            self.last_outflows.append(len(ts.new_arrived))
+-            reward = np.mean(self.last_outflows)
+-            obs.append(reward / max_veh_outflows)
+-            obs = np.array(obs, dtype=np.float32)
+-            assert 0 <= obs.min() and obs.max() <= 1
+-            return obs, reward, False, None
+-        route = nexti(ts.routes)
+-        obs, ids = [], []
+-        default_close = [0, max_speed]
+-        default_far = [max_dist, 0]
+-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+-            speed, edge, lane = veh.speed, veh.edge, veh.lane
+-            merge_dist = max_dist
+-            default_human = default_far
+-
+-            other_info = {}
+-            next_lane = lane.next(veh.route)
+-            if next_lane and next_lane.get('junction'):
+-                merge_dist = lane.length - veh.laneposition
+-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+-                pos = other_lane.length if c.veh_junction else veh.laneposition
+-                # Look for veh on other lane but do not extend past that lane
+-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
+-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
+-                    if other_veh.type is rl_type:
+-                        default_human = default_close
+-                        break
+-
+-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
+-            ids.append(veh.id)
+-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
+-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+-        
+-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+-
+-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+-        ttc = np.clip(ttc/7, -1, 1)
+-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+-        drac = np.clip(drac/10, -1, 1)
+-
+-        raw_pet = self.calc_pet()
+-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+-        pet = np.clip(pet, -1, 1)
+-
+-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+-        
+-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+-        return returned
+-        
+-        # return Namespace(obs=obs, id=ids, reward=reward)
+-    
+-    def calc_ttc(self):
+-        cur_veh_list = self.ts.vehicles
+-        ttcs = []
+-        for v in cur_veh_list:
+-            leader, headway = v.leader()
+-            v_speed = v.speed
+-            leader_speed = leader.speed
+-            if leader_speed < v_speed:
+-                ttc =  headway/(v_speed-leader_speed)
+-            else:
+-                ttc = np.nan
+-            ttcs.append(ttc)
+-        fleet_ttc = np.nanmean(np.array(ttcs))
+-        return fleet_ttc
+-    
+-    def calc_drac(self):
+-        cur_veh_list = self.ts.vehicles
+-        dracs = []
+-        for v in cur_veh_list:
+-            leader, headway = v.leader()
+-            v_speed = v.speed
+-            leader_speed = leader.speed
+-            drac = 0.5*np.square(v_speed-leader_speed)/headway
+-            dracs.append(drac)
+-        fleet_drac = np.nanmean(np.array(dracs))
+-        return fleet_drac
+-
+-    def calc_pet(self):
+-        cur_veh_list = self.ts.vehicles
+-        pets = []
+-        for v in cur_veh_list:
+-            leader, headway = v.leader()
+-            v_speed = v.speed
+-            if v_speed > 1e-16:
+-                pet = headway/(v_speed)
+-                pets.append(pet)
+-        fleet_pet = np.nanmean(np.array(pets))
+-        return fleet_pet
+-
+-class BNeck(Main):
+-    def create_env(c):
+-        return BNeckEnv(c)
+-
+-    @property
+-    def observation_space(c):
+-        low = np.full(c._n_obs, c.low)
+-        return Box(low, np.ones_like(low))
+-
+-    @property
+-    def action_space(c):
+-        if c.vinitsky:
+-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
+-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+-        if c.act_type in ['discretize', 'continuous', 'accel']:
+-            assert c.lc_av in [False, 'binary']
+-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
+-        elif c.act_type in ['discrete', 'accel_discrete']:
+-            return Discrete(c.n_actions)
+-
+-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+-        if c.vinitsky:
+-            return super().on_rollout_end(rollout, stats, ii=n_ii)
+-        log = c.get_log_ii(ii, n_ii)
+-        step_obs_ = rollout.obs
+-        step_obs = step_obs_[:-1]
+-
+-        ret, _ = calc_adv(rollout.reward, c.gamma)
+-
+-        n_veh = np.array([len(o) for o in step_obs])
+-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+-        rollout.update(obs=step_obs, ret=step_ret)
+-
+-        step_id_ = rollout.pop('id')
+-        id = np.concatenate(step_id_[:-1])
+-        id_unique = np.unique(id)
+-
+-        reward = np.array(rollout.pop('reward'))
+-
+-        log(**stats)
+-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+-        log(
+-            n_veh_step_mean=n_veh.mean(), 
+-            n_veh_step_sum=n_veh.sum(), 
+-            n_veh_unique=len(id_unique),
+-            
+-            reward_mean=np.mean(reward),
+-            reward_std=np.std(reward),        
+-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+-            ssm_mean=np.mean(rollout.ssm),
+-            ssm_std=np.std(rollout.ssm),
+-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+-
+-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+-            # nom_action = np.mean(rollout.nom_action),
+-            # res_action = np.mean(rollout.res_action),
+-            )
+-        return rollout
+-
+-if __name__ == '__main__':
+-    c = BNeck.from_args(globals(), locals()).setdefaults(
+-        warmup_steps=1000,
+-        horizon=2000,
+-        n_steps=100,
+-        step_save=5,
+-
+-        av_frac=0.2,
+-        sim_step=0.5,
+-        depart_speed=0,
+-        edge_lengths=[100, 100, 50],
+-        n_lanes=[4, 2, 1],
+-        max_speed=30,
+-
+-        lc_av=False,
+-        flow_rate=2300,
+-        flow_rate_range=None,
+-        split_flow=True,
+-        generic_type='rand',
+-        speed_mode=SPEED_MODE.all_checks,
+-        lc_mode=LC_MODE.off,
+-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+-
+-        veh_junction=False,
+-        act_type='accel_discrete',
+-        max_accel=2.6,
+-        max_decel=4.5,
+-        tau=1.0,
+-        min_gap=2.5,
+-        delta=4,
+-        n_actions=3,
+-        low=-1,
+-        handcraft=False,
+-        vinitsky=False,
+-
+-        render=False,
+-
+-        alg=PG,
+-        lr=1e-3,
+-
+-        gamma=0.99,
+-        adv_norm=False,
+-        batch_concat=True,
+-
+-        beta=0,
+-        scale_ttc=1,
+-        scale_drac=1,
+-        seed_np=False,
+-        seed_torch = False,
+-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+-        mrtl=False, # this flag deals with adding beta to observation vector
+-
+-    )
+-    
+-    if c.seed_torch:
+-        # Set seed for PyTorch CPU operations
+-        torch.manual_seed(c.seed_torch)
+-        # Set seed for PyTorch CUDA operations (if available)
+-        if torch.cuda.is_available():
+-            torch.cuda.manual_seed_all(c.seed_torch)
+-    if c.seed_np:
+-        np.random.seed(c.seed_np)
+-        
+-    if c.vinitsky:
+-        c.piece_length = 20
+-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
+-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
+-        c._n_action = sum(n_actions[:-1])
+-        c._n_obs = sum(n_actions) * 4 + 1
+-        c.batch_concat = False
+-    else:
+-        c._n_obs = 2 + 2 + 2
+-        
+-    if c.mrtl:
+-        c._n_obs += 1 # modified for mrtl related
+-        
+-    c.redef_sumo = bool(c.flow_rate_range)
+-    c.run()
+\ No newline at end of file
+diff --git a/highway_ramp.py b/highway_ramp.py
+deleted file mode 100644
+index ef0358f..0000000
+--- a/highway_ramp.py
++++ /dev/null
+@@ -1,325 +0,0 @@
+-from automatic_vehicular_control.exp import *
+-from automatic_vehicular_control.env import *
+-from automatic_vehicular_control.u import *
+-
+-class RampEnv(Env):
+-    # https://flow-project.github.io/papers/08569485.pdf
+-    def def_sumo(self):
+-        c = self.c
+-        builder = NetBuilder()
+-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
+-            (0, 0),
+-            (c.premerge_distance, 0),
+-            (c.premerge_distance + c.merge_distance, 0),
+-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
+-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
+-        ])
+-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
+-            {}, {'numLanes': 2}, {}
+-        ], lane_maps=[
+-            {0: 1}, {0: 0, 1: 0}
+-        ], route_id='highway')
+-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
+-            {}, {'numLanes': 2}, {}
+-        ], lane_maps=[
+-            {0: 0}, {0: 0, 1: 0}
+-        ], route_id='ramp')
+-        nodes, edges, connections, routes = builder.build()
+-        nodes[2].type = 'zipper'
+-
+-        routes = E('routes',
+-            *routes,
+-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
+-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
+-        )
+-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
+-        additional = E('additional',
+-            E('vType', id='generic', **idm),
+-            E('vType', id='rl', **idm),
+-            E('vType', id='human', **idm),
+-        )
+-        sumo_args = {'collision.action': COLLISION.remove}
+-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+-
+-    def step(self, action=[]):
+-        c = self.c
+-        ts = self.ts
+-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
+-        max_speed = c.max_speed
+-        human_type = ts.types.human
+-        rl_type = ts.types.rl
+-
+-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+-        for rl, act in zip(prev_rls, action):
+-            if c.handcraft:
+-                route, edge, lane = rl.route, rl.edge, rl.lane
+-                leader, dist = rl.leader()
+-                level = 1
+-                if edge.id == 'e_n_0.0_n_400.0':
+-                    if rl.laneposition < 100:
+-                        leaders = list(rl.leaders())
+-                        if len(leaders) > 20:
+-                            level = 0
+-                        else:
+-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+-                continue
+-            if not isinstance(act, (int, np.integer)):
+-                act = (act - c.low) / (1 - c.low)
+-            if c.act_type.startswith('accel'):
+-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+-            else:
+-                if c.act_type == 'continuous':
+-                    level = act[0]
+-                elif c.act_type == 'discretize':
+-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+-                elif c.act_type == 'discrete':
+-                    level = act / (c.n_actions - 1)
+-                ts.set_max_speed(rl, max_speed * level)
+-
+-        super().step()
+-
+-        route = ts.routes.highway
+-        obs, ids = [], []
+-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+-            if hasattr(veh, 'edge'):
+-                speed, edge, lane = veh.speed, veh.edge, veh.lane
+-                merge_dist = max_dist
+-
+-                lead_speed = follow_speed = other_speed = 0
+-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
+-
+-                leader, dist = veh.leader()
+-                if leader: lead_speed, lead_dist = leader.speed, dist
+-
+-                follower, dist = veh.follower()
+-                if follower: follow_speed, follow_dist = follower.speed, dist
+-
+-                if c.global_obs:
+-                    jun_edge = edge.next(route)
+-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
+-                        jun_edge = jun_edge.next(route)
+-                    if jun_edge:
+-                        merge_dist = lane.length - veh.laneposition
+-                        next_edge = edge.next(route)
+-                        while next_edge is not jun_edge:
+-                            merge_dist += next_edge.length
+-                            next_edge = next_edge.next(route)
+-
+-                        other_lane = jun_edge.lanes[0]
+-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
+-                            other_speed = other_veh.speed
+-                            break
+-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
+-                else:
+-                    next_lane = lane.next(route)
+-                    if next_lane and next_lane.get('junction'):
+-                        if len(edge.lanes) == 2:
+-                            other_lane = edge.lanes[0]
+-                            pos = veh.laneposition
+-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
+-                                other_speed = other_veh.speed
+-                                break
+-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
+-                ids.append(veh.id)
+-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
+-        if c.mrtl:
+-            obs = np.concatenate([obs, np.array([c.beta])])
+-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+-        
+-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+-
+-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+-        ttc = np.clip(ttc/7, -1, 1)
+-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+-        drac = np.clip(drac/10, -1, 1)
+-
+-        raw_pet = self.calc_pet()
+-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+-        pet = np.clip(pet, -1, 1)
+-
+-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+-        
+-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+-        return returned
+-        
+-        # return Namespace(obs=obs, id=ids, reward=reward)
+-    
+-    def calc_ttc(self):
+-        cur_veh_list = self.ts.vehicles
+-        ttcs = []
+-        for v in cur_veh_list:
+-            if hasattr(v, 'edge'):
+-                leader, headway = v.leader()
+-                if leader:
+-                    v_speed = v.speed
+-                    leader_speed = leader.speed
+-                    if leader_speed < v_speed:
+-                        ttc =  headway/(v_speed-leader_speed)
+-                    else:
+-                        ttc = np.nan
+-                    ttcs.append(ttc)
+-        fleet_ttc = np.nanmean(np.array(ttcs))
+-        return fleet_ttc
+-    
+-    def calc_drac(self):
+-        cur_veh_list = self.ts.vehicles
+-        dracs = []
+-        for v in cur_veh_list:
+-            if hasattr(v, 'edge'):
+-                leader, headway = v.leader()
+-                if leader:
+-                    v_speed = v.speed
+-                    leader_speed = leader.speed
+-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
+-                    dracs.append(drac)
+-        fleet_drac = np.nanmean(np.array(dracs))
+-        return fleet_drac
+-
+-    def calc_pet(self):
+-        cur_veh_list = self.ts.vehicles
+-        pets = []
+-        for v in cur_veh_list:
+-            if hasattr(v, 'edge'):
+-                leader, headway = v.leader()
+-                if leader:
+-                    v_speed = v.speed
+-                    if v_speed > 1e-16:
+-                        pet = headway/(v_speed)
+-                        pets.append(pet)
+-        fleet_pet = np.nanmean(np.array(pets))
+-        # return fleet_pet if not np.isnan(fleet_pet) else 1
+-        return fleet_pet
+-
+-class Ramp(Main):
+-    def create_env(c):
+-        return RampEnv(c)
+-
+-    @property
+-    def observation_space(c):
+-        low = np.full(c._n_obs, c.low)
+-        return Box(low, np.ones_like(low))
+-
+-    @property
+-    def action_space(c):
+-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+-        if c.act_type in ['discretize', 'continuous', 'accel']:
+-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+-        elif c.act_type in ['discrete', 'accel_discrete']:
+-            return Discrete(c.n_actions)
+-
+-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+-        log = c.get_log_ii(ii, n_ii)
+-        step_obs_ = rollout.obs
+-        step_obs = step_obs_[:-1]
+-
+-        ret, _ = calc_adv(rollout.reward, c.gamma)
+-
+-        n_veh = np.array([len(o) for o in step_obs])
+-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+-        rollout.update(obs=step_obs, ret=step_ret)
+-
+-        step_id_ = rollout.pop('id')
+-        id = np.concatenate(step_id_[:-1])
+-        id_unique = np.unique(id)
+-
+-        reward = np.array(rollout.pop('reward'))
+-
+-        log(**stats)
+-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+-        log(
+-            n_veh_step_mean=n_veh.mean(), 
+-            n_veh_step_sum=n_veh.sum(), 
+-            n_veh_unique=len(id_unique),
+-            
+-            reward_mean=np.mean(reward),
+-            reward_std=np.std(reward),        
+-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+-            ssm_mean=np.mean(rollout.ssm),
+-            ssm_std=np.std(rollout.ssm),
+-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+-
+-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+-            # nom_action = np.mean(rollout.nom_action),
+-            # res_action = np.mean(rollout.res_action),
+-            )
+-        return rollout
+-
+-if __name__ == '__main__':
+-    c = Ramp.from_args(globals(), locals()).setdefaults(
+-        warmup_steps=100,
+-        horizon=2000,
+-        n_steps=100,
+-        step_save=5,
+-
+-        premerge_distance=400,
+-        merge_distance=100,
+-        postmerge_distance=30,
+-        av_frac=0.1,
+-        sim_step=0.5,
+-        max_speed=30,
+-        highway_depart_speed=10,
+-        ramp_depart_speed=0,
+-        highway_flow_rate=2000,
+-        ramp_flow_rate=300,
+-        global_obs=False,
+-        handcraft=False,
+-
+-        generic_type='default',
+-        speed_mode=SPEED_MODE.all_checks,
+-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+-
+-        act_type='accel_discrete',
+-        max_accel=1,
+-        max_decel=1.5,
+-        n_actions=3,
+-        low=-1,
+-
+-        render=False,
+-
+-        alg=PG,
+-        lr=1e-3,
+-
+-        gamma=0.99,
+-        adv_norm=False,
+-        batch_concat=True,
+-
+-        beta=0,
+-        scale_ttc=1,
+-        scale_drac=1,
+-        seed_np=False,
+-        seed_torch = False,
+-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+-        mrtl=False, # this flag deals with adding beta to observation vector
+-
+-    )
+-    
+-    if c.seed_torch:
+-        # Set seed for PyTorch CPU operations
+-        torch.manual_seed(c.seed_torch)
+-        # Set seed for PyTorch CUDA operations (if available)
+-        if torch.cuda.is_available():
+-            torch.cuda.manual_seed_all(c.seed_torch)
+-    if c.seed_np:
+-        np.random.seed(c.seed_np)
+-        
+-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
+-    if c.mrtl:
+-        c._n_obs += 1 # modified for mrtl related
+-    c.run()
+\ No newline at end of file
+diff --git a/intersection.py b/intersection.py
+deleted file mode 100644
+index e38a84f..0000000
+--- a/intersection.py
++++ /dev/null
+@@ -1,489 +0,0 @@
+-from automatic_vehicular_control.u import *
+-from automatic_vehicular_control.exp import *
+-from automatic_vehicular_control.env import *
+-
+-class Platoon(Entity):
+-    pass
+-
+-class IntersectionEnv(Env):
+-    def def_sumo(self):
+-        c = self.c
+-
+-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
+-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
+-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
+-        ] if params.get('vehsPerHour')]
+-
+-        builder = NetBuilder()
+-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
+-        if c.enter_length:
+-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+-            xys[1:, :, 0] += c.enter_length - c.length
+-            xys[:, 1:, 1] += c.enter_length - c.length
+-            xys = xys.reshape(-1, 2)
+-        if c.short_exit:
+-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+-            xys[-1, :, 0] += c.short_exit - c.length
+-            xys[:, -1, 1] += c.short_exit - c.length
+-            xys = xys.reshape(-1, 2)
+-        nodes = builder.add_nodes(
+-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
+-        ).reshape(c.n_rows + 2, c.n_cols + 2)
+-        # import pdb; pdb.set_trace()
+-
+-        tl = c.setdefault('tl', False)
+-        if tl:
+-            c.av_frac = 0
+-            c.pop('av_range', None)
+-            c.speed_mode = SPEED_MODE.all_checks
+-
+-        flows = []
+-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
+-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
+-        for direction in c.directions:
+-            chains = nodes if direction in ['left', 'right'] else nodes.T
+-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
+-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
+-
+-            edge_attrs = dict(priority=int(direction in priority))
+-            if c.get('set_edge_speed', True):
+-                edge_attrs['speed'] = c.max_speed
+-
+-            for i, chain in enumerate(chains[1:-1]):
+-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
+-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
+-                flows.extend(default_flows(flow_id, route_id, flow_rate))
+-
+-        tls = []
+-        if tl:
+-            tl = 1000000 if tl == 'MaxPressure' else tl
+-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
+-            tl_offset = c.get('tl_offset', 'auto')
+-            yellow = c.get('yellow', 0.5)
+-            if tl_offset == 'auto':
+-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
+-            elif tl_offset == 'same':
+-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
+-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
+-                node.type = 'traffic_light'
+-                phase_multiple = len(c.directions) // 2
+-                tls.append(E('tlLogic',
+-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
+-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
+-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
+-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
+-                id=node.id, offset=offset, type='static', programID='1'))
+-
+-        nodes, edges, connections, routes = builder.build()
+-        additional = E('additional', *types, *routes, *flows, *tls)
+-        return super().def_sumo(nodes, edges, connections, additional)
+-
+-    def build_platoon(self):
+-        ts = self.ts
+-        rl_type = ts.types.rl
+-        for route in ts.routes:
+-            vehs = []
+-            route_offset = 0
+-            for edge in route.edges:
+-                for veh in edge.vehicles:
+-                    veh.route_position = route_offset + veh.laneposition
+-                    vehs.append(veh)
+-                route_offset += edge.length
+-
+-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
+-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
+-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
+-            rl_idxs, = rl_mask.nonzero()
+-            split_idxs = 1 + rl_idxs
+-
+-            prev = None
+-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
+-                if not len(vehs_i):
+-                    continue # Last vehicle is RL, so the last split is empty
+-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
+-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
+-                )
+-                if prev is not None:
+-                    prev.next = platoon
+-                prev = platoon
+-                for veh in vehs_i:
+-                    veh.platoon = platoon
+-            if prev is not None:
+-                prev.next = None
+-
+-    def reset(self):
+-        c = self.c
+-        if c.e is False:
+-            if 'length_range' in c:
+-                min_, max_ = c.length_range
+-                c.setdefaults(max_length=max_)
+-                c.length = np.random.randint(min_, max_ + 1)
+-            if 'av_range' in c:
+-                min_, max_ = c.av_range
+-                c.av_frac = np.random.uniform(min_, max_)
+-        self.mp_tlast = 0
+-        while not self.reset_sumo():
+-            pass
+-        ret = super().init_env()
+-        return ret
+-
+-    def step(self, action=[]):
+-        c = self.c
+-        ts = self.ts
+-        max_dist = c.max_dist
+-        depart_speed = c.depart_speed
+-        max_speed = c.max_speed
+-
+-        rl_type = ts.types.rl
+-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+-
+-        for rl, act in zip(prev_rls, action):
+-            if c.handcraft or c.handcraft_tl:
+-                route, lane = rl.route, rl.lane
+-                junction = lane.next_junction
+-                level = 1
+-                if junction is not ts.sentinel_junction:
+-                    dist = junction.route_position[route] - rl.route_position
+-                    if c.handcraft:
+-                        for cross_lane in lane.next_cross_lanes:
+-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
+-                    elif c.handcraft_tl and dist < 15:
+-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
+-                        yellow_time = 0
+-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
+-                        horizontal_go = 0 <= rem < t_h
+-                        vertical_go = t_h + yellow_time <= rem
+-                        horizontal_lane = 'left' in route.id or 'right' in route.id
+-                        human_remain = False
+-                        for cross_lane in lane.next_cross_lanes:
+-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+-                            human_remain = cross_veh and cross_veh.type is not rl_type
+-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
+-            elif c.act_type == 'accel':
+-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
+-            else:
+-                level = act / (c.n_actions - 1)
+-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+-
+-        if c.tl == 'MaxPressure':
+-            self.mp_tlast += c.sim_step
+-            tmin = c.get('mp_tmin', 0)
+-            if self.mp_tlast >= tmin:
+-                for tl in ts.traffic_lights:
+-                    if ts.get_program(tl) == 'off':
+-                        break
+-                    jun = tl.junction
+-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
+-
+-                    total_pressures = []
+-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
+-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
+-
+-                    ts.set_phase(tl, np.argmax(total_pressures))
+-                self.mp_tlast = 0
+-
+-        super().step()
+-        self.build_platoon()
+-
+-        obs = {}
+-
+-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
+-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
+-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
+-        for veh in rl_type.vehicles:
+-            if hasattr(veh, 'lane'):
+-                route, lane, platoon = veh.route, veh.lane, veh.platoon
+-                junction = lane.next_junction
+-
+-                head, tail = veh, platoon.tail
+-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
+-
+-                if junction is ts.sentinel_junction:
+-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
+-                else:
+-                    for jun_lane in lane.next_junction_lanes:
+-                        # Defaults for jun_lane
+-                        jun_headtails = vehs_default()
+-
+-                        jun_lane_route = nexti(jun_lane.from_routes)
+-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
+-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
+-
+-                        if jun_veh:
+-                            if jun_veh.type is rl_type:
+-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
+-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
+-                                platoon = jun_veh.platoon.prev
+-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+-                                    if platoon is None: break
+-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
+-                                    platoon = platoon.prev
+-                            else:
+-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
+-                                jun_headtails[0] = jun_veh.platoon.tail
+-                                next_cross_platoon = jun_veh.platoon.prev
+-                                if next_cross_platoon:
+-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
+-                                    platoon = next_cross_platoon.prev
+-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+-                                        if platoon is None: break
+-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
+-                                        platoon = platoon.prev
+-                        route_vehs.append((jun_lane_route, jun_headtails))
+-
+-                dist_features, speed_features = [], []
+-                for route, vehs in route_vehs:
+-                    j_pos = junction.route_position[route]
+-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
+-                    speed_features.extend([v.speed / max_speed for v in vehs])
+-
+-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
+-
+-        sort_id = lambda d: [v for k, v in sorted(d.items())]
+-        ids = sorted(obs)
+-        if c.mrtl:
+-            obs = np.concatenate([obs, np.array([c.beta])])
+-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
+-        if c.rew_type == 'outflow':
+-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+-        elif c.rew_type == 'time_penalty':
+-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
+-        
+-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+-
+-        raw_drac = self.calc_drac()
+-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+-        drac = np.clip(drac/10, -1, 1)
+-        raw_pet = self.calc_pet()
+-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+-        pet = np.clip(pet/6, -1, 1)
+-
+-        raw_ttc = self.calc_ttc()
+-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+-        ttc = np.clip(ttc/7, -1, 1)
+-
+-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
+-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+-
+-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+-        return returned
+-        # return Namespace(obs=obs, id=ids, reward=reward)
+-        
+-    def calc_drac(self):
+-        cur_veh_list = self.ts.vehicles
+-        dracs = []
+-        for v in cur_veh_list:
+-            if hasattr(v, 'lane'):
+-                leader, headway = v.leader()
+-                v_speed = v.speed
+-                leader_speed = leader.speed
+-                drac = 0.5*np.square(v_speed-leader_speed)/headway
+-                dracs.append(drac)
+-        fleet_drac = np.nanmean(np.array(dracs))
+-        return fleet_drac
+-    
+-    def calc_pet(self):
+-        cur_veh_list = self.ts.vehicles
+-        pets = []
+-        for v in cur_veh_list:
+-            if hasattr(v, 'lane'):
+-                leader, headway = v.leader()
+-                v_speed = v.speed
+-                if v_speed > 1e-16:
+-                    pet = headway/(v_speed)
+-                    pets.append(pet)
+-        fleet_pet = np.nanmean(np.array(pets))
+-        return fleet_pet
+-
+-    def calc_ttc(self):
+-        cur_veh_list = self.ts.vehicles
+-        ttcs = []
+-        for v in cur_veh_list:
+-            if hasattr(v, 'lane'):
+-                leader, headway = v.leader()
+-                v_speed = v.speed
+-                leader_speed = leader.speed
+-                if leader_speed < v_speed:
+-                    ttc =  headway/(v_speed-leader_speed)
+-                else:
+-                    ttc = np.nan
+-                ttcs.append(ttc)
+-        fleet_ttc = np.nanmean(np.array(ttcs))
+-        return fleet_ttc
+-
+-    def append_step_info(self):
+-        super().append_step_info()
+-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
+-
+-    @property
+-    def stats(self):
+-        c = self.c
+-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
+-        mean = lambda L: np.mean(L) if len(L) else np.nan
+-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
+-        stats['backlog_step'] = mean(info['backlog'])
+-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
+-
+-        stats['beta'] = c.beta
+-
+-        if c.multi_flowrate:
+-            stats['flow_horizontal'] = c.flow_rate_h
+-            stats['flow_vertical'] = c.flow_rate_v
+-        return stats
+-
+-class Intersection(Main):
+-    def create_env(c):
+-        if c.multi_flowrate:
+-            return NormEnv(c, IntersectionEnv(c))
+-        else:
+-            c._norm = NormEnv(c, None)
+-            return IntersectionEnv(c)
+-
+-    @property
+-    def observation_space(c):
+-        low = np.full(c._n_obs, c.low)
+-        return Box(low, np.ones_like(low))
+-
+-    @property
+-    def action_space(c):
+-        if c.act_type == 'accel':
+-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+-        else:
+-            return Discrete(c.n_actions)
+-
+-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+-        log = c.get_log_ii(ii, n_ii)
+-        step_obs_ = rollout.obs
+-        step_obs = step_obs_[:-1]
+-
+-        if not c.multi_flowrate:
+-            rollout.raw_reward = rollout.reward
+-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
+-
+-        ret, _ = calc_adv(rollout.reward, c.gamma)
+-
+-        n_veh = np.array([len(o) for o in step_obs])
+-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+-        rollout.update(obs=step_obs, ret=step_ret)
+-
+-        step_id_ = rollout.pop('id')
+-        id = np.concatenate(step_id_[:-1])
+-        id_unique = np.unique(id)
+-
+-        reward = np.array(rollout.pop('reward'))
+-        raw_reward = np.array(rollout.pop('raw_reward'))
+-
+-        log(**stats)
+-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
+-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+-        log(
+-            n_veh_step_mean=n_veh.mean(), 
+-            n_veh_step_sum=n_veh.sum(), 
+-            n_veh_unique=len(id_unique),
+-            
+-            reward_mean=np.mean(reward),
+-            reward_std=np.std(reward),        
+-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+-            ssm_mean=np.mean(rollout.ssm),
+-            ssm_std=np.std(rollout.ssm),
+-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+-
+-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+-            # nom_action = np.mean(rollout.nom_action),
+-            # res_action = np.mean(rollout.res_action),
+-            )
+-        
+-        return rollout
+-
+-if __name__ == '__main__':
+-    c = Intersection.from_args(globals(), locals())
+-    c.setdefaults(
+-        n_steps=200,
+-        step_save=5,
+-
+-        depart_speed=0,
+-        max_speed=13,
+-        max_dist=100,
+-        max_accel=1.5,
+-        max_decel=3.5,
+-        sim_step=0.5,
+-        generic_type=True,
+-        n_actions=3,
+-
+-        adv_norm=False,
+-        batch_concat=True,
+-
+-        render=False,
+-
+-        warmup_steps=100,
+-        horizon=2000,
+-        directions='4way',
+-        av_frac=0.15,
+-        handcraft=False,
+-        handcraft_tl=None,
+-        flow_rate=700,
+-        length=100,
+-        n_rows=1,
+-        n_cols=1,
+-        speed_mode=SPEED_MODE.obey_safe_speed,
+-
+-        act_type='accel_discrete',
+-        low=-1,
+-
+-        alg=PG,
+-        n_gds=1,
+-        lr=1e-3,
+-        gamma=0.99,
+-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+-
+-        enter_length=False,
+-        short_exit=False,
+-
+-        rew_type='outflow',
+-        norm_reward=True,
+-        center_reward=True,
+-        multi_flowrate=False,
+-        opt='RMSprop',
+-
+-        obs_tail=True,
+-        obs_next_cross_platoons=1,
+-
+-        beta=0,
+-        scale_pet=1,
+-        scale_drac=1,
+-        seed_np=False,
+-        seed_torch = False,
+-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+-        mrtl=False, # this flag deals with adding beta to observation vector
+-    )
+-
+-    if c.seed_torch:
+-        # Set seed for PyTorch CPU operations
+-        torch.manual_seed(c.seed_torch)
+-        # Set seed for PyTorch CUDA operations (if available)
+-        if torch.cuda.is_available():
+-            torch.cuda.manual_seed_all(c.seed_torch)
+-    if c.seed_np:
+-        np.random.seed(c.seed_np)
+-
+-    if c.directions == '4way':
+-        c.directions = ['up', 'right', 'down', 'left']
+-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
+-    if c.mrtl:
+-        c._n_obs += 1
+-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
+-    c.redef_sumo = 'length_range' in c
+-    c.run()
+\ No newline at end of file
+diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+index d4c3dac..c72a87d 100644
+--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+@@ -1,600 +1,24538 @@
+-diff --git a/README.md b/README.md
+-index b591747..127f484 100644
+---- a/README.md
+-+++ b/README.md
+-@@ -39,7 +39,7 @@ conda env create -f environment.yml
+- ### 1.2 Set the environmental variables
+- ```
+- # Code directory
+--export F=automatic_vehicular_control/automatic_vehicular_control
+-+export F=automatic_vehicular_control
+- 
+- # Results directory extracted from the zip file
+- export R=results
+-@@ -48,10 +48,8 @@ export R=results
+- ## 2. Directory Structure
+- 
+- The code directory structure is
+--```
+-+``` 
+- automatic_vehicular_control/
+--│
+--├── automatic_vehicular_control/
+- │   ├── __pycache__/                # Compiled Python files
+- │   ├── evaluations/                # Evaluation results and metrics
+- │   ├── models/                     # Model checkpoints
+ diff --git a/env.py b/env.py
+-index 4ab3d95..c83a674 100644
++index c83a674..0bcfb8e 100644
+ --- a/env.py
+ +++ b/env.py
+-@@ -724,9 +724,11 @@ class TrafficState:
+-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
+- 
+-         segments = {}
+-+        
+-         def add_from_to(from_, to):
+-             from_.tos.add(to)
+-             to.froms.add(from_)
+-+            
+-         for con in map(values_str_to_val, net.children('connection')):
+-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
+-             to_lane = edges[con.to].lanes[int(con.toLane)]
+-@@ -888,89 +890,109 @@ class TrafficState:
+- 
+-     def step(self):
+-         """
+--        Take a simulation step and update state
+-+        Take a simulation step and update state.
+-         """
+--        c = self.c
+--        tc = self.tc
+--        subscribes = self.subscribes
+-+        c = self.c  # Configuration object for the simulation
+-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
+-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
+- 
+-         # Actual SUMO step
+--        tc.simulationStep()
+--        sim_res = subscribes.sim.get()
+-+        tc.simulationStep()  # Advances the SUMO simulation by one step
+-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
+- 
+-+        # Clear references to current vehicle edges and lanes for the next update
+-         for veh in self.vehicles:
+--            veh.unvar('edge', 'lane')
+-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
+-+
+-+        # Clear current vehicle data from edges and lanes
+-         for ent in itertools.chain(self.edges, self.lanes):
+--            ent.vehicles.clear()
+--            ent.positions.clear()
+-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
+-+            ent.positions.clear()  # Clear vehicle positions
+- 
+-+        # Update traffic light states
+-         for tl_id, tl in self.traffic_lights.items():
+--            tl.update(subscribes.tl.get(tl_id))
+-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
+- 
+-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
+-         for veh_id in sim_res.loaded_vehicles_ids:
+--            flow_id, _ = veh_id.rsplit('.')
+--            flow = self.flows[flow_id]
+--            flow.backlog.add(veh_id)
+-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
+-+            flow = self.flows[flow_id]  # Get the corresponding flow object
+-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
+- 
+-+        # Initialize a set for newly departed vehicles
+-         self.new_departed = set()
+-+
+-+        # Handle vehicles that have departed (entered the network)
+-         for veh_id in sim_res.departed_vehicles_ids:
+--            subscribes.veh.subscribe(veh_id)
+--            type_id = tc.vehicle.getTypeID(veh_id)
+--            # import pdb; pdb.set_trace()
+-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
+-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
+-+            # If vehicle type is 'generic', compute specific type
+-             if type_id == 'generic':
+-                 type_id = self.compute_type(veh_id)
+--            type_ = self.types[type_id]
+--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
+--            length = tc.vehicle.getLength(veh_id)
+--            road_id = tc.vehicle.getRoadID(veh_id)
+--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
+--            type_.vehicles.add(veh)
+-+            type_ = self.types[type_id]  # Get vehicle type object
+-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
+-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
+-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
+-+
+-+            # Create a new vehicle object and add it to the list of vehicles
+-+            self.vehicles[veh_id] = veh = Vehicle(
+-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
+-+            )
+-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
+- 
+-+            # Set color if rendering is enabled
+-             if c.render:
+-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
+--                self.set_color(veh, color_fn(veh))
+-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
+- 
+-+            # Set vehicle speed mode and lane change mode using SUMO settings
+-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
+-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
+-+
+-+            # Add to new_departed set
+-             self.new_departed.add(veh)
+-+
+-+            # Remove vehicle from backlog if necessary
+-             if '.' in veh_id:
+-                 flow_id, _ = veh_id.rsplit('.')
+-                 if flow_id in self.flows:
+-                     flow = self.flows[flow_id]
+-                     flow.backlog.remove(veh_id)
+- 
+-+        # Handle newly arrived and collided vehicles
+-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
+-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+-+        
+-+        # Remove newly arrived vehicles from tracking if they collided
+-         for veh in self.new_arrived:
+--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
+--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
+-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
+-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
+- 
+-+        # Update vehicle positions on edges and lanes
+-         for veh_id, veh in self.vehicles.items():
+--            veh.prev_speed = veh.get('speed', None)
+--            veh.update(subscribes.veh.get(veh_id))
+-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
+-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
+-             if veh_id not in sim_res.colliding_vehicles_ids:
+--                edge = self.edges[veh.road_id]
+--                edge.vehicles.append(veh)
+--                veh.edge = edge
+--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
+--            # edge = self.edges[veh.road_id]
+--            # edge.vehicles.append(veh)
+--            # veh.edge = edge
+-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
+-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
+-+                veh.edge = edge  # Set vehicle's edge attribute
+- 
+-+        # Update vehicle sorting and lane positions
+-         for edge in self.edges:
+--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
+--            edge.positions = [veh.laneposition for veh in edge.vehicles]
+-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
+-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
+-             for edge_i, veh in enumerate(edge.vehicles):
+--                veh.edge_i = edge_i
+--                veh.lane = lane = edge.lanes[veh.lane_index]
+--                veh.lane_i = len(lane.vehicles)
+--                lane.vehicles.append(veh)
+--                lane.positions.append(veh.laneposition)
+-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
+-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
+-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
+-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
+-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
+- 
+-+        # Record sets of vehicles that have arrived, departed, or collided during this step
+-         self.all_arrived.append(self.new_arrived)
+-         self.all_departed.append(self.new_departed)
+-         self.all_collided.append(self.new_collided)
+--
+-+            
+-     def reset(self, tc):
+-         self.tc = tc
+-         self.subscribes.clear()
+-@@ -1043,6 +1065,7 @@ class Env:
+-     """
+-     Offers a similar reinforcement learning environment interface as gym.Env
+-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
+-+    c: Ring class
+-     """
+-     def __init__(self, c):
+-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
+-@@ -1056,6 +1079,7 @@ class Env:
+-             if c.get('save_agent'):
+-                 self._agent_info = []
+-         self._step = 0
+-+        self.mean_speed = 0
+- 
+-     def def_sumo(self, *args, **kwargs):
+-         """ Override this with code defining the SUMO network """
+-@@ -1094,49 +1118,91 @@ class Env:
+-         """
+-         return True
+- 
+-+   # Method to reset or initialize the SUMO traffic simulation environment
+-     def reset_sumo(self):
+-+        # Shortcuts for configuration and SUMO definition objects
+-         c = self.c
+-         sumo_def = self.sumo_def
+--
+--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
++@@ -852,12 +852,15 @@ class TrafficState:
++         subscribes.sim = SubscribeDef(tc.simulation, [
++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
+ +        
+-+        # Determine if new SUMO definitions need to be generated
+-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
++         subscribes.tl = SubscribeDef(tc.trafficlight, [
++             TL.red_yellow_green_state])
+ +        
+-         if generate_def:
+--            kwargs = self.def_sumo()
+--            kwargs['net'] = sumo_def.generate_net(**kwargs)
+--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
+-+            # Generate new definitions if necessary
+-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
+-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
+-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++         subscribes.veh = SubscribeDef(tc.vehicle, [
++             V.road_id, V.lane_index, V.laneposition,
++             V.speed, V.position, V.angle,
++             V.fuelconsumption, V.noxemission])
+ +        
+-+        # Start SUMO with the current traffic controller (tc)
+-         self.tc = sumo_def.start_sumo(self.tc)
+-+        
+-         if generate_def:
+-+            # If new definitions were generated, store relevant SUMO file paths
+-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
+-+            
+-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
+-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
+--            self.ts = TrafficState(c, self.tc, **defs)
+-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
+-         else:
+-+            # If not generating new definitions, simply reset the existing traffic state
+-             self.ts.reset(self.tc)
+-+        
+-+        # Set up the traffic state (e.g., initialize the simulation settings)
+-         self.ts.setup()
+-+        
+-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+-         success = self.init_vehicles()
+-+        
+-+        # Return whether the SUMO reset and vehicle initialization were successful
+-         return success
++         for tl_id in self.traffic_lights.keys():
++             subscribes.tl.subscribe(tl_id)
+  
+-+    # Method to initialize the environment after SUMO reset
+-     def init_env(self):
+-+        # Reference to the traffic state
+-         ts = self.ts
++@@ -1109,6 +1112,26 @@ class Env:
++         if self._vehicle_info is not None:
++             self.extend_vehicle_info()
++         self._step += 1
+++        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++        return c.observation_space.low, 0, False, None
+ +    
+-+        # Create an empty data structure to store rollout information
+-         self.rollout_info = NamedArrays()
+-+        
+-+        # Turn off all traffic lights in the network
+-         for tl in ts.traffic_lights:
+--            ts.set_program(tl, 'off')
+-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
+-+        
+-+        # Reset the step counter to 0
+-         self._step = 0
+-+        
+-+        # Take the first step in the simulation
+-         ret = self.step()
+-+        
+-+        # Run the simulation for a number of warmup steps
+-         for _ in range(self.c.warmup_steps):
+--            ret = self.step()
+-+            ret = self.step()  # Advance the simulation one step
+-+            
+-+            # If the simulation ends during the warmup phase, return None to indicate failure
+-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
+-                 return None
+-+        
+-+        # After warmup, turn traffic lights back on (set to a defined program '1')
+-         for tl in ts.traffic_lights:
+--            ts.set_program(tl, '1')
+-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
+-+        
+-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
+-         if isinstance(ret, tuple):
+--            return ret[0]
+--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
+--
+-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
+-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
+-+        
+-+    # Reset the entire environment, retrying until successful
+-     def reset(self):
+--        while True:
+-+        self.mean_speed = 0
+-+        while True:  # Infinite loop until the environment is successfully reset
+-+            # Attempt to reset the SUMO simulation
+-             if not self.reset_sumo():
+--                continue
+-+                continue  # If reset_sumo fails, retry the loop
+-+            
+-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
+-             if (obs := self.init_env()) is not None:
+--                return obs
+-+                return obs  # Successfully initialized, return the observation
+-+
+++    
+++    def step_2(self, *args):
+++        """
+++        Override this with additional code which applies acceleration and measures observation and reward
+++        """
+++        c, ts = self.c, self.ts
+++        if c.get('custom_idm'):
+++            idm = c.custom_idm
+++            for veh in ts.types.human.vehicles:
+++                leader, headway = veh.leader()
+++                v = veh.speed
+++                s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
+++                a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
+++                noise = np.random.normal(0, idm.sigma)
+++                ts.accel(veh, a + noise)
+++        self._step += 1
+++        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++         return c.observation_space.low, 0, False, None
+  
+-     def append_step_info(self):
+-         """
+-@@ -1231,6 +1297,8 @@ class Env:
+- class NormEnv(gym.Env):
+-     """
+-     Reward normalization with running average https://github.com/joschu/modular_rl
+-+    self.c: Ring parameters 
+-+    self.env: RingEnv class
+-     """
+-     def __init__(self, c, env):
+-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
++     def init_vehicles(self):
++@@ -1197,6 +1220,7 @@ class Env:
++         while True:  # Infinite loop until the environment is successfully reset
++             # Attempt to reset the SUMO simulation
++             if not self.reset_sumo():
+++                
++                 continue  # If reset_sumo fails, retry the loop
++             
++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
+ diff --git a/exp.py b/exp.py
+-index ead4652..7f7cee5 100644
++index 7f7cee5..cb160a1 100644
+ --- a/exp.py
+ +++ b/exp.py
+-@@ -169,9 +169,9 @@ class Main(Config):
+- 
+-     def on_train_start(c):
+-         # Initialize training: environment, algorithm, model, optimizer, and logging
+--        c.setdefaults(alg='Algorithm')
+--        c._env = c.create_env()
+--
+-+        c.setdefaults(alg='Algorithm') 
+-+        c._env = c.create_env() # Create NormEnv
+-+ 
+-         # Instantiate the algorithm (e.g., PPO, DQN)
+-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
+-         c.set_model()
+-@@ -222,8 +222,8 @@ class Main(Config):
+- 
+-     def on_step_start(c, stats={}):
+-         # Update the learning rate and log stats at the start of a training step
+--        lr = c._lr
+--        for g in c._opt.param_groups:
+-+        lr = c._lr # Update Learning Rate
+-+        for g in c._opt.param_groups: # Log Statistics
+-             g['lr'] = float(lr)
+-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
+- 
+-@@ -285,10 +285,14 @@ class Main(Config):
++@@ -285,11 +285,10 @@ class Main(Config):
+              ret = dict(obs=ret)
+          rollout = NamedArrays()
+          rollout.append(**ret)
+--
+-+        rollout_flow_each_step = []
++-        rollout_flow_each_step = []
+          done = False
+          a_space = c.action_space
+          step = 0
+-+        density = 20/(250*1e-3)
+-+        vehicle_flow = c._env.mean_speed * 3.6 * density 
+-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+-+
+-         while step < c.horizon + c.skip_stat_steps and not done:
+-             # Generate an action from the model's policy
+-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
+-@@ -309,6 +313,12 @@ class Main(Config):
+-             rollout.append(**ret)
+-             step += 1
++-        density = 20/(250*1e-3)
+++        density = c.var().n_veh/(c.var().circumference*1e-3)
++         vehicle_flow = c._env.mean_speed * 3.6 * density 
++         print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++ 
++@@ -315,8 +314,7 @@ class Main(Config):
+          # Collect stats from the environment
+-+        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+-+        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+-+        density = 20/(250 * 1e-3)
+-+        vehicle_flow = c._env.mean_speed * density 
+-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+-+
++         # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++         # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++-        density = 20/(250 * 1e-3)
++-        vehicle_flow = c._env.mean_speed * density 
+++        vehicle_flow = c._env.mean_speed * density  * 3.6
++         print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++ 
+          stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
+-         return rollout, stats
++@@ -406,9 +404,8 @@ class Main(Config):
+  
+-@@ -398,10 +408,10 @@ class Main(Config):
++     def train(c):
+          # Main training loop
+-         c.on_train_start()
++-        c.on_train_start()
+++        c.on_train_start() # Ring Env
+          while c._i < c.n_steps:
+--            c.on_step_start()
+-+            c.on_step_start() # save stat 
++-            c.on_step_start() # save stat 
+              with torch.no_grad():
+                  # Collect rollouts without computing gradients
+--                rollouts = c.rollouts()
+-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+-             gd_stats = {}
+-             if len(rollouts.obs):
+-                 t_start = time()
+-@@ -410,7 +420,7 @@ class Main(Config):
+-                 gd_stats.update(gd_time=time() - t_start)
+-             c.on_step_end(gd_stats)
+-             c._i += 1
+--        c.on_step_start()  # last step
+-+        c.on_step_start()  # save stat
+-         gd_stats = {}
+-         with torch.no_grad():
+-             rollouts = c.rollouts()
+-@@ -450,6 +460,8 @@ class Main(Config):
+-         if hasattr(c._env, 'close'):
+-             c._env.close()
+- 
+-+  
++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++@@ -497,3 +494,31 @@ class Main(Config):
++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
++             c.train()
++         c.log('job done!')
+ +
+-     def run(c):
+-         # Determine whether to train or evaluate based on configuration
+-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+-diff --git a/ring.py b/ring.py
+-index 94d632d..ee1372b 100644
+---- a/ring.py
+-+++ b/ring.py
+-@@ -15,7 +15,6 @@ class RingEnv(Env):
+-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+-         )
+++    def run_2(c):
+++        # Determine whether to train or evaluate based on configuration
+++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
+++        c.on_train_start()
+++        c._env = c.create_env() # Create NormEnv
+++        ret = c._env.reset()
+++        c.set_model()
+++        step = 0
+++        density = 20/(250*1e-3)
+++        vehicle_flow = c._env.mean_speed * 3.6 * density 
+++        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+++        done = False
+++        while step < c.horizon + c.skip_stat_steps and not done:
+++            # Take a step in the environment
+++            ret = c._env.step_2()
+++            if isinstance(ret, tuple):
+++                obs, reward, done, info = ret
+++                ret = dict(obs=obs, reward=reward, done=done, info=info)
+++            done = ret.setdefault('done', False)
+++            step += 1
+++        # Collect stats from the environment
+++        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+++        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+++        density = 20/(250 * 1e-3)
+++        vehicle_flow = c._env.mean_speed * density 
+++        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
++deleted file mode 100644
++index 6b9ba52..0000000
++--- a/highway_bottleneck.py
+++++ /dev/null
++@@ -1,381 +0,0 @@
++-from automatic_vehicular_control.exp import *
++-from automatic_vehicular_control.env import *
++-from automatic_vehicular_control.u import *
+ -
+-         # Function to generate the shape of the edges (circular arcs)
+-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+- 
+-@@ -88,6 +87,17 @@ class RingEnv(Env):
+-         if c.circumference_range:  # Check if the circumference should be randomized
+-             # Randomly set the circumference within the specified range
+-             c.circumference = np.random.randint(*c.circumference_range)
+-+        
+-+        if self.flow_log:
+-+            average_flow = sum(self.flow_log) / len(self.flow_log)
+-+            self.episode_flow.append(average_flow)
+-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
+-+        
+-+        # Reset flow counters for the new episode
+-+        self.flow_counter = 0
+-+        self.flow_log = []
+-+        self.last_vehicle_times = {}
+-+        
+-         return super().reset_sumo()  # Reset the simulation
+- 
+-     @property
+-@@ -101,8 +111,37 @@ class RingEnv(Env):
+-         }
+-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+-         stats['beta'] = c.beta                    # Add the beta parameter
+-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
+-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
+-         return stats
++-class BNeckEnv(Env):
++-    def def_sumo(self):
++-        c = self.c
++-        nodes = E('nodes',
++-            E('node', id='n_0', x=0, y=0), *(
++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
++-        ))
++-        edges = E('edges', *(
++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
++-                'numLanes': n_lane,
++-                'speed': c.max_speed
++-            }) for i, n_lane in enumerate(c.n_lanes)
++-        ))
++-        connections = E('connections', *(
++-            E('connection', **{
++-                'from': prev.id,
++-                'to': curr.id,
++-                'fromLane': i,
++-                'toLane': int(i / prev.numLanes * curr.numLanes)
++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
++-        ))
+ -
+-+    
+-+    def calculate_flow(self):
+-+        """
+-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+-+        """
+-+        current_time = self.ts.time
+-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+-+
+-+        for vehicle in vehicles_on_edge:
+-+            # Check if vehicle has passed the observation point since the last timestep
+-+            if vehicle.id not in self.last_vehicle_times:
+-+                # If the vehicle was not previously recorded, count it as a new passage
+-+                self.flow_counter += 1
+-+            else:
+-+                # If recorded, ensure sufficient time has passed to consider it as a new count
+-+                last_time = self.last_vehicle_times[vehicle.id]
+-+                if current_time - last_time > self.c.sim_step:
+-+                    self.flow_counter += 1
+-+
+-+            # Update the last time the vehicle passed the point
+-+            self.last_vehicle_times[vehicle.id] = current_time
+-+
+-+        # Calculate flow as vehicles per hour equivalent based on timestep
+-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
+-+        self.flow_log.append(flow_per_hour)
+-+        return flow_per_hour
+-+    
+-     def step(self, action=None):
+-         c = self.c  # Configuration object
+-         ts = self.ts  # Time step object
+-@@ -181,6 +220,10 @@ class RingEnv(Env):
+-                     # Change to a specific lane
+-                     ts.lane_change_to(rl, lc)
++-        if c.split_flow:
++-            n_inflow_lanes = c.n_lanes[0]
++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
++-                for i in range(n_inflow_lanes)
++-            ]
++-        else:
++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
++-            ]
++-        routes = E('routes',
++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
++-            *flows
++-        )
++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
++-        additional = E('additional',
++-            E('vType', id='generic', **idm_params),
++-            E('vType', id='rl', **idm_params),
++-            E('vType', id='human', **idm_params),
++-        )
++-        sumo_args = {'collision.action': COLLISION.remove}
++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++-
++-    def reset_sumo(self):
++-        c = self.c
++-        if c.flow_rate_range:
++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
++-        ret = super().reset_sumo()
++-        if c.vinitsky:
++-            self.obs_lanes = [(lane, i_start * c.piece_length)
++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
++-                for i_start in range(round(edge.length) // c.piece_length)
++-                for lane in edge.lanes
++-            ]
++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
++-            self.last_outflows = []
++-        return ret
++-
++-    def step(self, action=[]):
++-        c = self.c
++-        ts = self.ts
++-        max_dist = 100
++-        max_speed = c.max_speed
++-        human_type = ts.types.human
++-        rl_type = ts.types.rl
++-
++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++-        if c.vinitsky:
++-            if len(action):
++-                assert len(action) == len(self.control_lanes)
++-                for (lane, piece_start), act in zip(self.control_lanes, action):
++-                    self.control_lanes[lane, piece_start] = np.clip(
++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
++-                        0.1, max_speed
++-                    )
++-                for veh in prev_rls:
++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
++-        else:
++-            for veh, act in zip(prev_rls, action):
++-                if c.handcraft:
++-                    route, edge, lane = veh.route, veh.edge, veh.lane
++-                    next_lane = lane.next(veh.route)
++-                    level = 1
++-                    if next_lane and next_lane.get('junction'):
++-                        merge_dist = lane.length - veh.laneposition
++-                        if merge_dist < c.handcraft:
++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
++-                                level = 0
++-                    if c.act_type.startswith('accel'):
++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++-                    else:
++-                        ts.set_max_speed(veh, max_speed * level)
++-                    continue
++-                if not isinstance(act, (int, np.integer)):
++-                    act = (act - c.low) / (1 - c.low)
++-                if c.act_type.startswith('accel'):
++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++-                else:
++-                    if c.act_type == 'continuous':
++-                        level = act[0]
++-                    elif c.act_type == 'discretize':
++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++-                    elif c.act_type == 'discrete':
++-                        level = act / (c.n_actions - 1)
++-                    ts.set_max_speed(veh, max_speed * level)
++-
++-                if c.lc_av == 'binary' and act[1] > 0.5:
++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
++-
++-        super().step()
++-
++-        if c.vinitsky:
++-            n_last_outflows = 20
++-            max_vehs = 4
++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
++-            obs = []
++-            for lane, piece_start in self.obs_lanes:
++-                piece_end = piece_start + c.piece_length
++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
++-                obs.extend([
++-                    len(lane_humans) / max_vehs,
++-                    len(lane_avs) / max_vehs,
++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
++-                ])
++-            if len(self.last_outflows) == n_last_outflows:
++-                self.last_outflows = self.last_outflows[1:]
++-            self.last_outflows.append(len(ts.new_arrived))
++-            reward = np.mean(self.last_outflows)
++-            obs.append(reward / max_veh_outflows)
++-            obs = np.array(obs, dtype=np.float32)
++-            assert 0 <= obs.min() and obs.max() <= 1
++-            return obs, reward, False, None
++-        route = nexti(ts.routes)
++-        obs, ids = [], []
++-        default_close = [0, max_speed]
++-        default_far = [max_dist, 0]
++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
++-            merge_dist = max_dist
++-            default_human = default_far
++-
++-            other_info = {}
++-            next_lane = lane.next(veh.route)
++-            if next_lane and next_lane.get('junction'):
++-                merge_dist = lane.length - veh.laneposition
++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++-                pos = other_lane.length if c.veh_junction else veh.laneposition
++-                # Look for veh on other lane but do not extend past that lane
++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
++-                    if other_veh.type is rl_type:
++-                        default_human = default_close
++-                        break
++-
++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
++-            ids.append(veh.id)
++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++-        
++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++-
++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++-        ttc = np.clip(ttc/7, -1, 1)
++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++-        drac = np.clip(drac/10, -1, 1)
++-
++-        raw_pet = self.calc_pet()
++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++-        pet = np.clip(pet, -1, 1)
++-
++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++-        
++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++-        return returned
++-        
++-        # return Namespace(obs=obs, id=ids, reward=reward)
++-    
++-    def calc_ttc(self):
++-        cur_veh_list = self.ts.vehicles
++-        ttcs = []
++-        for v in cur_veh_list:
++-            leader, headway = v.leader()
++-            v_speed = v.speed
++-            leader_speed = leader.speed
++-            if leader_speed < v_speed:
++-                ttc =  headway/(v_speed-leader_speed)
++-            else:
++-                ttc = np.nan
++-            ttcs.append(ttc)
++-        fleet_ttc = np.nanmean(np.array(ttcs))
++-        return fleet_ttc
++-    
++-    def calc_drac(self):
++-        cur_veh_list = self.ts.vehicles
++-        dracs = []
++-        for v in cur_veh_list:
++-            leader, headway = v.leader()
++-            v_speed = v.speed
++-            leader_speed = leader.speed
++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
++-            dracs.append(drac)
++-        fleet_drac = np.nanmean(np.array(dracs))
++-        return fleet_drac
++-
++-    def calc_pet(self):
++-        cur_veh_list = self.ts.vehicles
++-        pets = []
++-        for v in cur_veh_list:
++-            leader, headway = v.leader()
++-            v_speed = v.speed
++-            if v_speed > 1e-16:
++-                pet = headway/(v_speed)
++-                pets.append(pet)
++-        fleet_pet = np.nanmean(np.array(pets))
++-        return fleet_pet
++-
++-class BNeck(Main):
++-    def create_env(c):
++-        return BNeckEnv(c)
++-
++-    @property
++-    def observation_space(c):
++-        low = np.full(c._n_obs, c.low)
++-        return Box(low, np.ones_like(low))
++-
++-    @property
++-    def action_space(c):
++-        if c.vinitsky:
++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++-            assert c.lc_av in [False, 'binary']
++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
++-        elif c.act_type in ['discrete', 'accel_discrete']:
++-            return Discrete(c.n_actions)
++-
++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++-        if c.vinitsky:
++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
++-        log = c.get_log_ii(ii, n_ii)
++-        step_obs_ = rollout.obs
++-        step_obs = step_obs_[:-1]
++-
++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++-
++-        n_veh = np.array([len(o) for o in step_obs])
++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++-        rollout.update(obs=step_obs, ret=step_ret)
++-
++-        step_id_ = rollout.pop('id')
++-        id = np.concatenate(step_id_[:-1])
++-        id_unique = np.unique(id)
++-
++-        reward = np.array(rollout.pop('reward'))
++-
++-        log(**stats)
++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++-        log(
++-            n_veh_step_mean=n_veh.mean(), 
++-            n_veh_step_sum=n_veh.sum(), 
++-            n_veh_unique=len(id_unique),
++-            
++-            reward_mean=np.mean(reward),
++-            reward_std=np.std(reward),        
++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++-            ssm_mean=np.mean(rollout.ssm),
++-            ssm_std=np.std(rollout.ssm),
++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++-
++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++-            # nom_action = np.mean(rollout.nom_action),
++-            # res_action = np.mean(rollout.res_action),
++-            )
++-        return rollout
++-
++-if __name__ == '__main__':
++-    c = BNeck.from_args(globals(), locals()).setdefaults(
++-        warmup_steps=1000,
++-        horizon=2000,
++-        n_steps=100,
++-        step_save=5,
++-
++-        av_frac=0.2,
++-        sim_step=0.5,
++-        depart_speed=0,
++-        edge_lengths=[100, 100, 50],
++-        n_lanes=[4, 2, 1],
++-        max_speed=30,
++-
++-        lc_av=False,
++-        flow_rate=2300,
++-        flow_rate_range=None,
++-        split_flow=True,
++-        generic_type='rand',
++-        speed_mode=SPEED_MODE.all_checks,
++-        lc_mode=LC_MODE.off,
++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++-
++-        veh_junction=False,
++-        act_type='accel_discrete',
++-        max_accel=2.6,
++-        max_decel=4.5,
++-        tau=1.0,
++-        min_gap=2.5,
++-        delta=4,
++-        n_actions=3,
++-        low=-1,
++-        handcraft=False,
++-        vinitsky=False,
++-
++-        render=False,
++-
++-        alg=PG,
++-        lr=1e-3,
++-
++-        gamma=0.99,
++-        adv_norm=False,
++-        batch_concat=True,
++-
++-        beta=0,
++-        scale_ttc=1,
++-        scale_drac=1,
++-        seed_np=False,
++-        seed_torch = False,
++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++-        mrtl=False, # this flag deals with adding beta to observation vector
++-
++-    )
++-    
++-    if c.seed_torch:
++-        # Set seed for PyTorch CPU operations
++-        torch.manual_seed(c.seed_torch)
++-        # Set seed for PyTorch CUDA operations (if available)
++-        if torch.cuda.is_available():
++-            torch.cuda.manual_seed_all(c.seed_torch)
++-    if c.seed_np:
++-        np.random.seed(c.seed_np)
++-        
++-    if c.vinitsky:
++-        c.piece_length = 20
++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
++-        c._n_action = sum(n_actions[:-1])
++-        c._n_obs = sum(n_actions) * 4 + 1
++-        c.batch_concat = False
++-    else:
++-        c._n_obs = 2 + 2 + 2
++-        
++-    if c.mrtl:
++-        c._n_obs += 1 # modified for mrtl related
++-        
++-    c.redef_sumo = bool(c.flow_rate_range)
++-    c.run()
++\ No newline at end of file
++diff --git a/highway_ramp.py b/highway_ramp.py
++deleted file mode 100644
++index ef0358f..0000000
++--- a/highway_ramp.py
+++++ /dev/null
++@@ -1,325 +0,0 @@
++-from automatic_vehicular_control.exp import *
++-from automatic_vehicular_control.env import *
++-from automatic_vehicular_control.u import *
++-
++-class RampEnv(Env):
++-    # https://flow-project.github.io/papers/08569485.pdf
++-    def def_sumo(self):
++-        c = self.c
++-        builder = NetBuilder()
++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
++-            (0, 0),
++-            (c.premerge_distance, 0),
++-            (c.premerge_distance + c.merge_distance, 0),
++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
++-        ])
++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
++-            {}, {'numLanes': 2}, {}
++-        ], lane_maps=[
++-            {0: 1}, {0: 0, 1: 0}
++-        ], route_id='highway')
++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
++-            {}, {'numLanes': 2}, {}
++-        ], lane_maps=[
++-            {0: 0}, {0: 0, 1: 0}
++-        ], route_id='ramp')
++-        nodes, edges, connections, routes = builder.build()
++-        nodes[2].type = 'zipper'
++-
++-        routes = E('routes',
++-            *routes,
++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
++-        )
++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
++-        additional = E('additional',
++-            E('vType', id='generic', **idm),
++-            E('vType', id='rl', **idm),
++-            E('vType', id='human', **idm),
++-        )
++-        sumo_args = {'collision.action': COLLISION.remove}
++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++-
++-    def step(self, action=[]):
++-        c = self.c
++-        ts = self.ts
++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
++-        max_speed = c.max_speed
++-        human_type = ts.types.human
++-        rl_type = ts.types.rl
++-
++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++-        for rl, act in zip(prev_rls, action):
++-            if c.handcraft:
++-                route, edge, lane = rl.route, rl.edge, rl.lane
++-                leader, dist = rl.leader()
++-                level = 1
++-                if edge.id == 'e_n_0.0_n_400.0':
++-                    if rl.laneposition < 100:
++-                        leaders = list(rl.leaders())
++-                        if len(leaders) > 20:
++-                            level = 0
++-                        else:
++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++-                continue
++-            if not isinstance(act, (int, np.integer)):
++-                act = (act - c.low) / (1 - c.low)
++-            if c.act_type.startswith('accel'):
++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++-            else:
++-                if c.act_type == 'continuous':
++-                    level = act[0]
++-                elif c.act_type == 'discretize':
++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++-                elif c.act_type == 'discrete':
++-                    level = act / (c.n_actions - 1)
++-                ts.set_max_speed(rl, max_speed * level)
++-
++-        super().step()
++-
++-        route = ts.routes.highway
++-        obs, ids = [], []
++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++-            if hasattr(veh, 'edge'):
++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
++-                merge_dist = max_dist
++-
++-                lead_speed = follow_speed = other_speed = 0
++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
++-
++-                leader, dist = veh.leader()
++-                if leader: lead_speed, lead_dist = leader.speed, dist
++-
++-                follower, dist = veh.follower()
++-                if follower: follow_speed, follow_dist = follower.speed, dist
++-
++-                if c.global_obs:
++-                    jun_edge = edge.next(route)
++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
++-                        jun_edge = jun_edge.next(route)
++-                    if jun_edge:
++-                        merge_dist = lane.length - veh.laneposition
++-                        next_edge = edge.next(route)
++-                        while next_edge is not jun_edge:
++-                            merge_dist += next_edge.length
++-                            next_edge = next_edge.next(route)
++-
++-                        other_lane = jun_edge.lanes[0]
++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
++-                            other_speed = other_veh.speed
++-                            break
++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
++-                else:
++-                    next_lane = lane.next(route)
++-                    if next_lane and next_lane.get('junction'):
++-                        if len(edge.lanes) == 2:
++-                            other_lane = edge.lanes[0]
++-                            pos = veh.laneposition
++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
++-                                other_speed = other_veh.speed
++-                                break
++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
++-                ids.append(veh.id)
++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
++-        if c.mrtl:
++-            obs = np.concatenate([obs, np.array([c.beta])])
++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++-        
++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++-
++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++-        ttc = np.clip(ttc/7, -1, 1)
++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++-        drac = np.clip(drac/10, -1, 1)
++-
++-        raw_pet = self.calc_pet()
++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++-        pet = np.clip(pet, -1, 1)
++-
++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++-        
++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++-        return returned
++-        
++-        # return Namespace(obs=obs, id=ids, reward=reward)
++-    
++-    def calc_ttc(self):
++-        cur_veh_list = self.ts.vehicles
++-        ttcs = []
++-        for v in cur_veh_list:
++-            if hasattr(v, 'edge'):
++-                leader, headway = v.leader()
++-                if leader:
++-                    v_speed = v.speed
++-                    leader_speed = leader.speed
++-                    if leader_speed < v_speed:
++-                        ttc =  headway/(v_speed-leader_speed)
++-                    else:
++-                        ttc = np.nan
++-                    ttcs.append(ttc)
++-        fleet_ttc = np.nanmean(np.array(ttcs))
++-        return fleet_ttc
++-    
++-    def calc_drac(self):
++-        cur_veh_list = self.ts.vehicles
++-        dracs = []
++-        for v in cur_veh_list:
++-            if hasattr(v, 'edge'):
++-                leader, headway = v.leader()
++-                if leader:
++-                    v_speed = v.speed
++-                    leader_speed = leader.speed
++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
++-                    dracs.append(drac)
++-        fleet_drac = np.nanmean(np.array(dracs))
++-        return fleet_drac
++-
++-    def calc_pet(self):
++-        cur_veh_list = self.ts.vehicles
++-        pets = []
++-        for v in cur_veh_list:
++-            if hasattr(v, 'edge'):
++-                leader, headway = v.leader()
++-                if leader:
++-                    v_speed = v.speed
++-                    if v_speed > 1e-16:
++-                        pet = headway/(v_speed)
++-                        pets.append(pet)
++-        fleet_pet = np.nanmean(np.array(pets))
++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
++-        return fleet_pet
++-
++-class Ramp(Main):
++-    def create_env(c):
++-        return RampEnv(c)
++-
++-    @property
++-    def observation_space(c):
++-        low = np.full(c._n_obs, c.low)
++-        return Box(low, np.ones_like(low))
++-
++-    @property
++-    def action_space(c):
++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++-        elif c.act_type in ['discrete', 'accel_discrete']:
++-            return Discrete(c.n_actions)
++-
++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++-        log = c.get_log_ii(ii, n_ii)
++-        step_obs_ = rollout.obs
++-        step_obs = step_obs_[:-1]
++-
++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++-
++-        n_veh = np.array([len(o) for o in step_obs])
++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++-        rollout.update(obs=step_obs, ret=step_ret)
++-
++-        step_id_ = rollout.pop('id')
++-        id = np.concatenate(step_id_[:-1])
++-        id_unique = np.unique(id)
++-
++-        reward = np.array(rollout.pop('reward'))
++-
++-        log(**stats)
++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++-        log(
++-            n_veh_step_mean=n_veh.mean(), 
++-            n_veh_step_sum=n_veh.sum(), 
++-            n_veh_unique=len(id_unique),
++-            
++-            reward_mean=np.mean(reward),
++-            reward_std=np.std(reward),        
++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++-            ssm_mean=np.mean(rollout.ssm),
++-            ssm_std=np.std(rollout.ssm),
++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++-
++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++-            # nom_action = np.mean(rollout.nom_action),
++-            # res_action = np.mean(rollout.res_action),
++-            )
++-        return rollout
++-
++-if __name__ == '__main__':
++-    c = Ramp.from_args(globals(), locals()).setdefaults(
++-        warmup_steps=100,
++-        horizon=2000,
++-        n_steps=100,
++-        step_save=5,
++-
++-        premerge_distance=400,
++-        merge_distance=100,
++-        postmerge_distance=30,
++-        av_frac=0.1,
++-        sim_step=0.5,
++-        max_speed=30,
++-        highway_depart_speed=10,
++-        ramp_depart_speed=0,
++-        highway_flow_rate=2000,
++-        ramp_flow_rate=300,
++-        global_obs=False,
++-        handcraft=False,
++-
++-        generic_type='default',
++-        speed_mode=SPEED_MODE.all_checks,
++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++-
++-        act_type='accel_discrete',
++-        max_accel=1,
++-        max_decel=1.5,
++-        n_actions=3,
++-        low=-1,
++-
++-        render=False,
++-
++-        alg=PG,
++-        lr=1e-3,
++-
++-        gamma=0.99,
++-        adv_norm=False,
++-        batch_concat=True,
++-
++-        beta=0,
++-        scale_ttc=1,
++-        scale_drac=1,
++-        seed_np=False,
++-        seed_torch = False,
++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++-        mrtl=False, # this flag deals with adding beta to observation vector
++-
++-    )
++-    
++-    if c.seed_torch:
++-        # Set seed for PyTorch CPU operations
++-        torch.manual_seed(c.seed_torch)
++-        # Set seed for PyTorch CUDA operations (if available)
++-        if torch.cuda.is_available():
++-            torch.cuda.manual_seed_all(c.seed_torch)
++-    if c.seed_np:
++-        np.random.seed(c.seed_np)
++-        
++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
++-    if c.mrtl:
++-        c._n_obs += 1 # modified for mrtl related
++-    c.run()
++\ No newline at end of file
++diff --git a/intersection.py b/intersection.py
++deleted file mode 100644
++index e38a84f..0000000
++--- a/intersection.py
+++++ /dev/null
++@@ -1,489 +0,0 @@
++-from automatic_vehicular_control.u import *
++-from automatic_vehicular_control.exp import *
++-from automatic_vehicular_control.env import *
++-
++-class Platoon(Entity):
++-    pass
++-
++-class IntersectionEnv(Env):
++-    def def_sumo(self):
++-        c = self.c
++-
++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
++-        ] if params.get('vehsPerHour')]
++-
++-        builder = NetBuilder()
++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
++-        if c.enter_length:
++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++-            xys[1:, :, 0] += c.enter_length - c.length
++-            xys[:, 1:, 1] += c.enter_length - c.length
++-            xys = xys.reshape(-1, 2)
++-        if c.short_exit:
++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++-            xys[-1, :, 0] += c.short_exit - c.length
++-            xys[:, -1, 1] += c.short_exit - c.length
++-            xys = xys.reshape(-1, 2)
++-        nodes = builder.add_nodes(
++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
++-        # import pdb; pdb.set_trace()
++-
++-        tl = c.setdefault('tl', False)
++-        if tl:
++-            c.av_frac = 0
++-            c.pop('av_range', None)
++-            c.speed_mode = SPEED_MODE.all_checks
++-
++-        flows = []
++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
++-        for direction in c.directions:
++-            chains = nodes if direction in ['left', 'right'] else nodes.T
++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
++-
++-            edge_attrs = dict(priority=int(direction in priority))
++-            if c.get('set_edge_speed', True):
++-                edge_attrs['speed'] = c.max_speed
++-
++-            for i, chain in enumerate(chains[1:-1]):
++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
++-
++-        tls = []
++-        if tl:
++-            tl = 1000000 if tl == 'MaxPressure' else tl
++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
++-            tl_offset = c.get('tl_offset', 'auto')
++-            yellow = c.get('yellow', 0.5)
++-            if tl_offset == 'auto':
++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
++-            elif tl_offset == 'same':
++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
++-                node.type = 'traffic_light'
++-                phase_multiple = len(c.directions) // 2
++-                tls.append(E('tlLogic',
++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
++-                id=node.id, offset=offset, type='static', programID='1'))
++-
++-        nodes, edges, connections, routes = builder.build()
++-        additional = E('additional', *types, *routes, *flows, *tls)
++-        return super().def_sumo(nodes, edges, connections, additional)
++-
++-    def build_platoon(self):
++-        ts = self.ts
++-        rl_type = ts.types.rl
++-        for route in ts.routes:
++-            vehs = []
++-            route_offset = 0
++-            for edge in route.edges:
++-                for veh in edge.vehicles:
++-                    veh.route_position = route_offset + veh.laneposition
++-                    vehs.append(veh)
++-                route_offset += edge.length
++-
++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
++-            rl_idxs, = rl_mask.nonzero()
++-            split_idxs = 1 + rl_idxs
++-
++-            prev = None
++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
++-                if not len(vehs_i):
++-                    continue # Last vehicle is RL, so the last split is empty
++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
++-                )
++-                if prev is not None:
++-                    prev.next = platoon
++-                prev = platoon
++-                for veh in vehs_i:
++-                    veh.platoon = platoon
++-            if prev is not None:
++-                prev.next = None
++-
++-    def reset(self):
++-        c = self.c
++-        if c.e is False:
++-            if 'length_range' in c:
++-                min_, max_ = c.length_range
++-                c.setdefaults(max_length=max_)
++-                c.length = np.random.randint(min_, max_ + 1)
++-            if 'av_range' in c:
++-                min_, max_ = c.av_range
++-                c.av_frac = np.random.uniform(min_, max_)
++-        self.mp_tlast = 0
++-        while not self.reset_sumo():
++-            pass
++-        ret = super().init_env()
++-        return ret
++-
++-    def step(self, action=[]):
++-        c = self.c
++-        ts = self.ts
++-        max_dist = c.max_dist
++-        depart_speed = c.depart_speed
++-        max_speed = c.max_speed
++-
++-        rl_type = ts.types.rl
++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++-
++-        for rl, act in zip(prev_rls, action):
++-            if c.handcraft or c.handcraft_tl:
++-                route, lane = rl.route, rl.lane
++-                junction = lane.next_junction
++-                level = 1
++-                if junction is not ts.sentinel_junction:
++-                    dist = junction.route_position[route] - rl.route_position
++-                    if c.handcraft:
++-                        for cross_lane in lane.next_cross_lanes:
++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
++-                    elif c.handcraft_tl and dist < 15:
++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
++-                        yellow_time = 0
++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
++-                        horizontal_go = 0 <= rem < t_h
++-                        vertical_go = t_h + yellow_time <= rem
++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
++-                        human_remain = False
++-                        for cross_lane in lane.next_cross_lanes:
++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++-                            human_remain = cross_veh and cross_veh.type is not rl_type
++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
++-            elif c.act_type == 'accel':
++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
++-            else:
++-                level = act / (c.n_actions - 1)
++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++-
++-        if c.tl == 'MaxPressure':
++-            self.mp_tlast += c.sim_step
++-            tmin = c.get('mp_tmin', 0)
++-            if self.mp_tlast >= tmin:
++-                for tl in ts.traffic_lights:
++-                    if ts.get_program(tl) == 'off':
++-                        break
++-                    jun = tl.junction
++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
++-
++-                    total_pressures = []
++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
++-
++-                    ts.set_phase(tl, np.argmax(total_pressures))
++-                self.mp_tlast = 0
++-
++-        super().step()
++-        self.build_platoon()
++-
++-        obs = {}
++-
++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
++-        for veh in rl_type.vehicles:
++-            if hasattr(veh, 'lane'):
++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
++-                junction = lane.next_junction
++-
++-                head, tail = veh, platoon.tail
++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
++-
++-                if junction is ts.sentinel_junction:
++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
++-                else:
++-                    for jun_lane in lane.next_junction_lanes:
++-                        # Defaults for jun_lane
++-                        jun_headtails = vehs_default()
++-
++-                        jun_lane_route = nexti(jun_lane.from_routes)
++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
++-
++-                        if jun_veh:
++-                            if jun_veh.type is rl_type:
++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
++-                                platoon = jun_veh.platoon.prev
++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++-                                    if platoon is None: break
++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
++-                                    platoon = platoon.prev
++-                            else:
++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
++-                                jun_headtails[0] = jun_veh.platoon.tail
++-                                next_cross_platoon = jun_veh.platoon.prev
++-                                if next_cross_platoon:
++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
++-                                    platoon = next_cross_platoon.prev
++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++-                                        if platoon is None: break
++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
++-                                        platoon = platoon.prev
++-                        route_vehs.append((jun_lane_route, jun_headtails))
++-
++-                dist_features, speed_features = [], []
++-                for route, vehs in route_vehs:
++-                    j_pos = junction.route_position[route]
++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
++-                    speed_features.extend([v.speed / max_speed for v in vehs])
++-
++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
++-
++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
++-        ids = sorted(obs)
++-        if c.mrtl:
++-            obs = np.concatenate([obs, np.array([c.beta])])
++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
++-        if c.rew_type == 'outflow':
++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++-        elif c.rew_type == 'time_penalty':
++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
++-        
++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++-
++-        raw_drac = self.calc_drac()
++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++-        drac = np.clip(drac/10, -1, 1)
++-        raw_pet = self.calc_pet()
++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++-        pet = np.clip(pet/6, -1, 1)
++-
++-        raw_ttc = self.calc_ttc()
++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++-        ttc = np.clip(ttc/7, -1, 1)
++-
++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++-
++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++-        return returned
++-        # return Namespace(obs=obs, id=ids, reward=reward)
++-        
++-    def calc_drac(self):
++-        cur_veh_list = self.ts.vehicles
++-        dracs = []
++-        for v in cur_veh_list:
++-            if hasattr(v, 'lane'):
++-                leader, headway = v.leader()
++-                v_speed = v.speed
++-                leader_speed = leader.speed
++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
++-                dracs.append(drac)
++-        fleet_drac = np.nanmean(np.array(dracs))
++-        return fleet_drac
++-    
++-    def calc_pet(self):
++-        cur_veh_list = self.ts.vehicles
++-        pets = []
++-        for v in cur_veh_list:
++-            if hasattr(v, 'lane'):
++-                leader, headway = v.leader()
++-                v_speed = v.speed
++-                if v_speed > 1e-16:
++-                    pet = headway/(v_speed)
++-                    pets.append(pet)
++-        fleet_pet = np.nanmean(np.array(pets))
++-        return fleet_pet
++-
++-    def calc_ttc(self):
++-        cur_veh_list = self.ts.vehicles
++-        ttcs = []
++-        for v in cur_veh_list:
++-            if hasattr(v, 'lane'):
++-                leader, headway = v.leader()
++-                v_speed = v.speed
++-                leader_speed = leader.speed
++-                if leader_speed < v_speed:
++-                    ttc =  headway/(v_speed-leader_speed)
++-                else:
++-                    ttc = np.nan
++-                ttcs.append(ttc)
++-        fleet_ttc = np.nanmean(np.array(ttcs))
++-        return fleet_ttc
++-
++-    def append_step_info(self):
++-        super().append_step_info()
++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
++-
++-    @property
++-    def stats(self):
++-        c = self.c
++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
++-        mean = lambda L: np.mean(L) if len(L) else np.nan
++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
++-        stats['backlog_step'] = mean(info['backlog'])
++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
++-
++-        stats['beta'] = c.beta
++-
++-        if c.multi_flowrate:
++-            stats['flow_horizontal'] = c.flow_rate_h
++-            stats['flow_vertical'] = c.flow_rate_v
++-        return stats
++-
++-class Intersection(Main):
++-    def create_env(c):
++-        if c.multi_flowrate:
++-            return NormEnv(c, IntersectionEnv(c))
++-        else:
++-            c._norm = NormEnv(c, None)
++-            return IntersectionEnv(c)
++-
++-    @property
++-    def observation_space(c):
++-        low = np.full(c._n_obs, c.low)
++-        return Box(low, np.ones_like(low))
++-
++-    @property
++-    def action_space(c):
++-        if c.act_type == 'accel':
++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++-        else:
++-            return Discrete(c.n_actions)
++-
++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++-        log = c.get_log_ii(ii, n_ii)
++-        step_obs_ = rollout.obs
++-        step_obs = step_obs_[:-1]
++-
++-        if not c.multi_flowrate:
++-            rollout.raw_reward = rollout.reward
++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
++-
++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++-
++-        n_veh = np.array([len(o) for o in step_obs])
++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++-        rollout.update(obs=step_obs, ret=step_ret)
++-
++-        step_id_ = rollout.pop('id')
++-        id = np.concatenate(step_id_[:-1])
++-        id_unique = np.unique(id)
++-
++-        reward = np.array(rollout.pop('reward'))
++-        raw_reward = np.array(rollout.pop('raw_reward'))
++-
++-        log(**stats)
++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++-        log(
++-            n_veh_step_mean=n_veh.mean(), 
++-            n_veh_step_sum=n_veh.sum(), 
++-            n_veh_unique=len(id_unique),
++-            
++-            reward_mean=np.mean(reward),
++-            reward_std=np.std(reward),        
++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++-            ssm_mean=np.mean(rollout.ssm),
++-            ssm_std=np.std(rollout.ssm),
++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++-
++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++-            # nom_action = np.mean(rollout.nom_action),
++-            # res_action = np.mean(rollout.res_action),
++-            )
++-        
++-        return rollout
++-
++-if __name__ == '__main__':
++-    c = Intersection.from_args(globals(), locals())
++-    c.setdefaults(
++-        n_steps=200,
++-        step_save=5,
++-
++-        depart_speed=0,
++-        max_speed=13,
++-        max_dist=100,
++-        max_accel=1.5,
++-        max_decel=3.5,
++-        sim_step=0.5,
++-        generic_type=True,
++-        n_actions=3,
++-
++-        adv_norm=False,
++-        batch_concat=True,
++-
++-        render=False,
++-
++-        warmup_steps=100,
++-        horizon=2000,
++-        directions='4way',
++-        av_frac=0.15,
++-        handcraft=False,
++-        handcraft_tl=None,
++-        flow_rate=700,
++-        length=100,
++-        n_rows=1,
++-        n_cols=1,
++-        speed_mode=SPEED_MODE.obey_safe_speed,
++-
++-        act_type='accel_discrete',
++-        low=-1,
++-
++-        alg=PG,
++-        n_gds=1,
++-        lr=1e-3,
++-        gamma=0.99,
++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++-
++-        enter_length=False,
++-        short_exit=False,
++-
++-        rew_type='outflow',
++-        norm_reward=True,
++-        center_reward=True,
++-        multi_flowrate=False,
++-        opt='RMSprop',
++-
++-        obs_tail=True,
++-        obs_next_cross_platoons=1,
++-
++-        beta=0,
++-        scale_pet=1,
++-        scale_drac=1,
++-        seed_np=False,
++-        seed_torch = False,
++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++-        mrtl=False, # this flag deals with adding beta to observation vector
++-    )
++-
++-    if c.seed_torch:
++-        # Set seed for PyTorch CPU operations
++-        torch.manual_seed(c.seed_torch)
++-        # Set seed for PyTorch CUDA operations (if available)
++-        if torch.cuda.is_available():
++-            torch.cuda.manual_seed_all(c.seed_torch)
++-    if c.seed_np:
++-        np.random.seed(c.seed_np)
++-
++-    if c.directions == '4way':
++-        c.directions = ['up', 'right', 'down', 'left']
++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
++-    if c.mrtl:
++-        c._n_obs += 1
++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
++-    c.redef_sumo = 'length_range' in c
++-    c.run()
++\ No newline at end of file
++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++index d4c3dac..9cd7677 100644
++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++@@ -1,600 +1,22378 @@
++-diff --git a/README.md b/README.md
++-index b591747..127f484 100644
++---- a/README.md
++-+++ b/README.md
++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
++- ### 1.2 Set the environmental variables
++- ```
++- # Code directory
++--export F=automatic_vehicular_control/automatic_vehicular_control
++-+export F=automatic_vehicular_control
++- 
++- # Results directory extracted from the zip file
++- export R=results
++-@@ -48,10 +48,8 @@ export R=results
++- ## 2. Directory Structure
++- 
++- The code directory structure is
++--```
++-+``` 
++- automatic_vehicular_control/
++--│
++--├── automatic_vehicular_control/
++- │   ├── __pycache__/                # Compiled Python files
++- │   ├── evaluations/                # Evaluation results and metrics
++- │   ├── models/                     # Model checkpoints
++ diff --git a/env.py b/env.py
++-index 4ab3d95..c83a674 100644
+++index c83a674..c65c948 100644
++ --- a/env.py
++ +++ b/env.py
++-@@ -724,9 +724,11 @@ class TrafficState:
++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
++- 
++-         segments = {}
+++@@ -852,12 +852,15 @@ class TrafficState:
+++         subscribes.sim = SubscribeDef(tc.simulation, [
+++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
+++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
++ +        
++-         def add_from_to(from_, to):
++-             from_.tos.add(to)
++-             to.froms.add(from_)
++-+            
++-         for con in map(values_str_to_val, net.children('connection')):
++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
++-             to_lane = edges[con.to].lanes[int(con.toLane)]
++-@@ -888,89 +890,109 @@ class TrafficState:
++- 
++-     def step(self):
++-         """
++--        Take a simulation step and update state
++-+        Take a simulation step and update state.
++-         """
++--        c = self.c
++--        tc = self.tc
++--        subscribes = self.subscribes
++-+        c = self.c  # Configuration object for the simulation
++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
++- 
++-         # Actual SUMO step
++--        tc.simulationStep()
++--        sim_res = subscribes.sim.get()
++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
++- 
++-+        # Clear references to current vehicle edges and lanes for the next update
++-         for veh in self.vehicles:
++--            veh.unvar('edge', 'lane')
++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
++-+
++-+        # Clear current vehicle data from edges and lanes
++-         for ent in itertools.chain(self.edges, self.lanes):
++--            ent.vehicles.clear()
++--            ent.positions.clear()
++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
++-+            ent.positions.clear()  # Clear vehicle positions
++- 
++-+        # Update traffic light states
++-         for tl_id, tl in self.traffic_lights.items():
++--            tl.update(subscribes.tl.get(tl_id))
++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
++- 
++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
++-         for veh_id in sim_res.loaded_vehicles_ids:
++--            flow_id, _ = veh_id.rsplit('.')
++--            flow = self.flows[flow_id]
++--            flow.backlog.add(veh_id)
++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
++- 
++-+        # Initialize a set for newly departed vehicles
++-         self.new_departed = set()
++-+
++-+        # Handle vehicles that have departed (entered the network)
++-         for veh_id in sim_res.departed_vehicles_ids:
++--            subscribes.veh.subscribe(veh_id)
++--            type_id = tc.vehicle.getTypeID(veh_id)
++--            # import pdb; pdb.set_trace()
++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
++-+            # If vehicle type is 'generic', compute specific type
++-             if type_id == 'generic':
++-                 type_id = self.compute_type(veh_id)
++--            type_ = self.types[type_id]
++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
++--            length = tc.vehicle.getLength(veh_id)
++--            road_id = tc.vehicle.getRoadID(veh_id)
++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
++--            type_.vehicles.add(veh)
++-+            type_ = self.types[type_id]  # Get vehicle type object
++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
++-+
++-+            # Create a new vehicle object and add it to the list of vehicles
++-+            self.vehicles[veh_id] = veh = Vehicle(
++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
++-+            )
++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
++- 
++-+            # Set color if rendering is enabled
++-             if c.render:
++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
++--                self.set_color(veh, color_fn(veh))
++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
++- 
++-+            # Set vehicle speed mode and lane change mode using SUMO settings
++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
++-+
++-+            # Add to new_departed set
++-             self.new_departed.add(veh)
++-+
++-+            # Remove vehicle from backlog if necessary
++-             if '.' in veh_id:
++-                 flow_id, _ = veh_id.rsplit('.')
++-                 if flow_id in self.flows:
++-                     flow = self.flows[flow_id]
++-                     flow.backlog.remove(veh_id)
++- 
++-+        # Handle newly arrived and collided vehicles
++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
++-+        
++-+        # Remove newly arrived vehicles from tracking if they collided
++-         for veh in self.new_arrived:
++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
++- 
++-+        # Update vehicle positions on edges and lanes
++-         for veh_id, veh in self.vehicles.items():
++--            veh.prev_speed = veh.get('speed', None)
++--            veh.update(subscribes.veh.get(veh_id))
++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
++-             if veh_id not in sim_res.colliding_vehicles_ids:
++--                edge = self.edges[veh.road_id]
++--                edge.vehicles.append(veh)
++--                veh.edge = edge
++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
++--            # edge = self.edges[veh.road_id]
++--            # edge.vehicles.append(veh)
++--            # veh.edge = edge
++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
++-+                veh.edge = edge  # Set vehicle's edge attribute
++- 
++-+        # Update vehicle sorting and lane positions
++-         for edge in self.edges:
++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
++-             for edge_i, veh in enumerate(edge.vehicles):
++--                veh.edge_i = edge_i
++--                veh.lane = lane = edge.lanes[veh.lane_index]
++--                veh.lane_i = len(lane.vehicles)
++--                lane.vehicles.append(veh)
++--                lane.positions.append(veh.laneposition)
++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
++- 
++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
++-         self.all_arrived.append(self.new_arrived)
++-         self.all_departed.append(self.new_departed)
++-         self.all_collided.append(self.new_collided)
++--
++-+            
++-     def reset(self, tc):
++-         self.tc = tc
++-         self.subscribes.clear()
++-@@ -1043,6 +1065,7 @@ class Env:
++-     """
++-     Offers a similar reinforcement learning environment interface as gym.Env
++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
++-+    c: Ring class
++-     """
++-     def __init__(self, c):
++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
++-@@ -1056,6 +1079,7 @@ class Env:
++-             if c.get('save_agent'):
++-                 self._agent_info = []
++-         self._step = 0
++-+        self.mean_speed = 0
++- 
++-     def def_sumo(self, *args, **kwargs):
++-         """ Override this with code defining the SUMO network """
++-@@ -1094,49 +1118,91 @@ class Env:
++-         """
++-         return True
++- 
++-+   # Method to reset or initialize the SUMO traffic simulation environment
++-     def reset_sumo(self):
++-+        # Shortcuts for configuration and SUMO definition objects
++-         c = self.c
++-         sumo_def = self.sumo_def
++--
++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+++         subscribes.tl = SubscribeDef(tc.trafficlight, [
+++             TL.red_yellow_green_state])
++ +        
++-+        # Determine if new SUMO definitions need to be generated
++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
+++         subscribes.veh = SubscribeDef(tc.vehicle, [
+++             V.road_id, V.lane_index, V.laneposition,
+++             V.speed, V.position, V.angle,
+++             V.fuelconsumption, V.noxemission])
++ +        
++-         if generate_def:
++--            kwargs = self.def_sumo()
++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
++-+            # Generate new definitions if necessary
++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++-+        
++-+        # Start SUMO with the current traffic controller (tc)
++-         self.tc = sumo_def.start_sumo(self.tc)
++-+        
++-         if generate_def:
++-+            # If new definitions were generated, store relevant SUMO file paths
++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
++-+            
++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
++--            self.ts = TrafficState(c, self.tc, **defs)
++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
++-         else:
++-+            # If not generating new definitions, simply reset the existing traffic state
++-             self.ts.reset(self.tc)
++-+        
++-+        # Set up the traffic state (e.g., initialize the simulation settings)
++-         self.ts.setup()
++-+        
++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
++-         success = self.init_vehicles()
++-+        
++-+        # Return whether the SUMO reset and vehicle initialization were successful
++-         return success
+++         for tl_id in self.traffic_lights.keys():
+++             subscribes.tl.subscribe(tl_id)
++  
++-+    # Method to initialize the environment after SUMO reset
++-     def init_env(self):
++-+        # Reference to the traffic state
++-         ts = self.ts
++-+    
++-+        # Create an empty data structure to store rollout information
++-         self.rollout_info = NamedArrays()
++-+        
++-+        # Turn off all traffic lights in the network
++-         for tl in ts.traffic_lights:
++--            ts.set_program(tl, 'off')
++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
++-+        
++-+        # Reset the step counter to 0
++-         self._step = 0
++-+        
++-+        # Take the first step in the simulation
++-         ret = self.step()
++-+        
++-+        # Run the simulation for a number of warmup steps
++-         for _ in range(self.c.warmup_steps):
++--            ret = self.step()
++-+            ret = self.step()  # Advance the simulation one step
++-+            
++-+            # If the simulation ends during the warmup phase, return None to indicate failure
++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
++-                 return None
++-+        
++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
++-         for tl in ts.traffic_lights:
++--            ts.set_program(tl, '1')
++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
++-+        
++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
++-         if isinstance(ret, tuple):
++--            return ret[0]
++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
++--
++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
++-+        
++-+    # Reset the entire environment, retrying until successful
++-     def reset(self):
++--        while True:
++-+        self.mean_speed = 0
++-+        while True:  # Infinite loop until the environment is successfully reset
++-+            # Attempt to reset the SUMO simulation
++-             if not self.reset_sumo():
++--                continue
++-+                continue  # If reset_sumo fails, retry the loop
++-+            
++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
++-             if (obs := self.init_env()) is not None:
++--                return obs
++-+                return obs  # Successfully initialized, return the observation
++-+
+++@@ -1109,6 +1112,7 @@ class Env:
+++         if self._vehicle_info is not None:
+++             self.extend_vehicle_info()
+++         self._step += 1
++++        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++         return c.observation_space.low, 0, False, None
++  
++-     def append_step_info(self):
++-         """
++-@@ -1231,6 +1297,8 @@ class Env:
++- class NormEnv(gym.Env):
++-     """
++-     Reward normalization with running average https://github.com/joschu/modular_rl
++-+    self.c: Ring parameters 
++-+    self.env: RingEnv class
++-     """
++-     def __init__(self, c, env):
++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
+++     def init_vehicles(self):
+++@@ -1197,6 +1201,7 @@ class Env:
+++         while True:  # Infinite loop until the environment is successfully reset
+++             # Attempt to reset the SUMO simulation
+++             if not self.reset_sumo():
++++                
+++                 continue  # If reset_sumo fails, retry the loop
+++             
+++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
++ diff --git a/exp.py b/exp.py
++-index ead4652..7f7cee5 100644
+++index 7f7cee5..43481b1 100644
++ --- a/exp.py
++ +++ b/exp.py
++-@@ -169,9 +169,9 @@ class Main(Config):
++- 
++-     def on_train_start(c):
++-         # Initialize training: environment, algorithm, model, optimizer, and logging
++--        c.setdefaults(alg='Algorithm')
++--        c._env = c.create_env()
++--
++-+        c.setdefaults(alg='Algorithm') 
++-+        c._env = c.create_env() # Create NormEnv
++-+ 
++-         # Instantiate the algorithm (e.g., PPO, DQN)
++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
++-         c.set_model()
++-@@ -222,8 +222,8 @@ class Main(Config):
++- 
++-     def on_step_start(c, stats={}):
++-         # Update the learning rate and log stats at the start of a training step
++--        lr = c._lr
++--        for g in c._opt.param_groups:
++-+        lr = c._lr # Update Learning Rate
++-+        for g in c._opt.param_groups: # Log Statistics
++-             g['lr'] = float(lr)
++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
++- 
++-@@ -285,10 +285,14 @@ class Main(Config):
+++@@ -285,11 +285,10 @@ class Main(Config):
++              ret = dict(obs=ret)
++          rollout = NamedArrays()
++          rollout.append(**ret)
++--
++-+        rollout_flow_each_step = []
+++-        rollout_flow_each_step = []
++          done = False
++          a_space = c.action_space
++          step = 0
++-+        density = 20/(250*1e-3)
++-+        vehicle_flow = c._env.mean_speed * 3.6 * density 
++-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++-+
++-         while step < c.horizon + c.skip_stat_steps and not done:
++-             # Generate an action from the model's policy
++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
++-@@ -309,6 +313,12 @@ class Main(Config):
++-             rollout.append(**ret)
++-             step += 1
+++-        density = 20/(250*1e-3)
++++        density = c.var().n_veh/(c.var().circumference*1e-3)
+++         vehicle_flow = c._env.mean_speed * 3.6 * density 
+++         print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+++ 
+++@@ -315,8 +314,7 @@ class Main(Config):
++          # Collect stats from the environment
++-+        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++-+        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++-+        density = 20/(250 * 1e-3)
++-+        vehicle_flow = c._env.mean_speed * density 
++-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++-+
+++         # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+++         # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+++-        density = 20/(250 * 1e-3)
+++-        vehicle_flow = c._env.mean_speed * density 
++++        vehicle_flow = c._env.mean_speed * density  * 3.6
+++         print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+++ 
++          stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
++-         return rollout, stats
+++@@ -406,9 +404,8 @@ class Main(Config):
++  
++-@@ -398,10 +408,10 @@ class Main(Config):
+++     def train(c):
++          # Main training loop
++-         c.on_train_start()
+++-        c.on_train_start()
++++        c.on_train_start() # Ring Env
++          while c._i < c.n_steps:
++--            c.on_step_start()
++-+            c.on_step_start() # save stat 
+++-            c.on_step_start() # save stat 
++              with torch.no_grad():
++                  # Collect rollouts without computing gradients
++--                rollouts = c.rollouts()
++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++-             gd_stats = {}
++-             if len(rollouts.obs):
++-                 t_start = time()
++-@@ -410,7 +420,7 @@ class Main(Config):
++-                 gd_stats.update(gd_time=time() - t_start)
++-             c.on_step_end(gd_stats)
++-             c._i += 1
++--        c.on_step_start()  # last step
++-+        c.on_step_start()  # save stat
++-         gd_stats = {}
++-         with torch.no_grad():
++-             rollouts = c.rollouts()
++-@@ -450,6 +460,8 @@ class Main(Config):
++-         if hasattr(c._env, 'close'):
++-             c._env.close()
++- 
++-+  
+++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++@@ -497,3 +494,31 @@ class Main(Config):
+++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
+++             c.train()
+++         c.log('job done!')
++ +
++-     def run(c):
++-         # Determine whether to train or evaluate based on configuration
++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++-diff --git a/ring.py b/ring.py
++-index 94d632d..ee1372b 100644
++---- a/ring.py
++-+++ b/ring.py
++-@@ -15,7 +15,6 @@ class RingEnv(Env):
++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++-         )
++++    def run_2(c):
++++        # Determine whether to train or evaluate based on configuration
++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
++++        c.on_train_start()
++++        c._env = c.create_env() # Create NormEnv
++++        ret = c._env.reset()
++++        c.set_model()
++++        step = 0
++++        density = 20/(250*1e-3)
++++        vehicle_flow = c._env.mean_speed * 3.6 * density 
++++        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++++        done = False
++++        while step < c.horizon + c.skip_stat_steps and not done:
++++            # Take a step in the environment
++++            ret = c._env.step()
++++            if isinstance(ret, tuple):
++++                obs, reward, done, info = ret
++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
++++            done = ret.setdefault('done', False)
++++            step += 1
++++        # Collect stats from the environment
++++        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++++        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++++        density = 20/(250 * 1e-3)
++++        vehicle_flow = c._env.mean_speed * density 
++++        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
+++deleted file mode 100644
+++index 6b9ba52..0000000
+++--- a/highway_bottleneck.py
++++++ /dev/null
+++@@ -1,381 +0,0 @@
+++-from automatic_vehicular_control.exp import *
+++-from automatic_vehicular_control.env import *
+++-from automatic_vehicular_control.u import *
++ -
++-         # Function to generate the shape of the edges (circular arcs)
++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++- 
++-@@ -88,6 +87,17 @@ class RingEnv(Env):
++-         if c.circumference_range:  # Check if the circumference should be randomized
++-             # Randomly set the circumference within the specified range
++-             c.circumference = np.random.randint(*c.circumference_range)
++-+        
++-+        if self.flow_log:
++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
++-+            self.episode_flow.append(average_flow)
++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
++-+        
++-+        # Reset flow counters for the new episode
++-+        self.flow_counter = 0
++-+        self.flow_log = []
++-+        self.last_vehicle_times = {}
++-+        
++-         return super().reset_sumo()  # Reset the simulation
+++-class BNeckEnv(Env):
+++-    def def_sumo(self):
+++-        c = self.c
+++-        nodes = E('nodes',
+++-            E('node', id='n_0', x=0, y=0), *(
+++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
+++-        ))
+++-        edges = E('edges', *(
+++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
+++-                'numLanes': n_lane,
+++-                'speed': c.max_speed
+++-            }) for i, n_lane in enumerate(c.n_lanes)
+++-        ))
+++-        connections = E('connections', *(
+++-            E('connection', **{
+++-                'from': prev.id,
+++-                'to': curr.id,
+++-                'fromLane': i,
+++-                'toLane': int(i / prev.numLanes * curr.numLanes)
+++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
+++-        ))
+++-
+++-        if c.split_flow:
+++-            n_inflow_lanes = c.n_lanes[0]
+++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
+++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
+++-                for i in range(n_inflow_lanes)
+++-            ]
+++-        else:
+++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
+++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
+++-            ]
+++-        routes = E('routes',
+++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
+++-            *flows
+++-        )
+++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
+++-        additional = E('additional',
+++-            E('vType', id='generic', **idm_params),
+++-            E('vType', id='rl', **idm_params),
+++-            E('vType', id='human', **idm_params),
+++-        )
+++-        sumo_args = {'collision.action': COLLISION.remove}
+++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++-
+++-    def reset_sumo(self):
+++-        c = self.c
+++-        if c.flow_rate_range:
+++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
+++-        ret = super().reset_sumo()
+++-        if c.vinitsky:
+++-            self.obs_lanes = [(lane, i_start * c.piece_length)
+++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
+++-                for i_start in range(round(edge.length) // c.piece_length)
+++-                for lane in edge.lanes
+++-            ]
+++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
+++-            self.last_outflows = []
+++-        return ret
+++-
+++-    def step(self, action=[]):
+++-        c = self.c
+++-        ts = self.ts
+++-        max_dist = 100
+++-        max_speed = c.max_speed
+++-        human_type = ts.types.human
+++-        rl_type = ts.types.rl
+++-
+++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++-        if c.vinitsky:
+++-            if len(action):
+++-                assert len(action) == len(self.control_lanes)
+++-                for (lane, piece_start), act in zip(self.control_lanes, action):
+++-                    self.control_lanes[lane, piece_start] = np.clip(
+++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
+++-                        0.1, max_speed
+++-                    )
+++-                for veh in prev_rls:
+++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
+++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
+++-        else:
+++-            for veh, act in zip(prev_rls, action):
+++-                if c.handcraft:
+++-                    route, edge, lane = veh.route, veh.edge, veh.lane
+++-                    next_lane = lane.next(veh.route)
+++-                    level = 1
+++-                    if next_lane and next_lane.get('junction'):
+++-                        merge_dist = lane.length - veh.laneposition
+++-                        if merge_dist < c.handcraft:
+++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
+++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
+++-                                level = 0
+++-                    if c.act_type.startswith('accel'):
+++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++-                    else:
+++-                        ts.set_max_speed(veh, max_speed * level)
+++-                    continue
+++-                if not isinstance(act, (int, np.integer)):
+++-                    act = (act - c.low) / (1 - c.low)
+++-                if c.act_type.startswith('accel'):
+++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++-                else:
+++-                    if c.act_type == 'continuous':
+++-                        level = act[0]
+++-                    elif c.act_type == 'discretize':
+++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++-                    elif c.act_type == 'discrete':
+++-                        level = act / (c.n_actions - 1)
+++-                    ts.set_max_speed(veh, max_speed * level)
+++-
+++-                if c.lc_av == 'binary' and act[1] > 0.5:
+++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
+++-
+++-        super().step()
+++-
+++-        if c.vinitsky:
+++-            n_last_outflows = 20
+++-            max_vehs = 4
+++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
+++-            obs = []
+++-            for lane, piece_start in self.obs_lanes:
+++-                piece_end = piece_start + c.piece_length
+++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
+++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
+++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
+++-                obs.extend([
+++-                    len(lane_humans) / max_vehs,
+++-                    len(lane_avs) / max_vehs,
+++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
+++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
+++-                ])
+++-            if len(self.last_outflows) == n_last_outflows:
+++-                self.last_outflows = self.last_outflows[1:]
+++-            self.last_outflows.append(len(ts.new_arrived))
+++-            reward = np.mean(self.last_outflows)
+++-            obs.append(reward / max_veh_outflows)
+++-            obs = np.array(obs, dtype=np.float32)
+++-            assert 0 <= obs.min() and obs.max() <= 1
+++-            return obs, reward, False, None
+++-        route = nexti(ts.routes)
+++-        obs, ids = [], []
+++-        default_close = [0, max_speed]
+++-        default_far = [max_dist, 0]
+++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
+++-            merge_dist = max_dist
+++-            default_human = default_far
+++-
+++-            other_info = {}
+++-            next_lane = lane.next(veh.route)
+++-            if next_lane and next_lane.get('junction'):
+++-                merge_dist = lane.length - veh.laneposition
+++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++-                pos = other_lane.length if c.veh_junction else veh.laneposition
+++-                # Look for veh on other lane but do not extend past that lane
+++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
+++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
+++-                    if other_veh.type is rl_type:
+++-                        default_human = default_close
+++-                        break
+++-
+++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
+++-            ids.append(veh.id)
+++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
+++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++-        
+++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++-
+++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++-        ttc = np.clip(ttc/7, -1, 1)
+++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++-        drac = np.clip(drac/10, -1, 1)
+++-
+++-        raw_pet = self.calc_pet()
+++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++-        pet = np.clip(pet, -1, 1)
+++-
+++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++-        
+++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++-        return returned
+++-        
+++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++-    
+++-    def calc_ttc(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        ttcs = []
+++-        for v in cur_veh_list:
+++-            leader, headway = v.leader()
+++-            v_speed = v.speed
+++-            leader_speed = leader.speed
+++-            if leader_speed < v_speed:
+++-                ttc =  headway/(v_speed-leader_speed)
+++-            else:
+++-                ttc = np.nan
+++-            ttcs.append(ttc)
+++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++-        return fleet_ttc
+++-    
+++-    def calc_drac(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        dracs = []
+++-        for v in cur_veh_list:
+++-            leader, headway = v.leader()
+++-            v_speed = v.speed
+++-            leader_speed = leader.speed
+++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
+++-            dracs.append(drac)
+++-        fleet_drac = np.nanmean(np.array(dracs))
+++-        return fleet_drac
+++-
+++-    def calc_pet(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        pets = []
+++-        for v in cur_veh_list:
+++-            leader, headway = v.leader()
+++-            v_speed = v.speed
+++-            if v_speed > 1e-16:
+++-                pet = headway/(v_speed)
+++-                pets.append(pet)
+++-        fleet_pet = np.nanmean(np.array(pets))
+++-        return fleet_pet
+++-
+++-class BNeck(Main):
+++-    def create_env(c):
+++-        return BNeckEnv(c)
+++-
+++-    @property
+++-    def observation_space(c):
+++-        low = np.full(c._n_obs, c.low)
+++-        return Box(low, np.ones_like(low))
+++-
+++-    @property
+++-    def action_space(c):
+++-        if c.vinitsky:
+++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
+++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++-            assert c.lc_av in [False, 'binary']
+++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
+++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++-            return Discrete(c.n_actions)
+++-
+++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++-        if c.vinitsky:
+++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
+++-        log = c.get_log_ii(ii, n_ii)
+++-        step_obs_ = rollout.obs
+++-        step_obs = step_obs_[:-1]
+++-
+++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++-
+++-        n_veh = np.array([len(o) for o in step_obs])
+++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++-        rollout.update(obs=step_obs, ret=step_ret)
+++-
+++-        step_id_ = rollout.pop('id')
+++-        id = np.concatenate(step_id_[:-1])
+++-        id_unique = np.unique(id)
+++-
+++-        reward = np.array(rollout.pop('reward'))
+++-
+++-        log(**stats)
+++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++-        log(
+++-            n_veh_step_mean=n_veh.mean(), 
+++-            n_veh_step_sum=n_veh.sum(), 
+++-            n_veh_unique=len(id_unique),
+++-            
+++-            reward_mean=np.mean(reward),
+++-            reward_std=np.std(reward),        
+++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++-            ssm_mean=np.mean(rollout.ssm),
+++-            ssm_std=np.std(rollout.ssm),
+++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++-
+++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++-            # nom_action = np.mean(rollout.nom_action),
+++-            # res_action = np.mean(rollout.res_action),
+++-            )
+++-        return rollout
+++-
+++-if __name__ == '__main__':
+++-    c = BNeck.from_args(globals(), locals()).setdefaults(
+++-        warmup_steps=1000,
+++-        horizon=2000,
+++-        n_steps=100,
+++-        step_save=5,
+++-
+++-        av_frac=0.2,
+++-        sim_step=0.5,
+++-        depart_speed=0,
+++-        edge_lengths=[100, 100, 50],
+++-        n_lanes=[4, 2, 1],
+++-        max_speed=30,
+++-
+++-        lc_av=False,
+++-        flow_rate=2300,
+++-        flow_rate_range=None,
+++-        split_flow=True,
+++-        generic_type='rand',
+++-        speed_mode=SPEED_MODE.all_checks,
+++-        lc_mode=LC_MODE.off,
+++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++-
+++-        veh_junction=False,
+++-        act_type='accel_discrete',
+++-        max_accel=2.6,
+++-        max_decel=4.5,
+++-        tau=1.0,
+++-        min_gap=2.5,
+++-        delta=4,
+++-        n_actions=3,
+++-        low=-1,
+++-        handcraft=False,
+++-        vinitsky=False,
+++-
+++-        render=False,
+++-
+++-        alg=PG,
+++-        lr=1e-3,
+++-
+++-        gamma=0.99,
+++-        adv_norm=False,
+++-        batch_concat=True,
+++-
+++-        beta=0,
+++-        scale_ttc=1,
+++-        scale_drac=1,
+++-        seed_np=False,
+++-        seed_torch = False,
+++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++-        mrtl=False, # this flag deals with adding beta to observation vector
+++-
+++-    )
+++-    
+++-    if c.seed_torch:
+++-        # Set seed for PyTorch CPU operations
+++-        torch.manual_seed(c.seed_torch)
+++-        # Set seed for PyTorch CUDA operations (if available)
+++-        if torch.cuda.is_available():
+++-            torch.cuda.manual_seed_all(c.seed_torch)
+++-    if c.seed_np:
+++-        np.random.seed(c.seed_np)
+++-        
+++-    if c.vinitsky:
+++-        c.piece_length = 20
+++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
+++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
+++-        c._n_action = sum(n_actions[:-1])
+++-        c._n_obs = sum(n_actions) * 4 + 1
+++-        c.batch_concat = False
+++-    else:
+++-        c._n_obs = 2 + 2 + 2
+++-        
+++-    if c.mrtl:
+++-        c._n_obs += 1 # modified for mrtl related
+++-        
+++-    c.redef_sumo = bool(c.flow_rate_range)
+++-    c.run()
+++\ No newline at end of file
+++diff --git a/highway_ramp.py b/highway_ramp.py
+++deleted file mode 100644
+++index ef0358f..0000000
+++--- a/highway_ramp.py
++++++ /dev/null
+++@@ -1,325 +0,0 @@
+++-from automatic_vehicular_control.exp import *
+++-from automatic_vehicular_control.env import *
+++-from automatic_vehicular_control.u import *
+++-
+++-class RampEnv(Env):
+++-    # https://flow-project.github.io/papers/08569485.pdf
+++-    def def_sumo(self):
+++-        c = self.c
+++-        builder = NetBuilder()
+++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
+++-            (0, 0),
+++-            (c.premerge_distance, 0),
+++-            (c.premerge_distance + c.merge_distance, 0),
+++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
+++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
+++-        ])
+++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
+++-            {}, {'numLanes': 2}, {}
+++-        ], lane_maps=[
+++-            {0: 1}, {0: 0, 1: 0}
+++-        ], route_id='highway')
+++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
+++-            {}, {'numLanes': 2}, {}
+++-        ], lane_maps=[
+++-            {0: 0}, {0: 0, 1: 0}
+++-        ], route_id='ramp')
+++-        nodes, edges, connections, routes = builder.build()
+++-        nodes[2].type = 'zipper'
+++-
+++-        routes = E('routes',
+++-            *routes,
+++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
+++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
+++-        )
+++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
+++-        additional = E('additional',
+++-            E('vType', id='generic', **idm),
+++-            E('vType', id='rl', **idm),
+++-            E('vType', id='human', **idm),
+++-        )
+++-        sumo_args = {'collision.action': COLLISION.remove}
+++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++-
+++-    def step(self, action=[]):
+++-        c = self.c
+++-        ts = self.ts
+++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
+++-        max_speed = c.max_speed
+++-        human_type = ts.types.human
+++-        rl_type = ts.types.rl
+++-
+++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++-        for rl, act in zip(prev_rls, action):
+++-            if c.handcraft:
+++-                route, edge, lane = rl.route, rl.edge, rl.lane
+++-                leader, dist = rl.leader()
+++-                level = 1
+++-                if edge.id == 'e_n_0.0_n_400.0':
+++-                    if rl.laneposition < 100:
+++-                        leaders = list(rl.leaders())
+++-                        if len(leaders) > 20:
+++-                            level = 0
+++-                        else:
+++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++-                continue
+++-            if not isinstance(act, (int, np.integer)):
+++-                act = (act - c.low) / (1 - c.low)
+++-            if c.act_type.startswith('accel'):
+++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++-            else:
+++-                if c.act_type == 'continuous':
+++-                    level = act[0]
+++-                elif c.act_type == 'discretize':
+++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++-                elif c.act_type == 'discrete':
+++-                    level = act / (c.n_actions - 1)
+++-                ts.set_max_speed(rl, max_speed * level)
+++-
+++-        super().step()
+++-
+++-        route = ts.routes.highway
+++-        obs, ids = [], []
+++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++-            if hasattr(veh, 'edge'):
+++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
+++-                merge_dist = max_dist
+++-
+++-                lead_speed = follow_speed = other_speed = 0
+++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
+++-
+++-                leader, dist = veh.leader()
+++-                if leader: lead_speed, lead_dist = leader.speed, dist
+++-
+++-                follower, dist = veh.follower()
+++-                if follower: follow_speed, follow_dist = follower.speed, dist
+++-
+++-                if c.global_obs:
+++-                    jun_edge = edge.next(route)
+++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
+++-                        jun_edge = jun_edge.next(route)
+++-                    if jun_edge:
+++-                        merge_dist = lane.length - veh.laneposition
+++-                        next_edge = edge.next(route)
+++-                        while next_edge is not jun_edge:
+++-                            merge_dist += next_edge.length
+++-                            next_edge = next_edge.next(route)
+++-
+++-                        other_lane = jun_edge.lanes[0]
+++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
+++-                            other_speed = other_veh.speed
+++-                            break
+++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
+++-                else:
+++-                    next_lane = lane.next(route)
+++-                    if next_lane and next_lane.get('junction'):
+++-                        if len(edge.lanes) == 2:
+++-                            other_lane = edge.lanes[0]
+++-                            pos = veh.laneposition
+++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
+++-                                other_speed = other_veh.speed
+++-                                break
+++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
+++-                ids.append(veh.id)
+++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
+++-        if c.mrtl:
+++-            obs = np.concatenate([obs, np.array([c.beta])])
+++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++-        
+++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++-
+++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++-        ttc = np.clip(ttc/7, -1, 1)
+++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++-        drac = np.clip(drac/10, -1, 1)
+++-
+++-        raw_pet = self.calc_pet()
+++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++-        pet = np.clip(pet, -1, 1)
+++-
+++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++-        
+++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++-        return returned
+++-        
+++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++-    
+++-    def calc_ttc(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        ttcs = []
+++-        for v in cur_veh_list:
+++-            if hasattr(v, 'edge'):
+++-                leader, headway = v.leader()
+++-                if leader:
+++-                    v_speed = v.speed
+++-                    leader_speed = leader.speed
+++-                    if leader_speed < v_speed:
+++-                        ttc =  headway/(v_speed-leader_speed)
+++-                    else:
+++-                        ttc = np.nan
+++-                    ttcs.append(ttc)
+++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++-        return fleet_ttc
+++-    
+++-    def calc_drac(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        dracs = []
+++-        for v in cur_veh_list:
+++-            if hasattr(v, 'edge'):
+++-                leader, headway = v.leader()
+++-                if leader:
+++-                    v_speed = v.speed
+++-                    leader_speed = leader.speed
+++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
+++-                    dracs.append(drac)
+++-        fleet_drac = np.nanmean(np.array(dracs))
+++-        return fleet_drac
+++-
+++-    def calc_pet(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        pets = []
+++-        for v in cur_veh_list:
+++-            if hasattr(v, 'edge'):
+++-                leader, headway = v.leader()
+++-                if leader:
+++-                    v_speed = v.speed
+++-                    if v_speed > 1e-16:
+++-                        pet = headway/(v_speed)
+++-                        pets.append(pet)
+++-        fleet_pet = np.nanmean(np.array(pets))
+++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
+++-        return fleet_pet
+++-
+++-class Ramp(Main):
+++-    def create_env(c):
+++-        return RampEnv(c)
+++-
+++-    @property
+++-    def observation_space(c):
+++-        low = np.full(c._n_obs, c.low)
+++-        return Box(low, np.ones_like(low))
+++-
+++-    @property
+++-    def action_space(c):
+++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++-            return Discrete(c.n_actions)
+++-
+++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++-        log = c.get_log_ii(ii, n_ii)
+++-        step_obs_ = rollout.obs
+++-        step_obs = step_obs_[:-1]
+++-
+++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++-
+++-        n_veh = np.array([len(o) for o in step_obs])
+++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++-        rollout.update(obs=step_obs, ret=step_ret)
+++-
+++-        step_id_ = rollout.pop('id')
+++-        id = np.concatenate(step_id_[:-1])
+++-        id_unique = np.unique(id)
+++-
+++-        reward = np.array(rollout.pop('reward'))
+++-
+++-        log(**stats)
+++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++-        log(
+++-            n_veh_step_mean=n_veh.mean(), 
+++-            n_veh_step_sum=n_veh.sum(), 
+++-            n_veh_unique=len(id_unique),
+++-            
+++-            reward_mean=np.mean(reward),
+++-            reward_std=np.std(reward),        
+++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++-            ssm_mean=np.mean(rollout.ssm),
+++-            ssm_std=np.std(rollout.ssm),
+++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++-
+++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++-            # nom_action = np.mean(rollout.nom_action),
+++-            # res_action = np.mean(rollout.res_action),
+++-            )
+++-        return rollout
+++-
+++-if __name__ == '__main__':
+++-    c = Ramp.from_args(globals(), locals()).setdefaults(
+++-        warmup_steps=100,
+++-        horizon=2000,
+++-        n_steps=100,
+++-        step_save=5,
+++-
+++-        premerge_distance=400,
+++-        merge_distance=100,
+++-        postmerge_distance=30,
+++-        av_frac=0.1,
+++-        sim_step=0.5,
+++-        max_speed=30,
+++-        highway_depart_speed=10,
+++-        ramp_depart_speed=0,
+++-        highway_flow_rate=2000,
+++-        ramp_flow_rate=300,
+++-        global_obs=False,
+++-        handcraft=False,
+++-
+++-        generic_type='default',
+++-        speed_mode=SPEED_MODE.all_checks,
+++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++-
+++-        act_type='accel_discrete',
+++-        max_accel=1,
+++-        max_decel=1.5,
+++-        n_actions=3,
+++-        low=-1,
+++-
+++-        render=False,
+++-
+++-        alg=PG,
+++-        lr=1e-3,
+++-
+++-        gamma=0.99,
+++-        adv_norm=False,
+++-        batch_concat=True,
+++-
+++-        beta=0,
+++-        scale_ttc=1,
+++-        scale_drac=1,
+++-        seed_np=False,
+++-        seed_torch = False,
+++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++-        mrtl=False, # this flag deals with adding beta to observation vector
+++-
+++-    )
+++-    
+++-    if c.seed_torch:
+++-        # Set seed for PyTorch CPU operations
+++-        torch.manual_seed(c.seed_torch)
+++-        # Set seed for PyTorch CUDA operations (if available)
+++-        if torch.cuda.is_available():
+++-            torch.cuda.manual_seed_all(c.seed_torch)
+++-    if c.seed_np:
+++-        np.random.seed(c.seed_np)
+++-        
+++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
+++-    if c.mrtl:
+++-        c._n_obs += 1 # modified for mrtl related
+++-    c.run()
+++\ No newline at end of file
+++diff --git a/intersection.py b/intersection.py
+++deleted file mode 100644
+++index e38a84f..0000000
+++--- a/intersection.py
++++++ /dev/null
+++@@ -1,489 +0,0 @@
+++-from automatic_vehicular_control.u import *
+++-from automatic_vehicular_control.exp import *
+++-from automatic_vehicular_control.env import *
+++-
+++-class Platoon(Entity):
+++-    pass
+++-
+++-class IntersectionEnv(Env):
+++-    def def_sumo(self):
+++-        c = self.c
+++-
+++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
+++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
+++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
+++-        ] if params.get('vehsPerHour')]
+++-
+++-        builder = NetBuilder()
+++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
+++-        if c.enter_length:
+++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++-            xys[1:, :, 0] += c.enter_length - c.length
+++-            xys[:, 1:, 1] += c.enter_length - c.length
+++-            xys = xys.reshape(-1, 2)
+++-        if c.short_exit:
+++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++-            xys[-1, :, 0] += c.short_exit - c.length
+++-            xys[:, -1, 1] += c.short_exit - c.length
+++-            xys = xys.reshape(-1, 2)
+++-        nodes = builder.add_nodes(
+++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
+++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
+++-        # import pdb; pdb.set_trace()
+++-
+++-        tl = c.setdefault('tl', False)
+++-        if tl:
+++-            c.av_frac = 0
+++-            c.pop('av_range', None)
+++-            c.speed_mode = SPEED_MODE.all_checks
+++-
+++-        flows = []
+++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
+++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
+++-        for direction in c.directions:
+++-            chains = nodes if direction in ['left', 'right'] else nodes.T
+++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
+++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
+++-
+++-            edge_attrs = dict(priority=int(direction in priority))
+++-            if c.get('set_edge_speed', True):
+++-                edge_attrs['speed'] = c.max_speed
+++-
+++-            for i, chain in enumerate(chains[1:-1]):
+++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
+++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
+++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
+++-
+++-        tls = []
+++-        if tl:
+++-            tl = 1000000 if tl == 'MaxPressure' else tl
+++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
+++-            tl_offset = c.get('tl_offset', 'auto')
+++-            yellow = c.get('yellow', 0.5)
+++-            if tl_offset == 'auto':
+++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
+++-            elif tl_offset == 'same':
+++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
+++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
+++-                node.type = 'traffic_light'
+++-                phase_multiple = len(c.directions) // 2
+++-                tls.append(E('tlLogic',
+++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
+++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
+++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
+++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
+++-                id=node.id, offset=offset, type='static', programID='1'))
+++-
+++-        nodes, edges, connections, routes = builder.build()
+++-        additional = E('additional', *types, *routes, *flows, *tls)
+++-        return super().def_sumo(nodes, edges, connections, additional)
+++-
+++-    def build_platoon(self):
+++-        ts = self.ts
+++-        rl_type = ts.types.rl
+++-        for route in ts.routes:
+++-            vehs = []
+++-            route_offset = 0
+++-            for edge in route.edges:
+++-                for veh in edge.vehicles:
+++-                    veh.route_position = route_offset + veh.laneposition
+++-                    vehs.append(veh)
+++-                route_offset += edge.length
+++-
+++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
+++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
+++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
+++-            rl_idxs, = rl_mask.nonzero()
+++-            split_idxs = 1 + rl_idxs
+++-
+++-            prev = None
+++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
+++-                if not len(vehs_i):
+++-                    continue # Last vehicle is RL, so the last split is empty
+++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
+++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
+++-                )
+++-                if prev is not None:
+++-                    prev.next = platoon
+++-                prev = platoon
+++-                for veh in vehs_i:
+++-                    veh.platoon = platoon
+++-            if prev is not None:
+++-                prev.next = None
+++-
+++-    def reset(self):
+++-        c = self.c
+++-        if c.e is False:
+++-            if 'length_range' in c:
+++-                min_, max_ = c.length_range
+++-                c.setdefaults(max_length=max_)
+++-                c.length = np.random.randint(min_, max_ + 1)
+++-            if 'av_range' in c:
+++-                min_, max_ = c.av_range
+++-                c.av_frac = np.random.uniform(min_, max_)
+++-        self.mp_tlast = 0
+++-        while not self.reset_sumo():
+++-            pass
+++-        ret = super().init_env()
+++-        return ret
+++-
+++-    def step(self, action=[]):
+++-        c = self.c
+++-        ts = self.ts
+++-        max_dist = c.max_dist
+++-        depart_speed = c.depart_speed
+++-        max_speed = c.max_speed
+++-
+++-        rl_type = ts.types.rl
+++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++-
+++-        for rl, act in zip(prev_rls, action):
+++-            if c.handcraft or c.handcraft_tl:
+++-                route, lane = rl.route, rl.lane
+++-                junction = lane.next_junction
+++-                level = 1
+++-                if junction is not ts.sentinel_junction:
+++-                    dist = junction.route_position[route] - rl.route_position
+++-                    if c.handcraft:
+++-                        for cross_lane in lane.next_cross_lanes:
+++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
+++-                    elif c.handcraft_tl and dist < 15:
+++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
+++-                        yellow_time = 0
+++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
+++-                        horizontal_go = 0 <= rem < t_h
+++-                        vertical_go = t_h + yellow_time <= rem
+++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
+++-                        human_remain = False
+++-                        for cross_lane in lane.next_cross_lanes:
+++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++-                            human_remain = cross_veh and cross_veh.type is not rl_type
+++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
+++-            elif c.act_type == 'accel':
+++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
+++-            else:
+++-                level = act / (c.n_actions - 1)
+++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++-
+++-        if c.tl == 'MaxPressure':
+++-            self.mp_tlast += c.sim_step
+++-            tmin = c.get('mp_tmin', 0)
+++-            if self.mp_tlast >= tmin:
+++-                for tl in ts.traffic_lights:
+++-                    if ts.get_program(tl) == 'off':
+++-                        break
+++-                    jun = tl.junction
+++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
+++-
+++-                    total_pressures = []
+++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
+++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
+++-
+++-                    ts.set_phase(tl, np.argmax(total_pressures))
+++-                self.mp_tlast = 0
+++-
+++-        super().step()
+++-        self.build_platoon()
+++-
+++-        obs = {}
+++-
+++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
+++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
+++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
+++-        for veh in rl_type.vehicles:
+++-            if hasattr(veh, 'lane'):
+++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
+++-                junction = lane.next_junction
+++-
+++-                head, tail = veh, platoon.tail
+++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
+++-
+++-                if junction is ts.sentinel_junction:
+++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
+++-                else:
+++-                    for jun_lane in lane.next_junction_lanes:
+++-                        # Defaults for jun_lane
+++-                        jun_headtails = vehs_default()
+++-
+++-                        jun_lane_route = nexti(jun_lane.from_routes)
+++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
+++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
+++-
+++-                        if jun_veh:
+++-                            if jun_veh.type is rl_type:
+++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
+++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
+++-                                platoon = jun_veh.platoon.prev
+++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++-                                    if platoon is None: break
+++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++-                                    platoon = platoon.prev
+++-                            else:
+++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
+++-                                jun_headtails[0] = jun_veh.platoon.tail
+++-                                next_cross_platoon = jun_veh.platoon.prev
+++-                                if next_cross_platoon:
+++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
+++-                                    platoon = next_cross_platoon.prev
+++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++-                                        if platoon is None: break
+++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++-                                        platoon = platoon.prev
+++-                        route_vehs.append((jun_lane_route, jun_headtails))
+++-
+++-                dist_features, speed_features = [], []
+++-                for route, vehs in route_vehs:
+++-                    j_pos = junction.route_position[route]
+++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
+++-                    speed_features.extend([v.speed / max_speed for v in vehs])
+++-
+++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++-
+++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
+++-        ids = sorted(obs)
+++-        if c.mrtl:
+++-            obs = np.concatenate([obs, np.array([c.beta])])
+++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
+++-        if c.rew_type == 'outflow':
+++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++-        elif c.rew_type == 'time_penalty':
+++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
+++-        
+++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++-
+++-        raw_drac = self.calc_drac()
+++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++-        drac = np.clip(drac/10, -1, 1)
+++-        raw_pet = self.calc_pet()
+++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++-        pet = np.clip(pet/6, -1, 1)
+++-
+++-        raw_ttc = self.calc_ttc()
+++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++-        ttc = np.clip(ttc/7, -1, 1)
+++-
+++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
+++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++-
+++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++-        return returned
+++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++-        
+++-    def calc_drac(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        dracs = []
+++-        for v in cur_veh_list:
+++-            if hasattr(v, 'lane'):
+++-                leader, headway = v.leader()
+++-                v_speed = v.speed
+++-                leader_speed = leader.speed
+++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
+++-                dracs.append(drac)
+++-        fleet_drac = np.nanmean(np.array(dracs))
+++-        return fleet_drac
+++-    
+++-    def calc_pet(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        pets = []
+++-        for v in cur_veh_list:
+++-            if hasattr(v, 'lane'):
+++-                leader, headway = v.leader()
+++-                v_speed = v.speed
+++-                if v_speed > 1e-16:
+++-                    pet = headway/(v_speed)
+++-                    pets.append(pet)
+++-        fleet_pet = np.nanmean(np.array(pets))
+++-        return fleet_pet
+++-
+++-    def calc_ttc(self):
+++-        cur_veh_list = self.ts.vehicles
+++-        ttcs = []
+++-        for v in cur_veh_list:
+++-            if hasattr(v, 'lane'):
+++-                leader, headway = v.leader()
+++-                v_speed = v.speed
+++-                leader_speed = leader.speed
+++-                if leader_speed < v_speed:
+++-                    ttc =  headway/(v_speed-leader_speed)
+++-                else:
+++-                    ttc = np.nan
+++-                ttcs.append(ttc)
+++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++-        return fleet_ttc
+++-
+++-    def append_step_info(self):
+++-        super().append_step_info()
+++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
+++-
+++-    @property
+++-    def stats(self):
+++-        c = self.c
+++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
+++-        mean = lambda L: np.mean(L) if len(L) else np.nan
+++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
+++-        stats['backlog_step'] = mean(info['backlog'])
+++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
+++-
+++-        stats['beta'] = c.beta
+++-
+++-        if c.multi_flowrate:
+++-            stats['flow_horizontal'] = c.flow_rate_h
+++-            stats['flow_vertical'] = c.flow_rate_v
+++-        return stats
+++-
+++-class Intersection(Main):
+++-    def create_env(c):
+++-        if c.multi_flowrate:
+++-            return NormEnv(c, IntersectionEnv(c))
+++-        else:
+++-            c._norm = NormEnv(c, None)
+++-            return IntersectionEnv(c)
+++-
+++-    @property
+++-    def observation_space(c):
+++-        low = np.full(c._n_obs, c.low)
+++-        return Box(low, np.ones_like(low))
+++-
+++-    @property
+++-    def action_space(c):
+++-        if c.act_type == 'accel':
+++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++-        else:
+++-            return Discrete(c.n_actions)
+++-
+++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++-        log = c.get_log_ii(ii, n_ii)
+++-        step_obs_ = rollout.obs
+++-        step_obs = step_obs_[:-1]
+++-
+++-        if not c.multi_flowrate:
+++-            rollout.raw_reward = rollout.reward
+++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
+++-
+++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++-
+++-        n_veh = np.array([len(o) for o in step_obs])
+++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++-        rollout.update(obs=step_obs, ret=step_ret)
+++-
+++-        step_id_ = rollout.pop('id')
+++-        id = np.concatenate(step_id_[:-1])
+++-        id_unique = np.unique(id)
+++-
+++-        reward = np.array(rollout.pop('reward'))
+++-        raw_reward = np.array(rollout.pop('raw_reward'))
+++-
+++-        log(**stats)
+++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
+++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++-        log(
+++-            n_veh_step_mean=n_veh.mean(), 
+++-            n_veh_step_sum=n_veh.sum(), 
+++-            n_veh_unique=len(id_unique),
+++-            
+++-            reward_mean=np.mean(reward),
+++-            reward_std=np.std(reward),        
+++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++-            ssm_mean=np.mean(rollout.ssm),
+++-            ssm_std=np.std(rollout.ssm),
+++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++-
+++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++-            # nom_action = np.mean(rollout.nom_action),
+++-            # res_action = np.mean(rollout.res_action),
+++-            )
+++-        
+++-        return rollout
+++-
+++-if __name__ == '__main__':
+++-    c = Intersection.from_args(globals(), locals())
+++-    c.setdefaults(
+++-        n_steps=200,
+++-        step_save=5,
+++-
+++-        depart_speed=0,
+++-        max_speed=13,
+++-        max_dist=100,
+++-        max_accel=1.5,
+++-        max_decel=3.5,
+++-        sim_step=0.5,
+++-        generic_type=True,
+++-        n_actions=3,
+++-
+++-        adv_norm=False,
+++-        batch_concat=True,
+++-
+++-        render=False,
+++-
+++-        warmup_steps=100,
+++-        horizon=2000,
+++-        directions='4way',
+++-        av_frac=0.15,
+++-        handcraft=False,
+++-        handcraft_tl=None,
+++-        flow_rate=700,
+++-        length=100,
+++-        n_rows=1,
+++-        n_cols=1,
+++-        speed_mode=SPEED_MODE.obey_safe_speed,
+++-
+++-        act_type='accel_discrete',
+++-        low=-1,
+++-
+++-        alg=PG,
+++-        n_gds=1,
+++-        lr=1e-3,
+++-        gamma=0.99,
+++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++-
+++-        enter_length=False,
+++-        short_exit=False,
+++-
+++-        rew_type='outflow',
+++-        norm_reward=True,
+++-        center_reward=True,
+++-        multi_flowrate=False,
+++-        opt='RMSprop',
+++-
+++-        obs_tail=True,
+++-        obs_next_cross_platoons=1,
+++-
+++-        beta=0,
+++-        scale_pet=1,
+++-        scale_drac=1,
+++-        seed_np=False,
+++-        seed_torch = False,
+++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++-        mrtl=False, # this flag deals with adding beta to observation vector
+++-    )
+++-
+++-    if c.seed_torch:
+++-        # Set seed for PyTorch CPU operations
+++-        torch.manual_seed(c.seed_torch)
+++-        # Set seed for PyTorch CUDA operations (if available)
+++-        if torch.cuda.is_available():
+++-            torch.cuda.manual_seed_all(c.seed_torch)
+++-    if c.seed_np:
+++-        np.random.seed(c.seed_np)
+++-
+++-    if c.directions == '4way':
+++-        c.directions = ['up', 'right', 'down', 'left']
+++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
+++-    if c.mrtl:
+++-        c._n_obs += 1
+++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
+++-    c.redef_sumo = 'length_range' in c
+++-    c.run()
+++\ No newline at end of file
+++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++index d4c3dac..4541fa7 100644
+++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++@@ -1,600 +1,20234 @@
+++-diff --git a/README.md b/README.md
+++-index b591747..127f484 100644
+++---- a/README.md
+++-+++ b/README.md
+++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
+++- ### 1.2 Set the environmental variables
+++- ```
+++- # Code directory
+++--export F=automatic_vehicular_control/automatic_vehicular_control
+++-+export F=automatic_vehicular_control
+++- 
+++- # Results directory extracted from the zip file
+++- export R=results
+++-@@ -48,10 +48,8 @@ export R=results
+++- ## 2. Directory Structure
+++- 
+++- The code directory structure is
+++--```
+++-+``` 
+++- automatic_vehicular_control/
+++--│
+++--├── automatic_vehicular_control/
+++- │   ├── __pycache__/                # Compiled Python files
+++- │   ├── evaluations/                # Evaluation results and metrics
+++- │   ├── models/                     # Model checkpoints
+++ diff --git a/env.py b/env.py
+++-index 4ab3d95..c83a674 100644
++++index c83a674..3ef7822 100644
+++ --- a/env.py
+++ +++ b/env.py
+++-@@ -724,9 +724,11 @@ class TrafficState:
+++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
+++- 
+++-         segments = {}
+++-+        
+++-         def add_from_to(from_, to):
+++-             from_.tos.add(to)
+++-             to.froms.add(from_)
+++-+            
+++-         for con in map(values_str_to_val, net.children('connection')):
+++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
+++-             to_lane = edges[con.to].lanes[int(con.toLane)]
+++-@@ -888,89 +890,109 @@ class TrafficState:
+++- 
+++-     def step(self):
+++-         """
+++--        Take a simulation step and update state
+++-+        Take a simulation step and update state.
+++-         """
+++--        c = self.c
+++--        tc = self.tc
+++--        subscribes = self.subscribes
+++-+        c = self.c  # Configuration object for the simulation
+++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
+++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
+++- 
+++-         # Actual SUMO step
+++--        tc.simulationStep()
+++--        sim_res = subscribes.sim.get()
+++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
+++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
+++- 
+++-+        # Clear references to current vehicle edges and lanes for the next update
+++-         for veh in self.vehicles:
+++--            veh.unvar('edge', 'lane')
+++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
+++-+
+++-+        # Clear current vehicle data from edges and lanes
+++-         for ent in itertools.chain(self.edges, self.lanes):
+++--            ent.vehicles.clear()
+++--            ent.positions.clear()
+++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
+++-+            ent.positions.clear()  # Clear vehicle positions
+++- 
+++-+        # Update traffic light states
+++-         for tl_id, tl in self.traffic_lights.items():
+++--            tl.update(subscribes.tl.get(tl_id))
+++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
+++- 
+++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
+++-         for veh_id in sim_res.loaded_vehicles_ids:
+++--            flow_id, _ = veh_id.rsplit('.')
+++--            flow = self.flows[flow_id]
+++--            flow.backlog.add(veh_id)
+++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
+++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
+++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
+++- 
+++-+        # Initialize a set for newly departed vehicles
+++-         self.new_departed = set()
+++-+
+++-+        # Handle vehicles that have departed (entered the network)
+++-         for veh_id in sim_res.departed_vehicles_ids:
+++--            subscribes.veh.subscribe(veh_id)
+++--            type_id = tc.vehicle.getTypeID(veh_id)
+++--            # import pdb; pdb.set_trace()
+++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
+++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
+++-+            # If vehicle type is 'generic', compute specific type
+++-             if type_id == 'generic':
+++-                 type_id = self.compute_type(veh_id)
+++--            type_ = self.types[type_id]
+++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
+++--            length = tc.vehicle.getLength(veh_id)
+++--            road_id = tc.vehicle.getRoadID(veh_id)
+++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
+++--            type_.vehicles.add(veh)
+++-+            type_ = self.types[type_id]  # Get vehicle type object
+++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
+++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
+++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
+++-+
+++-+            # Create a new vehicle object and add it to the list of vehicles
+++-+            self.vehicles[veh_id] = veh = Vehicle(
+++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
+++-+            )
+++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
+++- 
+++-+            # Set color if rendering is enabled
+++-             if c.render:
+++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
+++--                self.set_color(veh, color_fn(veh))
+++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
+++- 
+++-+            # Set vehicle speed mode and lane change mode using SUMO settings
+++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
+++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
+++-+
+++-+            # Add to new_departed set
+++-             self.new_departed.add(veh)
+++-+
+++-+            # Remove vehicle from backlog if necessary
+++-             if '.' in veh_id:
+++-                 flow_id, _ = veh_id.rsplit('.')
+++-                 if flow_id in self.flows:
+++-                     flow = self.flows[flow_id]
+++-                     flow.backlog.remove(veh_id)
+++- 
+++-+        # Handle newly arrived and collided vehicles
+++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
+++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+++-+        
+++-+        # Remove newly arrived vehicles from tracking if they collided
+++-         for veh in self.new_arrived:
+++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
+++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
+++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
+++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
+++- 
+++-+        # Update vehicle positions on edges and lanes
+++-         for veh_id, veh in self.vehicles.items():
+++--            veh.prev_speed = veh.get('speed', None)
+++--            veh.update(subscribes.veh.get(veh_id))
+++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
+++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
+++-             if veh_id not in sim_res.colliding_vehicles_ids:
+++--                edge = self.edges[veh.road_id]
+++--                edge.vehicles.append(veh)
+++--                veh.edge = edge
+++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
+++--            # edge = self.edges[veh.road_id]
+++--            # edge.vehicles.append(veh)
+++--            # veh.edge = edge
+++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
+++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
+++-+                veh.edge = edge  # Set vehicle's edge attribute
+++- 
+++-+        # Update vehicle sorting and lane positions
+++-         for edge in self.edges:
+++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
+++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
+++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
+++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
+++-             for edge_i, veh in enumerate(edge.vehicles):
+++--                veh.edge_i = edge_i
+++--                veh.lane = lane = edge.lanes[veh.lane_index]
+++--                veh.lane_i = len(lane.vehicles)
+++--                lane.vehicles.append(veh)
+++--                lane.positions.append(veh.laneposition)
+++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
+++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
+++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
+++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
+++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
+++- 
+++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
+++-         self.all_arrived.append(self.new_arrived)
+++-         self.all_departed.append(self.new_departed)
+++-         self.all_collided.append(self.new_collided)
+++--
+++-+            
+++-     def reset(self, tc):
+++-         self.tc = tc
+++-         self.subscribes.clear()
+++-@@ -1043,6 +1065,7 @@ class Env:
+++-     """
+++-     Offers a similar reinforcement learning environment interface as gym.Env
+++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
+++-+    c: Ring class
+++-     """
+++-     def __init__(self, c):
+++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
+++-@@ -1056,6 +1079,7 @@ class Env:
+++-             if c.get('save_agent'):
+++-                 self._agent_info = []
+++-         self._step = 0
+++-+        self.mean_speed = 0
+++- 
+++-     def def_sumo(self, *args, **kwargs):
+++-         """ Override this with code defining the SUMO network """
+++-@@ -1094,49 +1118,91 @@ class Env:
+++-         """
+++-         return True
+++- 
+++-+   # Method to reset or initialize the SUMO traffic simulation environment
+++-     def reset_sumo(self):
+++-+        # Shortcuts for configuration and SUMO definition objects
+++-         c = self.c
+++-         sumo_def = self.sumo_def
+++--
+++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+++-+        
+++-+        # Determine if new SUMO definitions need to be generated
+++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
+++-+        
+++-         if generate_def:
+++--            kwargs = self.def_sumo()
+++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
+++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
+++-+            # Generate new definitions if necessary
+++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
+++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
+++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++++@@ -852,12 +852,15 @@ class TrafficState:
++++         subscribes.sim = SubscribeDef(tc.simulation, [
++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
+++ +        
+++-+        # Start SUMO with the current traffic controller (tc)
+++-         self.tc = sumo_def.start_sumo(self.tc)
++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
++++             TL.red_yellow_green_state])
+++ +        
+++-         if generate_def:
+++-+            # If new definitions were generated, store relevant SUMO file paths
+++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
+++-+            
+++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
+++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
+++--            self.ts = TrafficState(c, self.tc, **defs)
+++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
+++-         else:
+++-+            # If not generating new definitions, simply reset the existing traffic state
+++-             self.ts.reset(self.tc)
++++         subscribes.veh = SubscribeDef(tc.vehicle, [
++++             V.road_id, V.lane_index, V.laneposition,
++++             V.speed, V.position, V.angle,
++++             V.fuelconsumption, V.noxemission])
+++ +        
+++-+        # Set up the traffic state (e.g., initialize the simulation settings)
+++-         self.ts.setup()
+++-+        
+++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+++-         success = self.init_vehicles()
+++-+        
+++-+        # Return whether the SUMO reset and vehicle initialization were successful
+++-         return success
++++         for tl_id in self.traffic_lights.keys():
++++             subscribes.tl.subscribe(tl_id)
+++  
+++-+    # Method to initialize the environment after SUMO reset
+++-     def init_env(self):
+++-+        # Reference to the traffic state
+++-         ts = self.ts
+++-+    
+++-+        # Create an empty data structure to store rollout information
+++-         self.rollout_info = NamedArrays()
+++-+        
+++-+        # Turn off all traffic lights in the network
+++-         for tl in ts.traffic_lights:
+++--            ts.set_program(tl, 'off')
+++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
+++-+        
+++-+        # Reset the step counter to 0
+++-         self._step = 0
+++-+        
+++-+        # Take the first step in the simulation
+++-         ret = self.step()
+++-+        
+++-+        # Run the simulation for a number of warmup steps
+++-         for _ in range(self.c.warmup_steps):
+++--            ret = self.step()
+++-+            ret = self.step()  # Advance the simulation one step
+++-+            
+++-+            # If the simulation ends during the warmup phase, return None to indicate failure
+++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
+++-                 return None
+++-+        
+++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
+++-         for tl in ts.traffic_lights:
+++--            ts.set_program(tl, '1')
+++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
+++-+        
+++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
+++-         if isinstance(ret, tuple):
+++--            return ret[0]
+++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
+++--
+++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
+++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
+++-+        
+++-+    # Reset the entire environment, retrying until successful
+++-     def reset(self):
+++--        while True:
+++-+        self.mean_speed = 0
+++-+        while True:  # Infinite loop until the environment is successfully reset
+++-+            # Attempt to reset the SUMO simulation
++++@@ -1197,6 +1200,7 @@ class Env:
++++         while True:  # Infinite loop until the environment is successfully reset
++++             # Attempt to reset the SUMO simulation
+++              if not self.reset_sumo():
+++--                continue
+++-+                continue  # If reset_sumo fails, retry the loop
+++-+            
+++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++-             if (obs := self.init_env()) is not None:
+++--                return obs
+++-+                return obs  # Successfully initialized, return the observation
+++-+
+++- 
+++-     def append_step_info(self):
+++-         """
+++-@@ -1231,6 +1297,8 @@ class Env:
+++- class NormEnv(gym.Env):
+++-     """
+++-     Reward normalization with running average https://github.com/joschu/modular_rl
+++-+    self.c: Ring parameters 
+++-+    self.env: RingEnv class
+++-     """
+++-     def __init__(self, c, env):
+++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
+++++                
++++                 continue  # If reset_sumo fails, retry the loop
++++             
++++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++ diff --git a/exp.py b/exp.py
+++-index ead4652..7f7cee5 100644
++++index 7f7cee5..6f16d66 100644
+++ --- a/exp.py
+++ +++ b/exp.py
+++-@@ -169,9 +169,9 @@ class Main(Config):
+++- 
+++-     def on_train_start(c):
+++-         # Initialize training: environment, algorithm, model, optimizer, and logging
+++--        c.setdefaults(alg='Algorithm')
+++--        c._env = c.create_env()
+++--
+++-+        c.setdefaults(alg='Algorithm') 
+++-+        c._env = c.create_env() # Create NormEnv
+++-+ 
+++-         # Instantiate the algorithm (e.g., PPO, DQN)
+++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
+++-         c.set_model()
+++-@@ -222,8 +222,8 @@ class Main(Config):
+++- 
+++-     def on_step_start(c, stats={}):
+++-         # Update the learning rate and log stats at the start of a training step
+++--        lr = c._lr
+++--        for g in c._opt.param_groups:
+++-+        lr = c._lr # Update Learning Rate
+++-+        for g in c._opt.param_groups: # Log Statistics
+++-             g['lr'] = float(lr)
+++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
+++- 
+++-@@ -285,10 +285,14 @@ class Main(Config):
++++@@ -285,7 +285,6 @@ class Main(Config):
+++              ret = dict(obs=ret)
+++          rollout = NamedArrays()
+++          rollout.append(**ret)
+++--
+++-+        rollout_flow_each_step = []
++++-        rollout_flow_each_step = []
+++          done = False
+++          a_space = c.action_space
+++          step = 0
++++@@ -406,9 +405,8 @@ class Main(Config):
++++ 
++++     def train(c):
++++         # Main training loop
++++-        c.on_train_start()
+++++        c.on_train_start() # Ring Env
++++         while c._i < c.n_steps:
++++-            c.on_step_start() # save stat 
++++             with torch.no_grad():
++++                 # Collect rollouts without computing gradients
++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++@@ -497,3 +495,32 @@ class Main(Config):
++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
++++             c.train()
++++         c.log('job done!')
+++++
+++++    def run_2(c):
+++++        # Determine whether to train or evaluate based on configuration
+++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
+++++        
+++++        c.on_train_start()
+++++        c._env = c.create_env() # Create NormEnv
+++++        ret = c._env.reset()
+++++        c.set_model()
+++++        step = 0
+++ +        density = 20/(250*1e-3)
+++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
+++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+++-+
+++-         while step < c.horizon + c.skip_stat_steps and not done:
+++-             # Generate an action from the model's policy
+++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
+++-@@ -309,6 +313,12 @@ class Main(Config):
+++-             rollout.append(**ret)
+++-             step += 1
+++-         # Collect stats from the environment
+++++        done = False
+++++        while step < c.horizon + c.skip_stat_steps and not done:
+++++            # Take a step in the environment
+++++            ret = c._env.step()
+++++            if isinstance(ret, tuple):
+++++                obs, reward, done, info = ret
+++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
+++++            done = ret.setdefault('done', False)
+++++            step += 1
+++++        # Collect stats from the environment
+++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+++ +        density = 20/(250 * 1e-3)
+++ +        vehicle_flow = c._env.mean_speed * density 
+++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+++-+
+++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
+++-         return rollout, stats
+++- 
+++-@@ -398,10 +408,10 @@ class Main(Config):
+++-         # Main training loop
+++-         c.on_train_start()
+++-         while c._i < c.n_steps:
+++--            c.on_step_start()
+++-+            c.on_step_start() # save stat 
+++-             with torch.no_grad():
+++-                 # Collect rollouts without computing gradients
+++--                rollouts = c.rollouts()
+++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++-             gd_stats = {}
+++-             if len(rollouts.obs):
+++-                 t_start = time()
+++-@@ -410,7 +420,7 @@ class Main(Config):
+++-                 gd_stats.update(gd_time=time() - t_start)
+++-             c.on_step_end(gd_stats)
+++-             c._i += 1
+++--        c.on_step_start()  # last step
+++-+        c.on_step_start()  # save stat
+++-         gd_stats = {}
+++-         with torch.no_grad():
+++-             rollouts = c.rollouts()
+++-@@ -450,6 +460,8 @@ class Main(Config):
+++-         if hasattr(c._env, 'close'):
+++-             c._env.close()
+++- 
++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
++++deleted file mode 100644
++++index 6b9ba52..0000000
++++--- a/highway_bottleneck.py
+++++++ /dev/null
++++@@ -1,381 +0,0 @@
++++-from automatic_vehicular_control.exp import *
++++-from automatic_vehicular_control.env import *
++++-from automatic_vehicular_control.u import *
++++-
++++-class BNeckEnv(Env):
++++-    def def_sumo(self):
++++-        c = self.c
++++-        nodes = E('nodes',
++++-            E('node', id='n_0', x=0, y=0), *(
++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
++++-        ))
++++-        edges = E('edges', *(
++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
++++-                'numLanes': n_lane,
++++-                'speed': c.max_speed
++++-            }) for i, n_lane in enumerate(c.n_lanes)
++++-        ))
++++-        connections = E('connections', *(
++++-            E('connection', **{
++++-                'from': prev.id,
++++-                'to': curr.id,
++++-                'fromLane': i,
++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
++++-        ))
++++-
++++-        if c.split_flow:
++++-            n_inflow_lanes = c.n_lanes[0]
++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
++++-                for i in range(n_inflow_lanes)
++++-            ]
++++-        else:
++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
++++-            ]
++++-        routes = E('routes',
++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
++++-            *flows
++++-        )
++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
++++-        additional = E('additional',
++++-            E('vType', id='generic', **idm_params),
++++-            E('vType', id='rl', **idm_params),
++++-            E('vType', id='human', **idm_params),
++++-        )
++++-        sumo_args = {'collision.action': COLLISION.remove}
++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++-
++++-    def reset_sumo(self):
++++-        c = self.c
++++-        if c.flow_rate_range:
++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
++++-        ret = super().reset_sumo()
++++-        if c.vinitsky:
++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
++++-                for i_start in range(round(edge.length) // c.piece_length)
++++-                for lane in edge.lanes
++++-            ]
++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
++++-            self.last_outflows = []
++++-        return ret
++++-
++++-    def step(self, action=[]):
++++-        c = self.c
++++-        ts = self.ts
++++-        max_dist = 100
++++-        max_speed = c.max_speed
++++-        human_type = ts.types.human
++++-        rl_type = ts.types.rl
++++-
++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++-        if c.vinitsky:
++++-            if len(action):
++++-                assert len(action) == len(self.control_lanes)
++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
++++-                    self.control_lanes[lane, piece_start] = np.clip(
++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
++++-                        0.1, max_speed
++++-                    )
++++-                for veh in prev_rls:
++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
++++-        else:
++++-            for veh, act in zip(prev_rls, action):
++++-                if c.handcraft:
++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
++++-                    next_lane = lane.next(veh.route)
++++-                    level = 1
++++-                    if next_lane and next_lane.get('junction'):
++++-                        merge_dist = lane.length - veh.laneposition
++++-                        if merge_dist < c.handcraft:
++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
++++-                                level = 0
++++-                    if c.act_type.startswith('accel'):
++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++-                    else:
++++-                        ts.set_max_speed(veh, max_speed * level)
++++-                    continue
++++-                if not isinstance(act, (int, np.integer)):
++++-                    act = (act - c.low) / (1 - c.low)
++++-                if c.act_type.startswith('accel'):
++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++-                else:
++++-                    if c.act_type == 'continuous':
++++-                        level = act[0]
++++-                    elif c.act_type == 'discretize':
++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++-                    elif c.act_type == 'discrete':
++++-                        level = act / (c.n_actions - 1)
++++-                    ts.set_max_speed(veh, max_speed * level)
++++-
++++-                if c.lc_av == 'binary' and act[1] > 0.5:
++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
++++-
++++-        super().step()
++++-
++++-        if c.vinitsky:
++++-            n_last_outflows = 20
++++-            max_vehs = 4
++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
++++-            obs = []
++++-            for lane, piece_start in self.obs_lanes:
++++-                piece_end = piece_start + c.piece_length
++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
++++-                obs.extend([
++++-                    len(lane_humans) / max_vehs,
++++-                    len(lane_avs) / max_vehs,
++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
++++-                ])
++++-            if len(self.last_outflows) == n_last_outflows:
++++-                self.last_outflows = self.last_outflows[1:]
++++-            self.last_outflows.append(len(ts.new_arrived))
++++-            reward = np.mean(self.last_outflows)
++++-            obs.append(reward / max_veh_outflows)
++++-            obs = np.array(obs, dtype=np.float32)
++++-            assert 0 <= obs.min() and obs.max() <= 1
++++-            return obs, reward, False, None
++++-        route = nexti(ts.routes)
++++-        obs, ids = [], []
++++-        default_close = [0, max_speed]
++++-        default_far = [max_dist, 0]
++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
++++-            merge_dist = max_dist
++++-            default_human = default_far
++++-
++++-            other_info = {}
++++-            next_lane = lane.next(veh.route)
++++-            if next_lane and next_lane.get('junction'):
++++-                merge_dist = lane.length - veh.laneposition
++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
++++-                # Look for veh on other lane but do not extend past that lane
++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
++++-                    if other_veh.type is rl_type:
++++-                        default_human = default_close
++++-                        break
++++-
++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
++++-            ids.append(veh.id)
++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++-        
++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++-
++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++-        ttc = np.clip(ttc/7, -1, 1)
++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++-        drac = np.clip(drac/10, -1, 1)
++++-
++++-        raw_pet = self.calc_pet()
++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++-        pet = np.clip(pet, -1, 1)
++++-
++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++-        
++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++-        return returned
++++-        
++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++-    
++++-    def calc_ttc(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        ttcs = []
++++-        for v in cur_veh_list:
++++-            leader, headway = v.leader()
++++-            v_speed = v.speed
++++-            leader_speed = leader.speed
++++-            if leader_speed < v_speed:
++++-                ttc =  headway/(v_speed-leader_speed)
++++-            else:
++++-                ttc = np.nan
++++-            ttcs.append(ttc)
++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++-        return fleet_ttc
++++-    
++++-    def calc_drac(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        dracs = []
++++-        for v in cur_veh_list:
++++-            leader, headway = v.leader()
++++-            v_speed = v.speed
++++-            leader_speed = leader.speed
++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
++++-            dracs.append(drac)
++++-        fleet_drac = np.nanmean(np.array(dracs))
++++-        return fleet_drac
++++-
++++-    def calc_pet(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        pets = []
++++-        for v in cur_veh_list:
++++-            leader, headway = v.leader()
++++-            v_speed = v.speed
++++-            if v_speed > 1e-16:
++++-                pet = headway/(v_speed)
++++-                pets.append(pet)
++++-        fleet_pet = np.nanmean(np.array(pets))
++++-        return fleet_pet
++++-
++++-class BNeck(Main):
++++-    def create_env(c):
++++-        return BNeckEnv(c)
++++-
++++-    @property
++++-    def observation_space(c):
++++-        low = np.full(c._n_obs, c.low)
++++-        return Box(low, np.ones_like(low))
++++-
++++-    @property
++++-    def action_space(c):
++++-        if c.vinitsky:
++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++-            assert c.lc_av in [False, 'binary']
++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++-            return Discrete(c.n_actions)
++++-
++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++-        if c.vinitsky:
++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
++++-        log = c.get_log_ii(ii, n_ii)
++++-        step_obs_ = rollout.obs
++++-        step_obs = step_obs_[:-1]
++++-
++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++-
++++-        n_veh = np.array([len(o) for o in step_obs])
++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++-        rollout.update(obs=step_obs, ret=step_ret)
++++-
++++-        step_id_ = rollout.pop('id')
++++-        id = np.concatenate(step_id_[:-1])
++++-        id_unique = np.unique(id)
++++-
++++-        reward = np.array(rollout.pop('reward'))
++++-
++++-        log(**stats)
++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++-        log(
++++-            n_veh_step_mean=n_veh.mean(), 
++++-            n_veh_step_sum=n_veh.sum(), 
++++-            n_veh_unique=len(id_unique),
++++-            
++++-            reward_mean=np.mean(reward),
++++-            reward_std=np.std(reward),        
++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++-            ssm_mean=np.mean(rollout.ssm),
++++-            ssm_std=np.std(rollout.ssm),
++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++-
++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++-            # nom_action = np.mean(rollout.nom_action),
++++-            # res_action = np.mean(rollout.res_action),
++++-            )
++++-        return rollout
++++-
++++-if __name__ == '__main__':
++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
++++-        warmup_steps=1000,
++++-        horizon=2000,
++++-        n_steps=100,
++++-        step_save=5,
++++-
++++-        av_frac=0.2,
++++-        sim_step=0.5,
++++-        depart_speed=0,
++++-        edge_lengths=[100, 100, 50],
++++-        n_lanes=[4, 2, 1],
++++-        max_speed=30,
++++-
++++-        lc_av=False,
++++-        flow_rate=2300,
++++-        flow_rate_range=None,
++++-        split_flow=True,
++++-        generic_type='rand',
++++-        speed_mode=SPEED_MODE.all_checks,
++++-        lc_mode=LC_MODE.off,
++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++-
++++-        veh_junction=False,
++++-        act_type='accel_discrete',
++++-        max_accel=2.6,
++++-        max_decel=4.5,
++++-        tau=1.0,
++++-        min_gap=2.5,
++++-        delta=4,
++++-        n_actions=3,
++++-        low=-1,
++++-        handcraft=False,
++++-        vinitsky=False,
++++-
++++-        render=False,
++++-
++++-        alg=PG,
++++-        lr=1e-3,
++++-
++++-        gamma=0.99,
++++-        adv_norm=False,
++++-        batch_concat=True,
++++-
++++-        beta=0,
++++-        scale_ttc=1,
++++-        scale_drac=1,
++++-        seed_np=False,
++++-        seed_torch = False,
++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++-
++++-    )
++++-    
++++-    if c.seed_torch:
++++-        # Set seed for PyTorch CPU operations
++++-        torch.manual_seed(c.seed_torch)
++++-        # Set seed for PyTorch CUDA operations (if available)
++++-        if torch.cuda.is_available():
++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++-    if c.seed_np:
++++-        np.random.seed(c.seed_np)
++++-        
++++-    if c.vinitsky:
++++-        c.piece_length = 20
++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
++++-        c._n_action = sum(n_actions[:-1])
++++-        c._n_obs = sum(n_actions) * 4 + 1
++++-        c.batch_concat = False
++++-    else:
++++-        c._n_obs = 2 + 2 + 2
++++-        
++++-    if c.mrtl:
++++-        c._n_obs += 1 # modified for mrtl related
++++-        
++++-    c.redef_sumo = bool(c.flow_rate_range)
++++-    c.run()
++++\ No newline at end of file
++++diff --git a/highway_ramp.py b/highway_ramp.py
++++deleted file mode 100644
++++index ef0358f..0000000
++++--- a/highway_ramp.py
+++++++ /dev/null
++++@@ -1,325 +0,0 @@
++++-from automatic_vehicular_control.exp import *
++++-from automatic_vehicular_control.env import *
++++-from automatic_vehicular_control.u import *
++++-
++++-class RampEnv(Env):
++++-    # https://flow-project.github.io/papers/08569485.pdf
++++-    def def_sumo(self):
++++-        c = self.c
++++-        builder = NetBuilder()
++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
++++-            (0, 0),
++++-            (c.premerge_distance, 0),
++++-            (c.premerge_distance + c.merge_distance, 0),
++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
++++-        ])
++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
++++-            {}, {'numLanes': 2}, {}
++++-        ], lane_maps=[
++++-            {0: 1}, {0: 0, 1: 0}
++++-        ], route_id='highway')
++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
++++-            {}, {'numLanes': 2}, {}
++++-        ], lane_maps=[
++++-            {0: 0}, {0: 0, 1: 0}
++++-        ], route_id='ramp')
++++-        nodes, edges, connections, routes = builder.build()
++++-        nodes[2].type = 'zipper'
++++-
++++-        routes = E('routes',
++++-            *routes,
++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
++++-        )
++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
++++-        additional = E('additional',
++++-            E('vType', id='generic', **idm),
++++-            E('vType', id='rl', **idm),
++++-            E('vType', id='human', **idm),
++++-        )
++++-        sumo_args = {'collision.action': COLLISION.remove}
++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++-
++++-    def step(self, action=[]):
++++-        c = self.c
++++-        ts = self.ts
++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
++++-        max_speed = c.max_speed
++++-        human_type = ts.types.human
++++-        rl_type = ts.types.rl
++++-
++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++-        for rl, act in zip(prev_rls, action):
++++-            if c.handcraft:
++++-                route, edge, lane = rl.route, rl.edge, rl.lane
++++-                leader, dist = rl.leader()
++++-                level = 1
++++-                if edge.id == 'e_n_0.0_n_400.0':
++++-                    if rl.laneposition < 100:
++++-                        leaders = list(rl.leaders())
++++-                        if len(leaders) > 20:
++++-                            level = 0
++++-                        else:
++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++-                continue
++++-            if not isinstance(act, (int, np.integer)):
++++-                act = (act - c.low) / (1 - c.low)
++++-            if c.act_type.startswith('accel'):
++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++-            else:
++++-                if c.act_type == 'continuous':
++++-                    level = act[0]
++++-                elif c.act_type == 'discretize':
++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++-                elif c.act_type == 'discrete':
++++-                    level = act / (c.n_actions - 1)
++++-                ts.set_max_speed(rl, max_speed * level)
++++-
++++-        super().step()
++++-
++++-        route = ts.routes.highway
++++-        obs, ids = [], []
++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++-            if hasattr(veh, 'edge'):
++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
++++-                merge_dist = max_dist
++++-
++++-                lead_speed = follow_speed = other_speed = 0
++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
++++-
++++-                leader, dist = veh.leader()
++++-                if leader: lead_speed, lead_dist = leader.speed, dist
++++-
++++-                follower, dist = veh.follower()
++++-                if follower: follow_speed, follow_dist = follower.speed, dist
++++-
++++-                if c.global_obs:
++++-                    jun_edge = edge.next(route)
++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
++++-                        jun_edge = jun_edge.next(route)
++++-                    if jun_edge:
++++-                        merge_dist = lane.length - veh.laneposition
++++-                        next_edge = edge.next(route)
++++-                        while next_edge is not jun_edge:
++++-                            merge_dist += next_edge.length
++++-                            next_edge = next_edge.next(route)
++++-
++++-                        other_lane = jun_edge.lanes[0]
++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
++++-                            other_speed = other_veh.speed
++++-                            break
++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
++++-                else:
++++-                    next_lane = lane.next(route)
++++-                    if next_lane and next_lane.get('junction'):
++++-                        if len(edge.lanes) == 2:
++++-                            other_lane = edge.lanes[0]
++++-                            pos = veh.laneposition
++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
++++-                                other_speed = other_veh.speed
++++-                                break
++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
++++-                ids.append(veh.id)
++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
++++-        if c.mrtl:
++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++-        
++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++-
++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++-        ttc = np.clip(ttc/7, -1, 1)
++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++-        drac = np.clip(drac/10, -1, 1)
++++-
++++-        raw_pet = self.calc_pet()
++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++-        pet = np.clip(pet, -1, 1)
++++-
++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++-        
++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++-        return returned
++++-        
++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++-    
++++-    def calc_ttc(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        ttcs = []
++++-        for v in cur_veh_list:
++++-            if hasattr(v, 'edge'):
++++-                leader, headway = v.leader()
++++-                if leader:
++++-                    v_speed = v.speed
++++-                    leader_speed = leader.speed
++++-                    if leader_speed < v_speed:
++++-                        ttc =  headway/(v_speed-leader_speed)
++++-                    else:
++++-                        ttc = np.nan
++++-                    ttcs.append(ttc)
++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++-        return fleet_ttc
++++-    
++++-    def calc_drac(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        dracs = []
++++-        for v in cur_veh_list:
++++-            if hasattr(v, 'edge'):
++++-                leader, headway = v.leader()
++++-                if leader:
++++-                    v_speed = v.speed
++++-                    leader_speed = leader.speed
++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
++++-                    dracs.append(drac)
++++-        fleet_drac = np.nanmean(np.array(dracs))
++++-        return fleet_drac
++++-
++++-    def calc_pet(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        pets = []
++++-        for v in cur_veh_list:
++++-            if hasattr(v, 'edge'):
++++-                leader, headway = v.leader()
++++-                if leader:
++++-                    v_speed = v.speed
++++-                    if v_speed > 1e-16:
++++-                        pet = headway/(v_speed)
++++-                        pets.append(pet)
++++-        fleet_pet = np.nanmean(np.array(pets))
++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
++++-        return fleet_pet
++++-
++++-class Ramp(Main):
++++-    def create_env(c):
++++-        return RampEnv(c)
++++-
++++-    @property
++++-    def observation_space(c):
++++-        low = np.full(c._n_obs, c.low)
++++-        return Box(low, np.ones_like(low))
++++-
++++-    @property
++++-    def action_space(c):
++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++-            return Discrete(c.n_actions)
++++-
++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++-        log = c.get_log_ii(ii, n_ii)
++++-        step_obs_ = rollout.obs
++++-        step_obs = step_obs_[:-1]
++++-
++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++-
++++-        n_veh = np.array([len(o) for o in step_obs])
++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++-        rollout.update(obs=step_obs, ret=step_ret)
++++-
++++-        step_id_ = rollout.pop('id')
++++-        id = np.concatenate(step_id_[:-1])
++++-        id_unique = np.unique(id)
++++-
++++-        reward = np.array(rollout.pop('reward'))
++++-
++++-        log(**stats)
++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++-        log(
++++-            n_veh_step_mean=n_veh.mean(), 
++++-            n_veh_step_sum=n_veh.sum(), 
++++-            n_veh_unique=len(id_unique),
++++-            
++++-            reward_mean=np.mean(reward),
++++-            reward_std=np.std(reward),        
++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++-            ssm_mean=np.mean(rollout.ssm),
++++-            ssm_std=np.std(rollout.ssm),
++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++-
++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++-            # nom_action = np.mean(rollout.nom_action),
++++-            # res_action = np.mean(rollout.res_action),
++++-            )
++++-        return rollout
++++-
++++-if __name__ == '__main__':
++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
++++-        warmup_steps=100,
++++-        horizon=2000,
++++-        n_steps=100,
++++-        step_save=5,
++++-
++++-        premerge_distance=400,
++++-        merge_distance=100,
++++-        postmerge_distance=30,
++++-        av_frac=0.1,
++++-        sim_step=0.5,
++++-        max_speed=30,
++++-        highway_depart_speed=10,
++++-        ramp_depart_speed=0,
++++-        highway_flow_rate=2000,
++++-        ramp_flow_rate=300,
++++-        global_obs=False,
++++-        handcraft=False,
++++-
++++-        generic_type='default',
++++-        speed_mode=SPEED_MODE.all_checks,
++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++-
++++-        act_type='accel_discrete',
++++-        max_accel=1,
++++-        max_decel=1.5,
++++-        n_actions=3,
++++-        low=-1,
++++-
++++-        render=False,
++++-
++++-        alg=PG,
++++-        lr=1e-3,
++++-
++++-        gamma=0.99,
++++-        adv_norm=False,
++++-        batch_concat=True,
++++-
++++-        beta=0,
++++-        scale_ttc=1,
++++-        scale_drac=1,
++++-        seed_np=False,
++++-        seed_torch = False,
++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++-
++++-    )
++++-    
++++-    if c.seed_torch:
++++-        # Set seed for PyTorch CPU operations
++++-        torch.manual_seed(c.seed_torch)
++++-        # Set seed for PyTorch CUDA operations (if available)
++++-        if torch.cuda.is_available():
++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++-    if c.seed_np:
++++-        np.random.seed(c.seed_np)
++++-        
++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
++++-    if c.mrtl:
++++-        c._n_obs += 1 # modified for mrtl related
++++-    c.run()
++++\ No newline at end of file
++++diff --git a/intersection.py b/intersection.py
++++deleted file mode 100644
++++index e38a84f..0000000
++++--- a/intersection.py
+++++++ /dev/null
++++@@ -1,489 +0,0 @@
++++-from automatic_vehicular_control.u import *
++++-from automatic_vehicular_control.exp import *
++++-from automatic_vehicular_control.env import *
++++-
++++-class Platoon(Entity):
++++-    pass
++++-
++++-class IntersectionEnv(Env):
++++-    def def_sumo(self):
++++-        c = self.c
++++-
++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
++++-        ] if params.get('vehsPerHour')]
++++-
++++-        builder = NetBuilder()
++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
++++-        if c.enter_length:
++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++-            xys[1:, :, 0] += c.enter_length - c.length
++++-            xys[:, 1:, 1] += c.enter_length - c.length
++++-            xys = xys.reshape(-1, 2)
++++-        if c.short_exit:
++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++-            xys[-1, :, 0] += c.short_exit - c.length
++++-            xys[:, -1, 1] += c.short_exit - c.length
++++-            xys = xys.reshape(-1, 2)
++++-        nodes = builder.add_nodes(
++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
++++-        # import pdb; pdb.set_trace()
++++-
++++-        tl = c.setdefault('tl', False)
++++-        if tl:
++++-            c.av_frac = 0
++++-            c.pop('av_range', None)
++++-            c.speed_mode = SPEED_MODE.all_checks
++++-
++++-        flows = []
++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
++++-        for direction in c.directions:
++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
++++-
++++-            edge_attrs = dict(priority=int(direction in priority))
++++-            if c.get('set_edge_speed', True):
++++-                edge_attrs['speed'] = c.max_speed
++++-
++++-            for i, chain in enumerate(chains[1:-1]):
++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
++++-
++++-        tls = []
++++-        if tl:
++++-            tl = 1000000 if tl == 'MaxPressure' else tl
++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
++++-            tl_offset = c.get('tl_offset', 'auto')
++++-            yellow = c.get('yellow', 0.5)
++++-            if tl_offset == 'auto':
++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
++++-            elif tl_offset == 'same':
++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
++++-                node.type = 'traffic_light'
++++-                phase_multiple = len(c.directions) // 2
++++-                tls.append(E('tlLogic',
++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
++++-                id=node.id, offset=offset, type='static', programID='1'))
++++-
++++-        nodes, edges, connections, routes = builder.build()
++++-        additional = E('additional', *types, *routes, *flows, *tls)
++++-        return super().def_sumo(nodes, edges, connections, additional)
++++-
++++-    def build_platoon(self):
++++-        ts = self.ts
++++-        rl_type = ts.types.rl
++++-        for route in ts.routes:
++++-            vehs = []
++++-            route_offset = 0
++++-            for edge in route.edges:
++++-                for veh in edge.vehicles:
++++-                    veh.route_position = route_offset + veh.laneposition
++++-                    vehs.append(veh)
++++-                route_offset += edge.length
++++-
++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
++++-            rl_idxs, = rl_mask.nonzero()
++++-            split_idxs = 1 + rl_idxs
++++-
++++-            prev = None
++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
++++-                if not len(vehs_i):
++++-                    continue # Last vehicle is RL, so the last split is empty
++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
++++-                )
++++-                if prev is not None:
++++-                    prev.next = platoon
++++-                prev = platoon
++++-                for veh in vehs_i:
++++-                    veh.platoon = platoon
++++-            if prev is not None:
++++-                prev.next = None
++++-
++++-    def reset(self):
++++-        c = self.c
++++-        if c.e is False:
++++-            if 'length_range' in c:
++++-                min_, max_ = c.length_range
++++-                c.setdefaults(max_length=max_)
++++-                c.length = np.random.randint(min_, max_ + 1)
++++-            if 'av_range' in c:
++++-                min_, max_ = c.av_range
++++-                c.av_frac = np.random.uniform(min_, max_)
++++-        self.mp_tlast = 0
++++-        while not self.reset_sumo():
++++-            pass
++++-        ret = super().init_env()
++++-        return ret
++++-
++++-    def step(self, action=[]):
++++-        c = self.c
++++-        ts = self.ts
++++-        max_dist = c.max_dist
++++-        depart_speed = c.depart_speed
++++-        max_speed = c.max_speed
++++-
++++-        rl_type = ts.types.rl
++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++-
++++-        for rl, act in zip(prev_rls, action):
++++-            if c.handcraft or c.handcraft_tl:
++++-                route, lane = rl.route, rl.lane
++++-                junction = lane.next_junction
++++-                level = 1
++++-                if junction is not ts.sentinel_junction:
++++-                    dist = junction.route_position[route] - rl.route_position
++++-                    if c.handcraft:
++++-                        for cross_lane in lane.next_cross_lanes:
++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
++++-                    elif c.handcraft_tl and dist < 15:
++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
++++-                        yellow_time = 0
++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
++++-                        horizontal_go = 0 <= rem < t_h
++++-                        vertical_go = t_h + yellow_time <= rem
++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
++++-                        human_remain = False
++++-                        for cross_lane in lane.next_cross_lanes:
++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
++++-            elif c.act_type == 'accel':
++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
++++-            else:
++++-                level = act / (c.n_actions - 1)
++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++-
++++-        if c.tl == 'MaxPressure':
++++-            self.mp_tlast += c.sim_step
++++-            tmin = c.get('mp_tmin', 0)
++++-            if self.mp_tlast >= tmin:
++++-                for tl in ts.traffic_lights:
++++-                    if ts.get_program(tl) == 'off':
++++-                        break
++++-                    jun = tl.junction
++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
++++-
++++-                    total_pressures = []
++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
++++-
++++-                    ts.set_phase(tl, np.argmax(total_pressures))
++++-                self.mp_tlast = 0
++++-
++++-        super().step()
++++-        self.build_platoon()
++++-
++++-        obs = {}
++++-
++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
++++-        for veh in rl_type.vehicles:
++++-            if hasattr(veh, 'lane'):
++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
++++-                junction = lane.next_junction
++++-
++++-                head, tail = veh, platoon.tail
++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
++++-
++++-                if junction is ts.sentinel_junction:
++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
++++-                else:
++++-                    for jun_lane in lane.next_junction_lanes:
++++-                        # Defaults for jun_lane
++++-                        jun_headtails = vehs_default()
++++-
++++-                        jun_lane_route = nexti(jun_lane.from_routes)
++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
++++-
++++-                        if jun_veh:
++++-                            if jun_veh.type is rl_type:
++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
++++-                                platoon = jun_veh.platoon.prev
++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++-                                    if platoon is None: break
++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++-                                    platoon = platoon.prev
++++-                            else:
++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
++++-                                jun_headtails[0] = jun_veh.platoon.tail
++++-                                next_cross_platoon = jun_veh.platoon.prev
++++-                                if next_cross_platoon:
++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
++++-                                    platoon = next_cross_platoon.prev
++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++-                                        if platoon is None: break
++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++-                                        platoon = platoon.prev
++++-                        route_vehs.append((jun_lane_route, jun_headtails))
++++-
++++-                dist_features, speed_features = [], []
++++-                for route, vehs in route_vehs:
++++-                    j_pos = junction.route_position[route]
++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
++++-
++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++-
++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
++++-        ids = sorted(obs)
++++-        if c.mrtl:
++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
++++-        if c.rew_type == 'outflow':
++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++-        elif c.rew_type == 'time_penalty':
++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
++++-        
++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++-
++++-        raw_drac = self.calc_drac()
++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++-        drac = np.clip(drac/10, -1, 1)
++++-        raw_pet = self.calc_pet()
++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++-        pet = np.clip(pet/6, -1, 1)
++++-
++++-        raw_ttc = self.calc_ttc()
++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++-        ttc = np.clip(ttc/7, -1, 1)
++++-
++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++-
++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++-        return returned
++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++-        
++++-    def calc_drac(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        dracs = []
++++-        for v in cur_veh_list:
++++-            if hasattr(v, 'lane'):
++++-                leader, headway = v.leader()
++++-                v_speed = v.speed
++++-                leader_speed = leader.speed
++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
++++-                dracs.append(drac)
++++-        fleet_drac = np.nanmean(np.array(dracs))
++++-        return fleet_drac
++++-    
++++-    def calc_pet(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        pets = []
++++-        for v in cur_veh_list:
++++-            if hasattr(v, 'lane'):
++++-                leader, headway = v.leader()
++++-                v_speed = v.speed
++++-                if v_speed > 1e-16:
++++-                    pet = headway/(v_speed)
++++-                    pets.append(pet)
++++-        fleet_pet = np.nanmean(np.array(pets))
++++-        return fleet_pet
++++-
++++-    def calc_ttc(self):
++++-        cur_veh_list = self.ts.vehicles
++++-        ttcs = []
++++-        for v in cur_veh_list:
++++-            if hasattr(v, 'lane'):
++++-                leader, headway = v.leader()
++++-                v_speed = v.speed
++++-                leader_speed = leader.speed
++++-                if leader_speed < v_speed:
++++-                    ttc =  headway/(v_speed-leader_speed)
++++-                else:
++++-                    ttc = np.nan
++++-                ttcs.append(ttc)
++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++-        return fleet_ttc
++++-
++++-    def append_step_info(self):
++++-        super().append_step_info()
++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
++++-
++++-    @property
++++-    def stats(self):
++++-        c = self.c
++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
++++-        stats['backlog_step'] = mean(info['backlog'])
++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
++++-
++++-        stats['beta'] = c.beta
++++-
++++-        if c.multi_flowrate:
++++-            stats['flow_horizontal'] = c.flow_rate_h
++++-            stats['flow_vertical'] = c.flow_rate_v
++++-        return stats
++++-
++++-class Intersection(Main):
++++-    def create_env(c):
++++-        if c.multi_flowrate:
++++-            return NormEnv(c, IntersectionEnv(c))
++++-        else:
++++-            c._norm = NormEnv(c, None)
++++-            return IntersectionEnv(c)
++++-
++++-    @property
++++-    def observation_space(c):
++++-        low = np.full(c._n_obs, c.low)
++++-        return Box(low, np.ones_like(low))
++++-
++++-    @property
++++-    def action_space(c):
++++-        if c.act_type == 'accel':
++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++-        else:
++++-            return Discrete(c.n_actions)
++++-
++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++-        log = c.get_log_ii(ii, n_ii)
++++-        step_obs_ = rollout.obs
++++-        step_obs = step_obs_[:-1]
++++-
++++-        if not c.multi_flowrate:
++++-            rollout.raw_reward = rollout.reward
++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
++++-
++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++-
++++-        n_veh = np.array([len(o) for o in step_obs])
++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++-        rollout.update(obs=step_obs, ret=step_ret)
++++-
++++-        step_id_ = rollout.pop('id')
++++-        id = np.concatenate(step_id_[:-1])
++++-        id_unique = np.unique(id)
++++-
++++-        reward = np.array(rollout.pop('reward'))
++++-        raw_reward = np.array(rollout.pop('raw_reward'))
++++-
++++-        log(**stats)
++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++-        log(
++++-            n_veh_step_mean=n_veh.mean(), 
++++-            n_veh_step_sum=n_veh.sum(), 
++++-            n_veh_unique=len(id_unique),
++++-            
++++-            reward_mean=np.mean(reward),
++++-            reward_std=np.std(reward),        
++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++-            ssm_mean=np.mean(rollout.ssm),
++++-            ssm_std=np.std(rollout.ssm),
++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++-
++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++-            # nom_action = np.mean(rollout.nom_action),
++++-            # res_action = np.mean(rollout.res_action),
++++-            )
++++-        
++++-        return rollout
++++-
++++-if __name__ == '__main__':
++++-    c = Intersection.from_args(globals(), locals())
++++-    c.setdefaults(
++++-        n_steps=200,
++++-        step_save=5,
++++-
++++-        depart_speed=0,
++++-        max_speed=13,
++++-        max_dist=100,
++++-        max_accel=1.5,
++++-        max_decel=3.5,
++++-        sim_step=0.5,
++++-        generic_type=True,
++++-        n_actions=3,
++++-
++++-        adv_norm=False,
++++-        batch_concat=True,
++++-
++++-        render=False,
++++-
++++-        warmup_steps=100,
++++-        horizon=2000,
++++-        directions='4way',
++++-        av_frac=0.15,
++++-        handcraft=False,
++++-        handcraft_tl=None,
++++-        flow_rate=700,
++++-        length=100,
++++-        n_rows=1,
++++-        n_cols=1,
++++-        speed_mode=SPEED_MODE.obey_safe_speed,
++++-
++++-        act_type='accel_discrete',
++++-        low=-1,
++++-
++++-        alg=PG,
++++-        n_gds=1,
++++-        lr=1e-3,
++++-        gamma=0.99,
++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++-
++++-        enter_length=False,
++++-        short_exit=False,
++++-
++++-        rew_type='outflow',
++++-        norm_reward=True,
++++-        center_reward=True,
++++-        multi_flowrate=False,
++++-        opt='RMSprop',
++++-
++++-        obs_tail=True,
++++-        obs_next_cross_platoons=1,
++++-
++++-        beta=0,
++++-        scale_pet=1,
++++-        scale_drac=1,
++++-        seed_np=False,
++++-        seed_torch = False,
++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++-    )
++++-
++++-    if c.seed_torch:
++++-        # Set seed for PyTorch CPU operations
++++-        torch.manual_seed(c.seed_torch)
++++-        # Set seed for PyTorch CUDA operations (if available)
++++-        if torch.cuda.is_available():
++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++-    if c.seed_np:
++++-        np.random.seed(c.seed_np)
++++-
++++-    if c.directions == '4way':
++++-        c.directions = ['up', 'right', 'down', 'left']
++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
++++-    if c.mrtl:
++++-        c._n_obs += 1
++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
++++-    c.redef_sumo = 'length_range' in c
++++-    c.run()
++++\ No newline at end of file
++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++index d4c3dac..40c6103 100644
++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++@@ -1,600 +1,18139 @@
++++-diff --git a/README.md b/README.md
++++-index b591747..127f484 100644
++++---- a/README.md
++++-+++ b/README.md
++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
++++- ### 1.2 Set the environmental variables
++++- ```
++++- # Code directory
++++--export F=automatic_vehicular_control/automatic_vehicular_control
++++-+export F=automatic_vehicular_control
++++- 
++++- # Results directory extracted from the zip file
++++- export R=results
++++-@@ -48,10 +48,8 @@ export R=results
++++- ## 2. Directory Structure
++++- 
++++- The code directory structure is
++++--```
++++-+``` 
++++- automatic_vehicular_control/
++++--│
++++--├── automatic_vehicular_control/
++++- │   ├── __pycache__/                # Compiled Python files
++++- │   ├── evaluations/                # Evaluation results and metrics
++++- │   ├── models/                     # Model checkpoints
++++ diff --git a/env.py b/env.py
++++-index 4ab3d95..c83a674 100644
+++++index c83a674..3ef7822 100644
++++ --- a/env.py
++++ +++ b/env.py
++++-@@ -724,9 +724,11 @@ class TrafficState:
++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
++++- 
++++-         segments = {}
++++-+        
++++-         def add_from_to(from_, to):
++++-             from_.tos.add(to)
++++-             to.froms.add(from_)
++++-+            
++++-         for con in map(values_str_to_val, net.children('connection')):
++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
++++-@@ -888,89 +890,109 @@ class TrafficState:
++++- 
++++-     def step(self):
++++-         """
++++--        Take a simulation step and update state
++++-+        Take a simulation step and update state.
++++-         """
++++--        c = self.c
++++--        tc = self.tc
++++--        subscribes = self.subscribes
++++-+        c = self.c  # Configuration object for the simulation
++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
++++- 
++++-         # Actual SUMO step
++++--        tc.simulationStep()
++++--        sim_res = subscribes.sim.get()
++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
++++- 
++++-+        # Clear references to current vehicle edges and lanes for the next update
++++-         for veh in self.vehicles:
++++--            veh.unvar('edge', 'lane')
++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
++++-+
++++-+        # Clear current vehicle data from edges and lanes
++++-         for ent in itertools.chain(self.edges, self.lanes):
++++--            ent.vehicles.clear()
++++--            ent.positions.clear()
++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
++++-+            ent.positions.clear()  # Clear vehicle positions
++++- 
++++-+        # Update traffic light states
++++-         for tl_id, tl in self.traffic_lights.items():
++++--            tl.update(subscribes.tl.get(tl_id))
++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
++++- 
++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
++++-         for veh_id in sim_res.loaded_vehicles_ids:
++++--            flow_id, _ = veh_id.rsplit('.')
++++--            flow = self.flows[flow_id]
++++--            flow.backlog.add(veh_id)
++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
++++- 
++++-+        # Initialize a set for newly departed vehicles
++++-         self.new_departed = set()
++++-+
++++-+        # Handle vehicles that have departed (entered the network)
++++-         for veh_id in sim_res.departed_vehicles_ids:
++++--            subscribes.veh.subscribe(veh_id)
++++--            type_id = tc.vehicle.getTypeID(veh_id)
++++--            # import pdb; pdb.set_trace()
++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
++++-+            # If vehicle type is 'generic', compute specific type
++++-             if type_id == 'generic':
++++-                 type_id = self.compute_type(veh_id)
++++--            type_ = self.types[type_id]
++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
++++--            length = tc.vehicle.getLength(veh_id)
++++--            road_id = tc.vehicle.getRoadID(veh_id)
++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
++++--            type_.vehicles.add(veh)
++++-+            type_ = self.types[type_id]  # Get vehicle type object
++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
++++-+
++++-+            # Create a new vehicle object and add it to the list of vehicles
++++-+            self.vehicles[veh_id] = veh = Vehicle(
++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
++++-+            )
++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
++++- 
++++-+            # Set color if rendering is enabled
++++-             if c.render:
++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
++++--                self.set_color(veh, color_fn(veh))
++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
++++- 
++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
++++-+
++++-+            # Add to new_departed set
++++-             self.new_departed.add(veh)
++++-+
++++-+            # Remove vehicle from backlog if necessary
++++-             if '.' in veh_id:
++++-                 flow_id, _ = veh_id.rsplit('.')
++++-                 if flow_id in self.flows:
++++-                     flow = self.flows[flow_id]
++++-                     flow.backlog.remove(veh_id)
++++- 
++++-+        # Handle newly arrived and collided vehicles
++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
++++-+        
++++-+        # Remove newly arrived vehicles from tracking if they collided
++++-         for veh in self.new_arrived:
++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
++++- 
++++-+        # Update vehicle positions on edges and lanes
++++-         for veh_id, veh in self.vehicles.items():
++++--            veh.prev_speed = veh.get('speed', None)
++++--            veh.update(subscribes.veh.get(veh_id))
++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
++++-             if veh_id not in sim_res.colliding_vehicles_ids:
++++--                edge = self.edges[veh.road_id]
++++--                edge.vehicles.append(veh)
++++--                veh.edge = edge
++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
++++--            # edge = self.edges[veh.road_id]
++++--            # edge.vehicles.append(veh)
++++--            # veh.edge = edge
++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
++++-+                veh.edge = edge  # Set vehicle's edge attribute
++++- 
++++-+        # Update vehicle sorting and lane positions
++++-         for edge in self.edges:
++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
++++-             for edge_i, veh in enumerate(edge.vehicles):
++++--                veh.edge_i = edge_i
++++--                veh.lane = lane = edge.lanes[veh.lane_index]
++++--                veh.lane_i = len(lane.vehicles)
++++--                lane.vehicles.append(veh)
++++--                lane.positions.append(veh.laneposition)
++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
++++- 
++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
++++-         self.all_arrived.append(self.new_arrived)
++++-         self.all_departed.append(self.new_departed)
++++-         self.all_collided.append(self.new_collided)
++++--
++++-+            
++++-     def reset(self, tc):
++++-         self.tc = tc
++++-         self.subscribes.clear()
++++-@@ -1043,6 +1065,7 @@ class Env:
++++-     """
++++-     Offers a similar reinforcement learning environment interface as gym.Env
++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
++++-+    c: Ring class
++++-     """
++++-     def __init__(self, c):
++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
++++-@@ -1056,6 +1079,7 @@ class Env:
++++-             if c.get('save_agent'):
++++-                 self._agent_info = []
++++-         self._step = 0
++++-+        self.mean_speed = 0
++++- 
++++-     def def_sumo(self, *args, **kwargs):
++++-         """ Override this with code defining the SUMO network """
++++-@@ -1094,49 +1118,91 @@ class Env:
++++-         """
++++-         return True
++++- 
++++-+   # Method to reset or initialize the SUMO traffic simulation environment
++++-     def reset_sumo(self):
++++-+        # Shortcuts for configuration and SUMO definition objects
++++-         c = self.c
++++-         sumo_def = self.sumo_def
++++--
++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
++++-+        
++++-+        # Determine if new SUMO definitions need to be generated
++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
++++-+        
++++-         if generate_def:
++++--            kwargs = self.def_sumo()
++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
++++-+            # Generate new definitions if necessary
++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
+++++@@ -852,12 +852,15 @@ class TrafficState:
+++++         subscribes.sim = SubscribeDef(tc.simulation, [
+++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
+++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
++++ +        
++++-+        # Start SUMO with the current traffic controller (tc)
++++-         self.tc = sumo_def.start_sumo(self.tc)
+++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
+++++             TL.red_yellow_green_state])
++++ +        
++++-         if generate_def:
++++-+            # If new definitions were generated, store relevant SUMO file paths
++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
++++-+            
++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
++++--            self.ts = TrafficState(c, self.tc, **defs)
++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
++++-         else:
++++-+            # If not generating new definitions, simply reset the existing traffic state
++++-             self.ts.reset(self.tc)
+++++         subscribes.veh = SubscribeDef(tc.vehicle, [
+++++             V.road_id, V.lane_index, V.laneposition,
+++++             V.speed, V.position, V.angle,
+++++             V.fuelconsumption, V.noxemission])
++++ +        
++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
++++-         self.ts.setup()
++++-+        
++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
++++-         success = self.init_vehicles()
++++-+        
++++-+        # Return whether the SUMO reset and vehicle initialization were successful
++++-         return success
+++++         for tl_id in self.traffic_lights.keys():
+++++             subscribes.tl.subscribe(tl_id)
++++  
++++-+    # Method to initialize the environment after SUMO reset
++++-     def init_env(self):
++++-+        # Reference to the traffic state
++++-         ts = self.ts
++++-+    
++++-+        # Create an empty data structure to store rollout information
++++-         self.rollout_info = NamedArrays()
++++-+        
++++-+        # Turn off all traffic lights in the network
++++-         for tl in ts.traffic_lights:
++++--            ts.set_program(tl, 'off')
++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
++++-+        
++++-+        # Reset the step counter to 0
++++-         self._step = 0
++++-+        
++++-+        # Take the first step in the simulation
++++-         ret = self.step()
++++-+        
++++-+        # Run the simulation for a number of warmup steps
++++-         for _ in range(self.c.warmup_steps):
++++--            ret = self.step()
++++-+            ret = self.step()  # Advance the simulation one step
++++-+            
++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
++++-                 return None
++++-+        
++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
++++-         for tl in ts.traffic_lights:
++++--            ts.set_program(tl, '1')
++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
++++-+        
++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
++++-         if isinstance(ret, tuple):
++++--            return ret[0]
++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
++++--
++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
++++-+        
++++-+    # Reset the entire environment, retrying until successful
++++-     def reset(self):
++++--        while True:
++++-+        self.mean_speed = 0
++++-+        while True:  # Infinite loop until the environment is successfully reset
++++-+            # Attempt to reset the SUMO simulation
+++++@@ -1197,6 +1200,7 @@ class Env:
+++++         while True:  # Infinite loop until the environment is successfully reset
+++++             # Attempt to reset the SUMO simulation
++++              if not self.reset_sumo():
++++--                continue
++++-+                continue  # If reset_sumo fails, retry the loop
++++-+            
++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++-             if (obs := self.init_env()) is not None:
++++--                return obs
++++-+                return obs  # Successfully initialized, return the observation
++++-+
++++- 
++++-     def append_step_info(self):
++++-         """
++++-@@ -1231,6 +1297,8 @@ class Env:
++++- class NormEnv(gym.Env):
++++-     """
++++-     Reward normalization with running average https://github.com/joschu/modular_rl
++++-+    self.c: Ring parameters 
++++-+    self.env: RingEnv class
++++-     """
++++-     def __init__(self, c, env):
++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
++++++                
+++++                 continue  # If reset_sumo fails, retry the loop
+++++             
+++++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++ diff --git a/exp.py b/exp.py
++++-index ead4652..7f7cee5 100644
+++++index 7f7cee5..6f16d66 100644
++++ --- a/exp.py
++++ +++ b/exp.py
++++-@@ -169,9 +169,9 @@ class Main(Config):
++++- 
++++-     def on_train_start(c):
++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
++++--        c.setdefaults(alg='Algorithm')
++++--        c._env = c.create_env()
++++--
++++-+        c.setdefaults(alg='Algorithm') 
++++-+        c._env = c.create_env() # Create NormEnv
++++-+ 
++++-         # Instantiate the algorithm (e.g., PPO, DQN)
++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
++++-         c.set_model()
++++-@@ -222,8 +222,8 @@ class Main(Config):
++++- 
++++-     def on_step_start(c, stats={}):
++++-         # Update the learning rate and log stats at the start of a training step
++++--        lr = c._lr
++++--        for g in c._opt.param_groups:
++++-+        lr = c._lr # Update Learning Rate
++++-+        for g in c._opt.param_groups: # Log Statistics
++++-             g['lr'] = float(lr)
++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
++++- 
++++-@@ -285,10 +285,14 @@ class Main(Config):
+++++@@ -285,7 +285,6 @@ class Main(Config):
++++              ret = dict(obs=ret)
++++          rollout = NamedArrays()
++++          rollout.append(**ret)
++++--
++++-+        rollout_flow_each_step = []
+++++-        rollout_flow_each_step = []
++++          done = False
++++          a_space = c.action_space
++++          step = 0
+++++@@ -406,9 +405,8 @@ class Main(Config):
+++++ 
+++++     def train(c):
+++++         # Main training loop
+++++-        c.on_train_start()
++++++        c.on_train_start() # Ring Env
+++++         while c._i < c.n_steps:
+++++-            c.on_step_start() # save stat 
+++++             with torch.no_grad():
+++++                 # Collect rollouts without computing gradients
+++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++@@ -497,3 +495,32 @@ class Main(Config):
+++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
+++++             c.train()
+++++         c.log('job done!')
++++++
++++++    def run_2(c):
++++++        # Determine whether to train or evaluate based on configuration
++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
++++++        
++++++        c.on_train_start()
++++++        c._env = c.create_env() # Create NormEnv
++++++        ret = c._env.reset()
++++++        c.set_model()
++++++        step = 0
++++ +        density = 20/(250*1e-3)
++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++++-+
++++-         while step < c.horizon + c.skip_stat_steps and not done:
++++-             # Generate an action from the model's policy
++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
++++-@@ -309,6 +313,12 @@ class Main(Config):
++++-             rollout.append(**ret)
++++-             step += 1
++++-         # Collect stats from the environment
++++++        done = False
++++++        while step < c.horizon + c.skip_stat_steps and not done:
++++++            # Take a step in the environment
++++++            ret = c._env.step()
++++++            if isinstance(ret, tuple):
++++++                obs, reward, done, info = ret
++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
++++++            done = ret.setdefault('done', False)
++++++            step += 1
++++++        # Collect stats from the environment
++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++++ +        density = 20/(250 * 1e-3)
++++ +        vehicle_flow = c._env.mean_speed * density 
++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++++-+
++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
++++-         return rollout, stats
++++- 
++++-@@ -398,10 +408,10 @@ class Main(Config):
++++-         # Main training loop
++++-         c.on_train_start()
++++-         while c._i < c.n_steps:
++++--            c.on_step_start()
++++-+            c.on_step_start() # save stat 
++++-             with torch.no_grad():
++++-                 # Collect rollouts without computing gradients
++++--                rollouts = c.rollouts()
++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++-             gd_stats = {}
++++-             if len(rollouts.obs):
++++-                 t_start = time()
++++-@@ -410,7 +420,7 @@ class Main(Config):
++++-                 gd_stats.update(gd_time=time() - t_start)
++++-             c.on_step_end(gd_stats)
++++-             c._i += 1
++++--        c.on_step_start()  # last step
++++-+        c.on_step_start()  # save stat
++++-         gd_stats = {}
++++-         with torch.no_grad():
++++-             rollouts = c.rollouts()
++++-@@ -450,6 +460,8 @@ class Main(Config):
++++-         if hasattr(c._env, 'close'):
++++-             c._env.close()
++++- 
+++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
+++++deleted file mode 100644
+++++index 6b9ba52..0000000
+++++--- a/highway_bottleneck.py
++++++++ /dev/null
+++++@@ -1,381 +0,0 @@
+++++-from automatic_vehicular_control.exp import *
+++++-from automatic_vehicular_control.env import *
+++++-from automatic_vehicular_control.u import *
+++++-
+++++-class BNeckEnv(Env):
+++++-    def def_sumo(self):
+++++-        c = self.c
+++++-        nodes = E('nodes',
+++++-            E('node', id='n_0', x=0, y=0), *(
+++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
+++++-        ))
+++++-        edges = E('edges', *(
+++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
+++++-                'numLanes': n_lane,
+++++-                'speed': c.max_speed
+++++-            }) for i, n_lane in enumerate(c.n_lanes)
+++++-        ))
+++++-        connections = E('connections', *(
+++++-            E('connection', **{
+++++-                'from': prev.id,
+++++-                'to': curr.id,
+++++-                'fromLane': i,
+++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
+++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
+++++-        ))
+++++-
+++++-        if c.split_flow:
+++++-            n_inflow_lanes = c.n_lanes[0]
+++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
+++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
+++++-                for i in range(n_inflow_lanes)
+++++-            ]
+++++-        else:
+++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
+++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
+++++-            ]
+++++-        routes = E('routes',
+++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
+++++-            *flows
+++++-        )
+++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
+++++-        additional = E('additional',
+++++-            E('vType', id='generic', **idm_params),
+++++-            E('vType', id='rl', **idm_params),
+++++-            E('vType', id='human', **idm_params),
+++++-        )
+++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++-
+++++-    def reset_sumo(self):
+++++-        c = self.c
+++++-        if c.flow_rate_range:
+++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
+++++-        ret = super().reset_sumo()
+++++-        if c.vinitsky:
+++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
+++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
+++++-                for i_start in range(round(edge.length) // c.piece_length)
+++++-                for lane in edge.lanes
+++++-            ]
+++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
+++++-            self.last_outflows = []
+++++-        return ret
+++++-
+++++-    def step(self, action=[]):
+++++-        c = self.c
+++++-        ts = self.ts
+++++-        max_dist = 100
+++++-        max_speed = c.max_speed
+++++-        human_type = ts.types.human
+++++-        rl_type = ts.types.rl
+++++-
+++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++-        if c.vinitsky:
+++++-            if len(action):
+++++-                assert len(action) == len(self.control_lanes)
+++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
+++++-                    self.control_lanes[lane, piece_start] = np.clip(
+++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
+++++-                        0.1, max_speed
+++++-                    )
+++++-                for veh in prev_rls:
+++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
+++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
+++++-        else:
+++++-            for veh, act in zip(prev_rls, action):
+++++-                if c.handcraft:
+++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
+++++-                    next_lane = lane.next(veh.route)
+++++-                    level = 1
+++++-                    if next_lane and next_lane.get('junction'):
+++++-                        merge_dist = lane.length - veh.laneposition
+++++-                        if merge_dist < c.handcraft:
+++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
+++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
+++++-                                level = 0
+++++-                    if c.act_type.startswith('accel'):
+++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++-                    else:
+++++-                        ts.set_max_speed(veh, max_speed * level)
+++++-                    continue
+++++-                if not isinstance(act, (int, np.integer)):
+++++-                    act = (act - c.low) / (1 - c.low)
+++++-                if c.act_type.startswith('accel'):
+++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++-                else:
+++++-                    if c.act_type == 'continuous':
+++++-                        level = act[0]
+++++-                    elif c.act_type == 'discretize':
+++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++-                    elif c.act_type == 'discrete':
+++++-                        level = act / (c.n_actions - 1)
+++++-                    ts.set_max_speed(veh, max_speed * level)
+++++-
+++++-                if c.lc_av == 'binary' and act[1] > 0.5:
+++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
+++++-
+++++-        super().step()
+++++-
+++++-        if c.vinitsky:
+++++-            n_last_outflows = 20
+++++-            max_vehs = 4
+++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
+++++-            obs = []
+++++-            for lane, piece_start in self.obs_lanes:
+++++-                piece_end = piece_start + c.piece_length
+++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
+++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
+++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
+++++-                obs.extend([
+++++-                    len(lane_humans) / max_vehs,
+++++-                    len(lane_avs) / max_vehs,
+++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
+++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
+++++-                ])
+++++-            if len(self.last_outflows) == n_last_outflows:
+++++-                self.last_outflows = self.last_outflows[1:]
+++++-            self.last_outflows.append(len(ts.new_arrived))
+++++-            reward = np.mean(self.last_outflows)
+++++-            obs.append(reward / max_veh_outflows)
+++++-            obs = np.array(obs, dtype=np.float32)
+++++-            assert 0 <= obs.min() and obs.max() <= 1
+++++-            return obs, reward, False, None
+++++-        route = nexti(ts.routes)
+++++-        obs, ids = [], []
+++++-        default_close = [0, max_speed]
+++++-        default_far = [max_dist, 0]
+++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++-            merge_dist = max_dist
+++++-            default_human = default_far
+++++-
+++++-            other_info = {}
+++++-            next_lane = lane.next(veh.route)
+++++-            if next_lane and next_lane.get('junction'):
+++++-                merge_dist = lane.length - veh.laneposition
+++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
+++++-                # Look for veh on other lane but do not extend past that lane
+++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
+++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
+++++-                    if other_veh.type is rl_type:
+++++-                        default_human = default_close
+++++-                        break
+++++-
+++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
+++++-            ids.append(veh.id)
+++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
+++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++-        
+++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++-
+++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++-        ttc = np.clip(ttc/7, -1, 1)
+++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++-        drac = np.clip(drac/10, -1, 1)
+++++-
+++++-        raw_pet = self.calc_pet()
+++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++-        pet = np.clip(pet, -1, 1)
+++++-
+++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++-        
+++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++-        return returned
+++++-        
+++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++-    
+++++-    def calc_ttc(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        ttcs = []
+++++-        for v in cur_veh_list:
+++++-            leader, headway = v.leader()
+++++-            v_speed = v.speed
+++++-            leader_speed = leader.speed
+++++-            if leader_speed < v_speed:
+++++-                ttc =  headway/(v_speed-leader_speed)
+++++-            else:
+++++-                ttc = np.nan
+++++-            ttcs.append(ttc)
+++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++-        return fleet_ttc
+++++-    
+++++-    def calc_drac(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        dracs = []
+++++-        for v in cur_veh_list:
+++++-            leader, headway = v.leader()
+++++-            v_speed = v.speed
+++++-            leader_speed = leader.speed
+++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++-            dracs.append(drac)
+++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++-        return fleet_drac
+++++-
+++++-    def calc_pet(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        pets = []
+++++-        for v in cur_veh_list:
+++++-            leader, headway = v.leader()
+++++-            v_speed = v.speed
+++++-            if v_speed > 1e-16:
+++++-                pet = headway/(v_speed)
+++++-                pets.append(pet)
+++++-        fleet_pet = np.nanmean(np.array(pets))
+++++-        return fleet_pet
+++++-
+++++-class BNeck(Main):
+++++-    def create_env(c):
+++++-        return BNeckEnv(c)
+++++-
+++++-    @property
+++++-    def observation_space(c):
+++++-        low = np.full(c._n_obs, c.low)
+++++-        return Box(low, np.ones_like(low))
+++++-
+++++-    @property
+++++-    def action_space(c):
+++++-        if c.vinitsky:
+++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
+++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++-            assert c.lc_av in [False, 'binary']
+++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
+++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++-            return Discrete(c.n_actions)
+++++-
+++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++-        if c.vinitsky:
+++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
+++++-        log = c.get_log_ii(ii, n_ii)
+++++-        step_obs_ = rollout.obs
+++++-        step_obs = step_obs_[:-1]
+++++-
+++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++-
+++++-        n_veh = np.array([len(o) for o in step_obs])
+++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++-
+++++-        step_id_ = rollout.pop('id')
+++++-        id = np.concatenate(step_id_[:-1])
+++++-        id_unique = np.unique(id)
+++++-
+++++-        reward = np.array(rollout.pop('reward'))
+++++-
+++++-        log(**stats)
+++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++-        log(
+++++-            n_veh_step_mean=n_veh.mean(), 
+++++-            n_veh_step_sum=n_veh.sum(), 
+++++-            n_veh_unique=len(id_unique),
+++++-            
+++++-            reward_mean=np.mean(reward),
+++++-            reward_std=np.std(reward),        
+++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++-            ssm_mean=np.mean(rollout.ssm),
+++++-            ssm_std=np.std(rollout.ssm),
+++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++-
+++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++-            # nom_action = np.mean(rollout.nom_action),
+++++-            # res_action = np.mean(rollout.res_action),
+++++-            )
+++++-        return rollout
+++++-
+++++-if __name__ == '__main__':
+++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
+++++-        warmup_steps=1000,
+++++-        horizon=2000,
+++++-        n_steps=100,
+++++-        step_save=5,
+++++-
+++++-        av_frac=0.2,
+++++-        sim_step=0.5,
+++++-        depart_speed=0,
+++++-        edge_lengths=[100, 100, 50],
+++++-        n_lanes=[4, 2, 1],
+++++-        max_speed=30,
+++++-
+++++-        lc_av=False,
+++++-        flow_rate=2300,
+++++-        flow_rate_range=None,
+++++-        split_flow=True,
+++++-        generic_type='rand',
+++++-        speed_mode=SPEED_MODE.all_checks,
+++++-        lc_mode=LC_MODE.off,
+++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++-
+++++-        veh_junction=False,
+++++-        act_type='accel_discrete',
+++++-        max_accel=2.6,
+++++-        max_decel=4.5,
+++++-        tau=1.0,
+++++-        min_gap=2.5,
+++++-        delta=4,
+++++-        n_actions=3,
+++++-        low=-1,
+++++-        handcraft=False,
+++++-        vinitsky=False,
+++++-
+++++-        render=False,
+++++-
+++++-        alg=PG,
+++++-        lr=1e-3,
+++++-
+++++-        gamma=0.99,
+++++-        adv_norm=False,
+++++-        batch_concat=True,
+++++-
+++++-        beta=0,
+++++-        scale_ttc=1,
+++++-        scale_drac=1,
+++++-        seed_np=False,
+++++-        seed_torch = False,
+++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++-
+++++-    )
+++++-    
+++++-    if c.seed_torch:
+++++-        # Set seed for PyTorch CPU operations
+++++-        torch.manual_seed(c.seed_torch)
+++++-        # Set seed for PyTorch CUDA operations (if available)
+++++-        if torch.cuda.is_available():
+++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++-    if c.seed_np:
+++++-        np.random.seed(c.seed_np)
+++++-        
+++++-    if c.vinitsky:
+++++-        c.piece_length = 20
+++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
+++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
+++++-        c._n_action = sum(n_actions[:-1])
+++++-        c._n_obs = sum(n_actions) * 4 + 1
+++++-        c.batch_concat = False
+++++-    else:
+++++-        c._n_obs = 2 + 2 + 2
+++++-        
+++++-    if c.mrtl:
+++++-        c._n_obs += 1 # modified for mrtl related
+++++-        
+++++-    c.redef_sumo = bool(c.flow_rate_range)
+++++-    c.run()
+++++\ No newline at end of file
+++++diff --git a/highway_ramp.py b/highway_ramp.py
+++++deleted file mode 100644
+++++index ef0358f..0000000
+++++--- a/highway_ramp.py
++++++++ /dev/null
+++++@@ -1,325 +0,0 @@
+++++-from automatic_vehicular_control.exp import *
+++++-from automatic_vehicular_control.env import *
+++++-from automatic_vehicular_control.u import *
+++++-
+++++-class RampEnv(Env):
+++++-    # https://flow-project.github.io/papers/08569485.pdf
+++++-    def def_sumo(self):
+++++-        c = self.c
+++++-        builder = NetBuilder()
+++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
+++++-            (0, 0),
+++++-            (c.premerge_distance, 0),
+++++-            (c.premerge_distance + c.merge_distance, 0),
+++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
+++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
+++++-        ])
+++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
+++++-            {}, {'numLanes': 2}, {}
+++++-        ], lane_maps=[
+++++-            {0: 1}, {0: 0, 1: 0}
+++++-        ], route_id='highway')
+++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
+++++-            {}, {'numLanes': 2}, {}
+++++-        ], lane_maps=[
+++++-            {0: 0}, {0: 0, 1: 0}
+++++-        ], route_id='ramp')
+++++-        nodes, edges, connections, routes = builder.build()
+++++-        nodes[2].type = 'zipper'
+++++-
+++++-        routes = E('routes',
+++++-            *routes,
+++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
+++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
+++++-        )
+++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
+++++-        additional = E('additional',
+++++-            E('vType', id='generic', **idm),
+++++-            E('vType', id='rl', **idm),
+++++-            E('vType', id='human', **idm),
+++++-        )
+++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++-
+++++-    def step(self, action=[]):
+++++-        c = self.c
+++++-        ts = self.ts
+++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
+++++-        max_speed = c.max_speed
+++++-        human_type = ts.types.human
+++++-        rl_type = ts.types.rl
+++++-
+++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++-        for rl, act in zip(prev_rls, action):
+++++-            if c.handcraft:
+++++-                route, edge, lane = rl.route, rl.edge, rl.lane
+++++-                leader, dist = rl.leader()
+++++-                level = 1
+++++-                if edge.id == 'e_n_0.0_n_400.0':
+++++-                    if rl.laneposition < 100:
+++++-                        leaders = list(rl.leaders())
+++++-                        if len(leaders) > 20:
+++++-                            level = 0
+++++-                        else:
+++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++-                continue
+++++-            if not isinstance(act, (int, np.integer)):
+++++-                act = (act - c.low) / (1 - c.low)
+++++-            if c.act_type.startswith('accel'):
+++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++-            else:
+++++-                if c.act_type == 'continuous':
+++++-                    level = act[0]
+++++-                elif c.act_type == 'discretize':
+++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++-                elif c.act_type == 'discrete':
+++++-                    level = act / (c.n_actions - 1)
+++++-                ts.set_max_speed(rl, max_speed * level)
+++++-
+++++-        super().step()
+++++-
+++++-        route = ts.routes.highway
+++++-        obs, ids = [], []
+++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++-            if hasattr(veh, 'edge'):
+++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++-                merge_dist = max_dist
+++++-
+++++-                lead_speed = follow_speed = other_speed = 0
+++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
+++++-
+++++-                leader, dist = veh.leader()
+++++-                if leader: lead_speed, lead_dist = leader.speed, dist
+++++-
+++++-                follower, dist = veh.follower()
+++++-                if follower: follow_speed, follow_dist = follower.speed, dist
+++++-
+++++-                if c.global_obs:
+++++-                    jun_edge = edge.next(route)
+++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
+++++-                        jun_edge = jun_edge.next(route)
+++++-                    if jun_edge:
+++++-                        merge_dist = lane.length - veh.laneposition
+++++-                        next_edge = edge.next(route)
+++++-                        while next_edge is not jun_edge:
+++++-                            merge_dist += next_edge.length
+++++-                            next_edge = next_edge.next(route)
+++++-
+++++-                        other_lane = jun_edge.lanes[0]
+++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
+++++-                            other_speed = other_veh.speed
+++++-                            break
+++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
+++++-                else:
+++++-                    next_lane = lane.next(route)
+++++-                    if next_lane and next_lane.get('junction'):
+++++-                        if len(edge.lanes) == 2:
+++++-                            other_lane = edge.lanes[0]
+++++-                            pos = veh.laneposition
+++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
+++++-                                other_speed = other_veh.speed
+++++-                                break
+++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
+++++-                ids.append(veh.id)
+++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
+++++-        if c.mrtl:
+++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++-        
+++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++-
+++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++-        ttc = np.clip(ttc/7, -1, 1)
+++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++-        drac = np.clip(drac/10, -1, 1)
+++++-
+++++-        raw_pet = self.calc_pet()
+++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++-        pet = np.clip(pet, -1, 1)
+++++-
+++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++-        
+++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++-        return returned
+++++-        
+++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++-    
+++++-    def calc_ttc(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        ttcs = []
+++++-        for v in cur_veh_list:
+++++-            if hasattr(v, 'edge'):
+++++-                leader, headway = v.leader()
+++++-                if leader:
+++++-                    v_speed = v.speed
+++++-                    leader_speed = leader.speed
+++++-                    if leader_speed < v_speed:
+++++-                        ttc =  headway/(v_speed-leader_speed)
+++++-                    else:
+++++-                        ttc = np.nan
+++++-                    ttcs.append(ttc)
+++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++-        return fleet_ttc
+++++-    
+++++-    def calc_drac(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        dracs = []
+++++-        for v in cur_veh_list:
+++++-            if hasattr(v, 'edge'):
+++++-                leader, headway = v.leader()
+++++-                if leader:
+++++-                    v_speed = v.speed
+++++-                    leader_speed = leader.speed
+++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++-                    dracs.append(drac)
+++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++-        return fleet_drac
+++++-
+++++-    def calc_pet(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        pets = []
+++++-        for v in cur_veh_list:
+++++-            if hasattr(v, 'edge'):
+++++-                leader, headway = v.leader()
+++++-                if leader:
+++++-                    v_speed = v.speed
+++++-                    if v_speed > 1e-16:
+++++-                        pet = headway/(v_speed)
+++++-                        pets.append(pet)
+++++-        fleet_pet = np.nanmean(np.array(pets))
+++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
+++++-        return fleet_pet
+++++-
+++++-class Ramp(Main):
+++++-    def create_env(c):
+++++-        return RampEnv(c)
+++++-
+++++-    @property
+++++-    def observation_space(c):
+++++-        low = np.full(c._n_obs, c.low)
+++++-        return Box(low, np.ones_like(low))
+++++-
+++++-    @property
+++++-    def action_space(c):
+++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++-            return Discrete(c.n_actions)
+++++-
+++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++-        log = c.get_log_ii(ii, n_ii)
+++++-        step_obs_ = rollout.obs
+++++-        step_obs = step_obs_[:-1]
+++++-
+++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++-
+++++-        n_veh = np.array([len(o) for o in step_obs])
+++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++-
+++++-        step_id_ = rollout.pop('id')
+++++-        id = np.concatenate(step_id_[:-1])
+++++-        id_unique = np.unique(id)
+++++-
+++++-        reward = np.array(rollout.pop('reward'))
+++++-
+++++-        log(**stats)
+++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++-        log(
+++++-            n_veh_step_mean=n_veh.mean(), 
+++++-            n_veh_step_sum=n_veh.sum(), 
+++++-            n_veh_unique=len(id_unique),
+++++-            
+++++-            reward_mean=np.mean(reward),
+++++-            reward_std=np.std(reward),        
+++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++-            ssm_mean=np.mean(rollout.ssm),
+++++-            ssm_std=np.std(rollout.ssm),
+++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++-
+++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++-            # nom_action = np.mean(rollout.nom_action),
+++++-            # res_action = np.mean(rollout.res_action),
+++++-            )
+++++-        return rollout
+++++-
+++++-if __name__ == '__main__':
+++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
+++++-        warmup_steps=100,
+++++-        horizon=2000,
+++++-        n_steps=100,
+++++-        step_save=5,
+++++-
+++++-        premerge_distance=400,
+++++-        merge_distance=100,
+++++-        postmerge_distance=30,
+++++-        av_frac=0.1,
+++++-        sim_step=0.5,
+++++-        max_speed=30,
+++++-        highway_depart_speed=10,
+++++-        ramp_depart_speed=0,
+++++-        highway_flow_rate=2000,
+++++-        ramp_flow_rate=300,
+++++-        global_obs=False,
+++++-        handcraft=False,
+++++-
+++++-        generic_type='default',
+++++-        speed_mode=SPEED_MODE.all_checks,
+++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++-
+++++-        act_type='accel_discrete',
+++++-        max_accel=1,
+++++-        max_decel=1.5,
+++++-        n_actions=3,
+++++-        low=-1,
+++++-
+++++-        render=False,
+++++-
+++++-        alg=PG,
+++++-        lr=1e-3,
+++++-
+++++-        gamma=0.99,
+++++-        adv_norm=False,
+++++-        batch_concat=True,
+++++-
+++++-        beta=0,
+++++-        scale_ttc=1,
+++++-        scale_drac=1,
+++++-        seed_np=False,
+++++-        seed_torch = False,
+++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++-
+++++-    )
+++++-    
+++++-    if c.seed_torch:
+++++-        # Set seed for PyTorch CPU operations
+++++-        torch.manual_seed(c.seed_torch)
+++++-        # Set seed for PyTorch CUDA operations (if available)
+++++-        if torch.cuda.is_available():
+++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++-    if c.seed_np:
+++++-        np.random.seed(c.seed_np)
+++++-        
+++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
+++++-    if c.mrtl:
+++++-        c._n_obs += 1 # modified for mrtl related
+++++-    c.run()
+++++\ No newline at end of file
+++++diff --git a/intersection.py b/intersection.py
+++++deleted file mode 100644
+++++index e38a84f..0000000
+++++--- a/intersection.py
++++++++ /dev/null
+++++@@ -1,489 +0,0 @@
+++++-from automatic_vehicular_control.u import *
+++++-from automatic_vehicular_control.exp import *
+++++-from automatic_vehicular_control.env import *
+++++-
+++++-class Platoon(Entity):
+++++-    pass
+++++-
+++++-class IntersectionEnv(Env):
+++++-    def def_sumo(self):
+++++-        c = self.c
+++++-
+++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
+++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
+++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
+++++-        ] if params.get('vehsPerHour')]
+++++-
+++++-        builder = NetBuilder()
+++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
+++++-        if c.enter_length:
+++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++-            xys[1:, :, 0] += c.enter_length - c.length
+++++-            xys[:, 1:, 1] += c.enter_length - c.length
+++++-            xys = xys.reshape(-1, 2)
+++++-        if c.short_exit:
+++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++-            xys[-1, :, 0] += c.short_exit - c.length
+++++-            xys[:, -1, 1] += c.short_exit - c.length
+++++-            xys = xys.reshape(-1, 2)
+++++-        nodes = builder.add_nodes(
+++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
+++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
+++++-        # import pdb; pdb.set_trace()
+++++-
+++++-        tl = c.setdefault('tl', False)
+++++-        if tl:
+++++-            c.av_frac = 0
+++++-            c.pop('av_range', None)
+++++-            c.speed_mode = SPEED_MODE.all_checks
+++++-
+++++-        flows = []
+++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
+++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
+++++-        for direction in c.directions:
+++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
+++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
+++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
+++++-
+++++-            edge_attrs = dict(priority=int(direction in priority))
+++++-            if c.get('set_edge_speed', True):
+++++-                edge_attrs['speed'] = c.max_speed
+++++-
+++++-            for i, chain in enumerate(chains[1:-1]):
+++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
+++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
+++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
+++++-
+++++-        tls = []
+++++-        if tl:
+++++-            tl = 1000000 if tl == 'MaxPressure' else tl
+++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
+++++-            tl_offset = c.get('tl_offset', 'auto')
+++++-            yellow = c.get('yellow', 0.5)
+++++-            if tl_offset == 'auto':
+++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
+++++-            elif tl_offset == 'same':
+++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
+++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
+++++-                node.type = 'traffic_light'
+++++-                phase_multiple = len(c.directions) // 2
+++++-                tls.append(E('tlLogic',
+++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
+++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
+++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
+++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
+++++-                id=node.id, offset=offset, type='static', programID='1'))
+++++-
+++++-        nodes, edges, connections, routes = builder.build()
+++++-        additional = E('additional', *types, *routes, *flows, *tls)
+++++-        return super().def_sumo(nodes, edges, connections, additional)
+++++-
+++++-    def build_platoon(self):
+++++-        ts = self.ts
+++++-        rl_type = ts.types.rl
+++++-        for route in ts.routes:
+++++-            vehs = []
+++++-            route_offset = 0
+++++-            for edge in route.edges:
+++++-                for veh in edge.vehicles:
+++++-                    veh.route_position = route_offset + veh.laneposition
+++++-                    vehs.append(veh)
+++++-                route_offset += edge.length
+++++-
+++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
+++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
+++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
+++++-            rl_idxs, = rl_mask.nonzero()
+++++-            split_idxs = 1 + rl_idxs
+++++-
+++++-            prev = None
+++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
+++++-                if not len(vehs_i):
+++++-                    continue # Last vehicle is RL, so the last split is empty
+++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
+++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
+++++-                )
+++++-                if prev is not None:
+++++-                    prev.next = platoon
+++++-                prev = platoon
+++++-                for veh in vehs_i:
+++++-                    veh.platoon = platoon
+++++-            if prev is not None:
+++++-                prev.next = None
+++++-
+++++-    def reset(self):
+++++-        c = self.c
+++++-        if c.e is False:
+++++-            if 'length_range' in c:
+++++-                min_, max_ = c.length_range
+++++-                c.setdefaults(max_length=max_)
+++++-                c.length = np.random.randint(min_, max_ + 1)
+++++-            if 'av_range' in c:
+++++-                min_, max_ = c.av_range
+++++-                c.av_frac = np.random.uniform(min_, max_)
+++++-        self.mp_tlast = 0
+++++-        while not self.reset_sumo():
+++++-            pass
+++++-        ret = super().init_env()
+++++-        return ret
+++++-
+++++-    def step(self, action=[]):
+++++-        c = self.c
+++++-        ts = self.ts
+++++-        max_dist = c.max_dist
+++++-        depart_speed = c.depart_speed
+++++-        max_speed = c.max_speed
+++++-
+++++-        rl_type = ts.types.rl
+++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++-
+++++-        for rl, act in zip(prev_rls, action):
+++++-            if c.handcraft or c.handcraft_tl:
+++++-                route, lane = rl.route, rl.lane
+++++-                junction = lane.next_junction
+++++-                level = 1
+++++-                if junction is not ts.sentinel_junction:
+++++-                    dist = junction.route_position[route] - rl.route_position
+++++-                    if c.handcraft:
+++++-                        for cross_lane in lane.next_cross_lanes:
+++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
+++++-                    elif c.handcraft_tl and dist < 15:
+++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
+++++-                        yellow_time = 0
+++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
+++++-                        horizontal_go = 0 <= rem < t_h
+++++-                        vertical_go = t_h + yellow_time <= rem
+++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
+++++-                        human_remain = False
+++++-                        for cross_lane in lane.next_cross_lanes:
+++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
+++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
+++++-            elif c.act_type == 'accel':
+++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
+++++-            else:
+++++-                level = act / (c.n_actions - 1)
+++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++-
+++++-        if c.tl == 'MaxPressure':
+++++-            self.mp_tlast += c.sim_step
+++++-            tmin = c.get('mp_tmin', 0)
+++++-            if self.mp_tlast >= tmin:
+++++-                for tl in ts.traffic_lights:
+++++-                    if ts.get_program(tl) == 'off':
+++++-                        break
+++++-                    jun = tl.junction
+++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
+++++-
+++++-                    total_pressures = []
+++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
+++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
+++++-
+++++-                    ts.set_phase(tl, np.argmax(total_pressures))
+++++-                self.mp_tlast = 0
+++++-
+++++-        super().step()
+++++-        self.build_platoon()
+++++-
+++++-        obs = {}
+++++-
+++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
+++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
+++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
+++++-        for veh in rl_type.vehicles:
+++++-            if hasattr(veh, 'lane'):
+++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
+++++-                junction = lane.next_junction
+++++-
+++++-                head, tail = veh, platoon.tail
+++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
+++++-
+++++-                if junction is ts.sentinel_junction:
+++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
+++++-                else:
+++++-                    for jun_lane in lane.next_junction_lanes:
+++++-                        # Defaults for jun_lane
+++++-                        jun_headtails = vehs_default()
+++++-
+++++-                        jun_lane_route = nexti(jun_lane.from_routes)
+++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
+++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
+++++-
+++++-                        if jun_veh:
+++++-                            if jun_veh.type is rl_type:
+++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
+++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
+++++-                                platoon = jun_veh.platoon.prev
+++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++-                                    if platoon is None: break
+++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++-                                    platoon = platoon.prev
+++++-                            else:
+++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
+++++-                                jun_headtails[0] = jun_veh.platoon.tail
+++++-                                next_cross_platoon = jun_veh.platoon.prev
+++++-                                if next_cross_platoon:
+++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
+++++-                                    platoon = next_cross_platoon.prev
+++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++-                                        if platoon is None: break
+++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++-                                        platoon = platoon.prev
+++++-                        route_vehs.append((jun_lane_route, jun_headtails))
+++++-
+++++-                dist_features, speed_features = [], []
+++++-                for route, vehs in route_vehs:
+++++-                    j_pos = junction.route_position[route]
+++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
+++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
+++++-
+++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++-
+++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
+++++-        ids = sorted(obs)
+++++-        if c.mrtl:
+++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
+++++-        if c.rew_type == 'outflow':
+++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++-        elif c.rew_type == 'time_penalty':
+++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
+++++-        
+++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++-
+++++-        raw_drac = self.calc_drac()
+++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++-        drac = np.clip(drac/10, -1, 1)
+++++-        raw_pet = self.calc_pet()
+++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++-        pet = np.clip(pet/6, -1, 1)
+++++-
+++++-        raw_ttc = self.calc_ttc()
+++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++-        ttc = np.clip(ttc/7, -1, 1)
+++++-
+++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
+++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++-
+++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++-        return returned
+++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++-        
+++++-    def calc_drac(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        dracs = []
+++++-        for v in cur_veh_list:
+++++-            if hasattr(v, 'lane'):
+++++-                leader, headway = v.leader()
+++++-                v_speed = v.speed
+++++-                leader_speed = leader.speed
+++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++-                dracs.append(drac)
+++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++-        return fleet_drac
+++++-    
+++++-    def calc_pet(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        pets = []
+++++-        for v in cur_veh_list:
+++++-            if hasattr(v, 'lane'):
+++++-                leader, headway = v.leader()
+++++-                v_speed = v.speed
+++++-                if v_speed > 1e-16:
+++++-                    pet = headway/(v_speed)
+++++-                    pets.append(pet)
+++++-        fleet_pet = np.nanmean(np.array(pets))
+++++-        return fleet_pet
+++++-
+++++-    def calc_ttc(self):
+++++-        cur_veh_list = self.ts.vehicles
+++++-        ttcs = []
+++++-        for v in cur_veh_list:
+++++-            if hasattr(v, 'lane'):
+++++-                leader, headway = v.leader()
+++++-                v_speed = v.speed
+++++-                leader_speed = leader.speed
+++++-                if leader_speed < v_speed:
+++++-                    ttc =  headway/(v_speed-leader_speed)
+++++-                else:
+++++-                    ttc = np.nan
+++++-                ttcs.append(ttc)
+++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++-        return fleet_ttc
+++++-
+++++-    def append_step_info(self):
+++++-        super().append_step_info()
+++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
+++++-
+++++-    @property
+++++-    def stats(self):
+++++-        c = self.c
+++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
+++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
+++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
+++++-        stats['backlog_step'] = mean(info['backlog'])
+++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
+++++-
+++++-        stats['beta'] = c.beta
+++++-
+++++-        if c.multi_flowrate:
+++++-            stats['flow_horizontal'] = c.flow_rate_h
+++++-            stats['flow_vertical'] = c.flow_rate_v
+++++-        return stats
+++++-
+++++-class Intersection(Main):
+++++-    def create_env(c):
+++++-        if c.multi_flowrate:
+++++-            return NormEnv(c, IntersectionEnv(c))
+++++-        else:
+++++-            c._norm = NormEnv(c, None)
+++++-            return IntersectionEnv(c)
+++++-
+++++-    @property
+++++-    def observation_space(c):
+++++-        low = np.full(c._n_obs, c.low)
+++++-        return Box(low, np.ones_like(low))
+++++-
+++++-    @property
+++++-    def action_space(c):
+++++-        if c.act_type == 'accel':
+++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++-        else:
+++++-            return Discrete(c.n_actions)
+++++-
+++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++-        log = c.get_log_ii(ii, n_ii)
+++++-        step_obs_ = rollout.obs
+++++-        step_obs = step_obs_[:-1]
+++++-
+++++-        if not c.multi_flowrate:
+++++-            rollout.raw_reward = rollout.reward
+++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
+++++-
+++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++-
+++++-        n_veh = np.array([len(o) for o in step_obs])
+++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++-
+++++-        step_id_ = rollout.pop('id')
+++++-        id = np.concatenate(step_id_[:-1])
+++++-        id_unique = np.unique(id)
+++++-
+++++-        reward = np.array(rollout.pop('reward'))
+++++-        raw_reward = np.array(rollout.pop('raw_reward'))
+++++-
+++++-        log(**stats)
+++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
+++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++-        log(
+++++-            n_veh_step_mean=n_veh.mean(), 
+++++-            n_veh_step_sum=n_veh.sum(), 
+++++-            n_veh_unique=len(id_unique),
+++++-            
+++++-            reward_mean=np.mean(reward),
+++++-            reward_std=np.std(reward),        
+++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++-            ssm_mean=np.mean(rollout.ssm),
+++++-            ssm_std=np.std(rollout.ssm),
+++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++-
+++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++-            # nom_action = np.mean(rollout.nom_action),
+++++-            # res_action = np.mean(rollout.res_action),
+++++-            )
+++++-        
+++++-        return rollout
+++++-
+++++-if __name__ == '__main__':
+++++-    c = Intersection.from_args(globals(), locals())
+++++-    c.setdefaults(
+++++-        n_steps=200,
+++++-        step_save=5,
+++++-
+++++-        depart_speed=0,
+++++-        max_speed=13,
+++++-        max_dist=100,
+++++-        max_accel=1.5,
+++++-        max_decel=3.5,
+++++-        sim_step=0.5,
+++++-        generic_type=True,
+++++-        n_actions=3,
+++++-
+++++-        adv_norm=False,
+++++-        batch_concat=True,
+++++-
+++++-        render=False,
+++++-
+++++-        warmup_steps=100,
+++++-        horizon=2000,
+++++-        directions='4way',
+++++-        av_frac=0.15,
+++++-        handcraft=False,
+++++-        handcraft_tl=None,
+++++-        flow_rate=700,
+++++-        length=100,
+++++-        n_rows=1,
+++++-        n_cols=1,
+++++-        speed_mode=SPEED_MODE.obey_safe_speed,
+++++-
+++++-        act_type='accel_discrete',
+++++-        low=-1,
+++++-
+++++-        alg=PG,
+++++-        n_gds=1,
+++++-        lr=1e-3,
+++++-        gamma=0.99,
+++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++-
+++++-        enter_length=False,
+++++-        short_exit=False,
+++++-
+++++-        rew_type='outflow',
+++++-        norm_reward=True,
+++++-        center_reward=True,
+++++-        multi_flowrate=False,
+++++-        opt='RMSprop',
+++++-
+++++-        obs_tail=True,
+++++-        obs_next_cross_platoons=1,
+++++-
+++++-        beta=0,
+++++-        scale_pet=1,
+++++-        scale_drac=1,
+++++-        seed_np=False,
+++++-        seed_torch = False,
+++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++-    )
+++++-
+++++-    if c.seed_torch:
+++++-        # Set seed for PyTorch CPU operations
+++++-        torch.manual_seed(c.seed_torch)
+++++-        # Set seed for PyTorch CUDA operations (if available)
+++++-        if torch.cuda.is_available():
+++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++-    if c.seed_np:
+++++-        np.random.seed(c.seed_np)
+++++-
+++++-    if c.directions == '4way':
+++++-        c.directions = ['up', 'right', 'down', 'left']
+++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
+++++-    if c.mrtl:
+++++-        c._n_obs += 1
+++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
+++++-    c.redef_sumo = 'length_range' in c
+++++-    c.run()
+++++\ No newline at end of file
+++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++index d4c3dac..544742d 100644
+++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++@@ -1,600 +1,16048 @@
+++++-diff --git a/README.md b/README.md
+++++-index b591747..127f484 100644
+++++---- a/README.md
+++++-+++ b/README.md
+++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
+++++- ### 1.2 Set the environmental variables
+++++- ```
+++++- # Code directory
+++++--export F=automatic_vehicular_control/automatic_vehicular_control
+++++-+export F=automatic_vehicular_control
+++++- 
+++++- # Results directory extracted from the zip file
+++++- export R=results
+++++-@@ -48,10 +48,8 @@ export R=results
+++++- ## 2. Directory Structure
+++++- 
+++++- The code directory structure is
+++++--```
+++++-+``` 
+++++- automatic_vehicular_control/
+++++--│
+++++--├── automatic_vehicular_control/
+++++- │   ├── __pycache__/                # Compiled Python files
+++++- │   ├── evaluations/                # Evaluation results and metrics
+++++- │   ├── models/                     # Model checkpoints
+++++ diff --git a/env.py b/env.py
+++++-index 4ab3d95..c83a674 100644
++++++index c83a674..3ef7822 100644
+++++ --- a/env.py
+++++ +++ b/env.py
+++++-@@ -724,9 +724,11 @@ class TrafficState:
+++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
+++++- 
+++++-         segments = {}
+++++-+        
+++++-         def add_from_to(from_, to):
+++++-             from_.tos.add(to)
+++++-             to.froms.add(from_)
+++++-+            
+++++-         for con in map(values_str_to_val, net.children('connection')):
+++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
+++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
+++++-@@ -888,89 +890,109 @@ class TrafficState:
+++++- 
+++++-     def step(self):
+++++-         """
+++++--        Take a simulation step and update state
+++++-+        Take a simulation step and update state.
+++++-         """
+++++--        c = self.c
+++++--        tc = self.tc
+++++--        subscribes = self.subscribes
+++++-+        c = self.c  # Configuration object for the simulation
+++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
+++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
+++++- 
+++++-         # Actual SUMO step
+++++--        tc.simulationStep()
+++++--        sim_res = subscribes.sim.get()
+++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
+++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
+++++- 
+++++-+        # Clear references to current vehicle edges and lanes for the next update
+++++-         for veh in self.vehicles:
+++++--            veh.unvar('edge', 'lane')
+++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
+++++-+
+++++-+        # Clear current vehicle data from edges and lanes
+++++-         for ent in itertools.chain(self.edges, self.lanes):
+++++--            ent.vehicles.clear()
+++++--            ent.positions.clear()
+++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
+++++-+            ent.positions.clear()  # Clear vehicle positions
+++++- 
+++++-+        # Update traffic light states
+++++-         for tl_id, tl in self.traffic_lights.items():
+++++--            tl.update(subscribes.tl.get(tl_id))
+++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
+++++- 
+++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
+++++-         for veh_id in sim_res.loaded_vehicles_ids:
+++++--            flow_id, _ = veh_id.rsplit('.')
+++++--            flow = self.flows[flow_id]
+++++--            flow.backlog.add(veh_id)
+++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
+++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
+++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
+++++- 
+++++-+        # Initialize a set for newly departed vehicles
+++++-         self.new_departed = set()
+++++-+
+++++-+        # Handle vehicles that have departed (entered the network)
+++++-         for veh_id in sim_res.departed_vehicles_ids:
+++++--            subscribes.veh.subscribe(veh_id)
+++++--            type_id = tc.vehicle.getTypeID(veh_id)
+++++--            # import pdb; pdb.set_trace()
+++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
+++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
+++++-+            # If vehicle type is 'generic', compute specific type
+++++-             if type_id == 'generic':
+++++-                 type_id = self.compute_type(veh_id)
+++++--            type_ = self.types[type_id]
+++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
+++++--            length = tc.vehicle.getLength(veh_id)
+++++--            road_id = tc.vehicle.getRoadID(veh_id)
+++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
+++++--            type_.vehicles.add(veh)
+++++-+            type_ = self.types[type_id]  # Get vehicle type object
+++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
+++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
+++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
+++++-+
+++++-+            # Create a new vehicle object and add it to the list of vehicles
+++++-+            self.vehicles[veh_id] = veh = Vehicle(
+++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
+++++-+            )
+++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
+++++- 
+++++-+            # Set color if rendering is enabled
+++++-             if c.render:
+++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
+++++--                self.set_color(veh, color_fn(veh))
+++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
+++++- 
+++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
+++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
+++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
+++++-+
+++++-+            # Add to new_departed set
+++++-             self.new_departed.add(veh)
+++++-+
+++++-+            # Remove vehicle from backlog if necessary
+++++-             if '.' in veh_id:
+++++-                 flow_id, _ = veh_id.rsplit('.')
+++++-                 if flow_id in self.flows:
+++++-                     flow = self.flows[flow_id]
+++++-                     flow.backlog.remove(veh_id)
+++++- 
+++++-+        # Handle newly arrived and collided vehicles
+++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
+++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+++++-+        
+++++-+        # Remove newly arrived vehicles from tracking if they collided
+++++-         for veh in self.new_arrived:
+++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
+++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
+++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
+++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
+++++- 
+++++-+        # Update vehicle positions on edges and lanes
+++++-         for veh_id, veh in self.vehicles.items():
+++++--            veh.prev_speed = veh.get('speed', None)
+++++--            veh.update(subscribes.veh.get(veh_id))
+++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
+++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
+++++-             if veh_id not in sim_res.colliding_vehicles_ids:
+++++--                edge = self.edges[veh.road_id]
+++++--                edge.vehicles.append(veh)
+++++--                veh.edge = edge
+++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
+++++--            # edge = self.edges[veh.road_id]
+++++--            # edge.vehicles.append(veh)
+++++--            # veh.edge = edge
+++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
+++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
+++++-+                veh.edge = edge  # Set vehicle's edge attribute
+++++- 
+++++-+        # Update vehicle sorting and lane positions
+++++-         for edge in self.edges:
+++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
+++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
+++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
+++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
+++++-             for edge_i, veh in enumerate(edge.vehicles):
+++++--                veh.edge_i = edge_i
+++++--                veh.lane = lane = edge.lanes[veh.lane_index]
+++++--                veh.lane_i = len(lane.vehicles)
+++++--                lane.vehicles.append(veh)
+++++--                lane.positions.append(veh.laneposition)
+++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
+++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
+++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
+++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
+++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
+++++- 
+++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
+++++-         self.all_arrived.append(self.new_arrived)
+++++-         self.all_departed.append(self.new_departed)
+++++-         self.all_collided.append(self.new_collided)
+++++--
+++++-+            
+++++-     def reset(self, tc):
+++++-         self.tc = tc
+++++-         self.subscribes.clear()
+++++-@@ -1043,6 +1065,7 @@ class Env:
+++++-     """
+++++-     Offers a similar reinforcement learning environment interface as gym.Env
+++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
+++++-+    c: Ring class
+++++-     """
+++++-     def __init__(self, c):
+++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
+++++-@@ -1056,6 +1079,7 @@ class Env:
+++++-             if c.get('save_agent'):
+++++-                 self._agent_info = []
+++++-         self._step = 0
+++++-+        self.mean_speed = 0
+++++- 
+++++-     def def_sumo(self, *args, **kwargs):
+++++-         """ Override this with code defining the SUMO network """
+++++-@@ -1094,49 +1118,91 @@ class Env:
+++++-         """
+++++-         return True
+++++- 
+++++-+   # Method to reset or initialize the SUMO traffic simulation environment
+++++-     def reset_sumo(self):
+++++-+        # Shortcuts for configuration and SUMO definition objects
+++++-         c = self.c
+++++-         sumo_def = self.sumo_def
+++++--
+++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+++++-+        
+++++-+        # Determine if new SUMO definitions need to be generated
+++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
+++++-+        
+++++-         if generate_def:
+++++--            kwargs = self.def_sumo()
+++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
+++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
+++++-+            # Generate new definitions if necessary
+++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
+++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
+++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
+++++-+        
+++++-+        # Start SUMO with the current traffic controller (tc)
+++++-         self.tc = sumo_def.start_sumo(self.tc)
+++++-+        
+++++-         if generate_def:
+++++-+            # If new definitions were generated, store relevant SUMO file paths
+++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
+++++-+            
+++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
+++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
+++++--            self.ts = TrafficState(c, self.tc, **defs)
+++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
+++++-         else:
+++++-+            # If not generating new definitions, simply reset the existing traffic state
+++++-             self.ts.reset(self.tc)
++++++@@ -852,12 +852,15 @@ class TrafficState:
++++++         subscribes.sim = SubscribeDef(tc.simulation, [
++++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
++++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
+++++ +        
+++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
+++++-         self.ts.setup()
++++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
++++++             TL.red_yellow_green_state])
+++++ +        
+++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+++++-         success = self.init_vehicles()
++++++         subscribes.veh = SubscribeDef(tc.vehicle, [
++++++             V.road_id, V.lane_index, V.laneposition,
++++++             V.speed, V.position, V.angle,
++++++             V.fuelconsumption, V.noxemission])
+++++ +        
+++++-+        # Return whether the SUMO reset and vehicle initialization were successful
+++++-         return success
++++++         for tl_id in self.traffic_lights.keys():
++++++             subscribes.tl.subscribe(tl_id)
+++ +  
+++-+
+++-     def run(c):
+++-         # Determine whether to train or evaluate based on configuration
+++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++-diff --git a/ring.py b/ring.py
+++-index 94d632d..ee1372b 100644
+++---- a/ring.py
+++-+++ b/ring.py
+++-@@ -15,7 +15,6 @@ class RingEnv(Env):
+++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++-         )
+++--
+++-         # Function to generate the shape of the edges (circular arcs)
+++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++- 
+++-@@ -88,6 +87,17 @@ class RingEnv(Env):
+++-         if c.circumference_range:  # Check if the circumference should be randomized
+++-             # Randomly set the circumference within the specified range
+++-             c.circumference = np.random.randint(*c.circumference_range)
+++-+        
+++-+        if self.flow_log:
+++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
+++-+            self.episode_flow.append(average_flow)
+++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
+++-+        
+++-+        # Reset flow counters for the new episode
+++-+        self.flow_counter = 0
+++-+        self.flow_log = []
+++-+        self.last_vehicle_times = {}
+++-+        
+++-         return super().reset_sumo()  # Reset the simulation
+++++-+    # Method to initialize the environment after SUMO reset
+++++-     def init_env(self):
+++++-+        # Reference to the traffic state
+++++-         ts = self.ts
+++++-+    
+++++-+        # Create an empty data structure to store rollout information
+++++-         self.rollout_info = NamedArrays()
+++++-+        
+++++-+        # Turn off all traffic lights in the network
+++++-         for tl in ts.traffic_lights:
+++++--            ts.set_program(tl, 'off')
+++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
+++++-+        
+++++-+        # Reset the step counter to 0
+++++-         self._step = 0
+++++-+        
+++++-+        # Take the first step in the simulation
+++++-         ret = self.step()
+++++-+        
+++++-+        # Run the simulation for a number of warmup steps
+++++-         for _ in range(self.c.warmup_steps):
+++++--            ret = self.step()
+++++-+            ret = self.step()  # Advance the simulation one step
+++++-+            
+++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
+++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
+++++-                 return None
+++++-+        
+++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
+++++-         for tl in ts.traffic_lights:
+++++--            ts.set_program(tl, '1')
+++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
+++++-+        
+++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
+++++-         if isinstance(ret, tuple):
+++++--            return ret[0]
+++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
+++++--
+++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
+++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
+++++-+        
+++++-+    # Reset the entire environment, retrying until successful
+++++-     def reset(self):
+++++--        while True:
+++++-+        self.mean_speed = 0
+++++-+        while True:  # Infinite loop until the environment is successfully reset
+++++-+            # Attempt to reset the SUMO simulation
++++++@@ -1197,6 +1200,7 @@ class Env:
++++++         while True:  # Infinite loop until the environment is successfully reset
++++++             # Attempt to reset the SUMO simulation
+++++              if not self.reset_sumo():
+++++--                continue
+++++-+                continue  # If reset_sumo fails, retry the loop
+++++-+            
+++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++++-             if (obs := self.init_env()) is not None:
+++++--                return obs
+++++-+                return obs  # Successfully initialized, return the observation
+++++-+
+++++- 
+++++-     def append_step_info(self):
+++++-         """
+++++-@@ -1231,6 +1297,8 @@ class Env:
+++++- class NormEnv(gym.Env):
+++++-     """
+++++-     Reward normalization with running average https://github.com/joschu/modular_rl
+++++-+    self.c: Ring parameters 
+++++-+    self.env: RingEnv class
+++++-     """
+++++-     def __init__(self, c, env):
+++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
+++++++                
++++++                 continue  # If reset_sumo fails, retry the loop
++++++             
++++++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++++ diff --git a/exp.py b/exp.py
+++++-index ead4652..7f7cee5 100644
++++++index 7f7cee5..6f16d66 100644
+++++ --- a/exp.py
+++++ +++ b/exp.py
+++++-@@ -169,9 +169,9 @@ class Main(Config):
+++++- 
+++++-     def on_train_start(c):
+++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
+++++--        c.setdefaults(alg='Algorithm')
+++++--        c._env = c.create_env()
+++++--
+++++-+        c.setdefaults(alg='Algorithm') 
+++++-+        c._env = c.create_env() # Create NormEnv
+++++-+ 
+++++-         # Instantiate the algorithm (e.g., PPO, DQN)
+++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
+++++-         c.set_model()
+++++-@@ -222,8 +222,8 @@ class Main(Config):
+++++- 
+++++-     def on_step_start(c, stats={}):
+++++-         # Update the learning rate and log stats at the start of a training step
+++++--        lr = c._lr
+++++--        for g in c._opt.param_groups:
+++++-+        lr = c._lr # Update Learning Rate
+++++-+        for g in c._opt.param_groups: # Log Statistics
+++++-             g['lr'] = float(lr)
+++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
+++++- 
+++++-@@ -285,10 +285,14 @@ class Main(Config):
++++++@@ -285,7 +285,6 @@ class Main(Config):
+++++              ret = dict(obs=ret)
+++++          rollout = NamedArrays()
+++++          rollout.append(**ret)
+++++--
+++++-+        rollout_flow_each_step = []
++++++-        rollout_flow_each_step = []
+++++          done = False
+++++          a_space = c.action_space
+++++          step = 0
++++++@@ -406,9 +405,8 @@ class Main(Config):
++++++ 
++++++     def train(c):
++++++         # Main training loop
++++++-        c.on_train_start()
+++++++        c.on_train_start() # Ring Env
++++++         while c._i < c.n_steps:
++++++-            c.on_step_start() # save stat 
++++++             with torch.no_grad():
++++++                 # Collect rollouts without computing gradients
++++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++@@ -497,3 +495,32 @@ class Main(Config):
++++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
++++++             c.train()
++++++         c.log('job done!')
+++++++
+++++++    def run_2(c):
+++++++        # Determine whether to train or evaluate based on configuration
+++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
+++++++        
+++++++        c.on_train_start()
+++++++        c._env = c.create_env() # Create NormEnv
+++++++        ret = c._env.reset()
+++++++        c.set_model()
+++++++        step = 0
+++++ +        density = 20/(250*1e-3)
+++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
+++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+++++-+
+++++-         while step < c.horizon + c.skip_stat_steps and not done:
+++++-             # Generate an action from the model's policy
+++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
+++++-@@ -309,6 +313,12 @@ class Main(Config):
+++++-             rollout.append(**ret)
+++++-             step += 1
+++++-         # Collect stats from the environment
+++++++        done = False
+++++++        while step < c.horizon + c.skip_stat_steps and not done:
+++++++            # Take a step in the environment
+++++++            ret = c._env.step()
+++++++            if isinstance(ret, tuple):
+++++++                obs, reward, done, info = ret
+++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
+++++++            done = ret.setdefault('done', False)
+++++++            step += 1
+++++++        # Collect stats from the environment
+++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+++++ +        density = 20/(250 * 1e-3)
+++++ +        vehicle_flow = c._env.mean_speed * density 
+++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+++++-+
+++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
+++++-         return rollout, stats
+++++- 
+++++-@@ -398,10 +408,10 @@ class Main(Config):
+++++-         # Main training loop
+++++-         c.on_train_start()
+++++-         while c._i < c.n_steps:
+++++--            c.on_step_start()
+++++-+            c.on_step_start() # save stat 
+++++-             with torch.no_grad():
+++++-                 # Collect rollouts without computing gradients
+++++--                rollouts = c.rollouts()
+++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++-             gd_stats = {}
+++++-             if len(rollouts.obs):
+++++-                 t_start = time()
+++++-@@ -410,7 +420,7 @@ class Main(Config):
+++++-                 gd_stats.update(gd_time=time() - t_start)
+++++-             c.on_step_end(gd_stats)
+++++-             c._i += 1
+++++--        c.on_step_start()  # last step
+++++-+        c.on_step_start()  # save stat
+++++-         gd_stats = {}
+++++-         with torch.no_grad():
+++++-             rollouts = c.rollouts()
+++++-@@ -450,6 +460,8 @@ class Main(Config):
+++++-         if hasattr(c._env, 'close'):
+++++-             c._env.close()
+++++- 
+++++-+  
+++++-+
+++++-     def run(c):
+++++-         # Determine whether to train or evaluate based on configuration
+++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++-diff --git a/ring.py b/ring.py
+++++-index 94d632d..ee1372b 100644
+++++---- a/ring.py
+++++-+++ b/ring.py
+++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
+++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++-         )
++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
++++++deleted file mode 100644
++++++index 6b9ba52..0000000
++++++--- a/highway_bottleneck.py
+++++++++ /dev/null
++++++@@ -1,381 +0,0 @@
++++++-from automatic_vehicular_control.exp import *
++++++-from automatic_vehicular_control.env import *
++++++-from automatic_vehicular_control.u import *
+++++ -
+++++-         # Function to generate the shape of the edges (circular arcs)
+++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++++- 
+++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
+++++-         if c.circumference_range:  # Check if the circumference should be randomized
+++++-             # Randomly set the circumference within the specified range
+++++-             c.circumference = np.random.randint(*c.circumference_range)
+++++-+        
+++++-+        if self.flow_log:
+++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
+++++-+            self.episode_flow.append(average_flow)
+++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
+++++-+        
+++++-+        # Reset flow counters for the new episode
+++++-+        self.flow_counter = 0
+++++-+        self.flow_log = []
+++++-+        self.last_vehicle_times = {}
+++++-+        
+++++-         return super().reset_sumo()  # Reset the simulation
++++++-class BNeckEnv(Env):
++++++-    def def_sumo(self):
++++++-        c = self.c
++++++-        nodes = E('nodes',
++++++-            E('node', id='n_0', x=0, y=0), *(
++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
++++++-        ))
++++++-        edges = E('edges', *(
++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
++++++-                'numLanes': n_lane,
++++++-                'speed': c.max_speed
++++++-            }) for i, n_lane in enumerate(c.n_lanes)
++++++-        ))
++++++-        connections = E('connections', *(
++++++-            E('connection', **{
++++++-                'from': prev.id,
++++++-                'to': curr.id,
++++++-                'fromLane': i,
++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
++++++-        ))
++++++-
++++++-        if c.split_flow:
++++++-            n_inflow_lanes = c.n_lanes[0]
++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
++++++-                for i in range(n_inflow_lanes)
++++++-            ]
++++++-        else:
++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
++++++-            ]
++++++-        routes = E('routes',
++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
++++++-            *flows
++++++-        )
++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
++++++-        additional = E('additional',
++++++-            E('vType', id='generic', **idm_params),
++++++-            E('vType', id='rl', **idm_params),
++++++-            E('vType', id='human', **idm_params),
++++++-        )
++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++-
++++++-    def reset_sumo(self):
++++++-        c = self.c
++++++-        if c.flow_rate_range:
++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
++++++-        ret = super().reset_sumo()
++++++-        if c.vinitsky:
++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
++++++-                for i_start in range(round(edge.length) // c.piece_length)
++++++-                for lane in edge.lanes
++++++-            ]
++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
++++++-            self.last_outflows = []
++++++-        return ret
++++++-
++++++-    def step(self, action=[]):
++++++-        c = self.c
++++++-        ts = self.ts
++++++-        max_dist = 100
++++++-        max_speed = c.max_speed
++++++-        human_type = ts.types.human
++++++-        rl_type = ts.types.rl
++++++-
++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++-        if c.vinitsky:
++++++-            if len(action):
++++++-                assert len(action) == len(self.control_lanes)
++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
++++++-                    self.control_lanes[lane, piece_start] = np.clip(
++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
++++++-                        0.1, max_speed
++++++-                    )
++++++-                for veh in prev_rls:
++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
++++++-        else:
++++++-            for veh, act in zip(prev_rls, action):
++++++-                if c.handcraft:
++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
++++++-                    next_lane = lane.next(veh.route)
++++++-                    level = 1
++++++-                    if next_lane and next_lane.get('junction'):
++++++-                        merge_dist = lane.length - veh.laneposition
++++++-                        if merge_dist < c.handcraft:
++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
++++++-                                level = 0
++++++-                    if c.act_type.startswith('accel'):
++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++-                    else:
++++++-                        ts.set_max_speed(veh, max_speed * level)
++++++-                    continue
++++++-                if not isinstance(act, (int, np.integer)):
++++++-                    act = (act - c.low) / (1 - c.low)
++++++-                if c.act_type.startswith('accel'):
++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++-                else:
++++++-                    if c.act_type == 'continuous':
++++++-                        level = act[0]
++++++-                    elif c.act_type == 'discretize':
++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++-                    elif c.act_type == 'discrete':
++++++-                        level = act / (c.n_actions - 1)
++++++-                    ts.set_max_speed(veh, max_speed * level)
++++++-
++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
++++++-
++++++-        super().step()
++++++-
++++++-        if c.vinitsky:
++++++-            n_last_outflows = 20
++++++-            max_vehs = 4
++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
++++++-            obs = []
++++++-            for lane, piece_start in self.obs_lanes:
++++++-                piece_end = piece_start + c.piece_length
++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
++++++-                obs.extend([
++++++-                    len(lane_humans) / max_vehs,
++++++-                    len(lane_avs) / max_vehs,
++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
++++++-                ])
++++++-            if len(self.last_outflows) == n_last_outflows:
++++++-                self.last_outflows = self.last_outflows[1:]
++++++-            self.last_outflows.append(len(ts.new_arrived))
++++++-            reward = np.mean(self.last_outflows)
++++++-            obs.append(reward / max_veh_outflows)
++++++-            obs = np.array(obs, dtype=np.float32)
++++++-            assert 0 <= obs.min() and obs.max() <= 1
++++++-            return obs, reward, False, None
++++++-        route = nexti(ts.routes)
++++++-        obs, ids = [], []
++++++-        default_close = [0, max_speed]
++++++-        default_far = [max_dist, 0]
++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++-            merge_dist = max_dist
++++++-            default_human = default_far
++++++-
++++++-            other_info = {}
++++++-            next_lane = lane.next(veh.route)
++++++-            if next_lane and next_lane.get('junction'):
++++++-                merge_dist = lane.length - veh.laneposition
++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
++++++-                # Look for veh on other lane but do not extend past that lane
++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
++++++-                    if other_veh.type is rl_type:
++++++-                        default_human = default_close
++++++-                        break
++++++-
++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
++++++-            ids.append(veh.id)
++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++-        
++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++-
++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++-        drac = np.clip(drac/10, -1, 1)
++++++-
++++++-        raw_pet = self.calc_pet()
++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++-        pet = np.clip(pet, -1, 1)
++++++-
++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++-        
++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++-        return returned
++++++-        
++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++-    
++++++-    def calc_ttc(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        ttcs = []
++++++-        for v in cur_veh_list:
++++++-            leader, headway = v.leader()
++++++-            v_speed = v.speed
++++++-            leader_speed = leader.speed
++++++-            if leader_speed < v_speed:
++++++-                ttc =  headway/(v_speed-leader_speed)
++++++-            else:
++++++-                ttc = np.nan
++++++-            ttcs.append(ttc)
++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++-        return fleet_ttc
++++++-    
++++++-    def calc_drac(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        dracs = []
++++++-        for v in cur_veh_list:
++++++-            leader, headway = v.leader()
++++++-            v_speed = v.speed
++++++-            leader_speed = leader.speed
++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++-            dracs.append(drac)
++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++-        return fleet_drac
++++++-
++++++-    def calc_pet(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        pets = []
++++++-        for v in cur_veh_list:
++++++-            leader, headway = v.leader()
++++++-            v_speed = v.speed
++++++-            if v_speed > 1e-16:
++++++-                pet = headway/(v_speed)
++++++-                pets.append(pet)
++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++-        return fleet_pet
++++++-
++++++-class BNeck(Main):
++++++-    def create_env(c):
++++++-        return BNeckEnv(c)
++++++-
++++++-    @property
++++++-    def observation_space(c):
++++++-        low = np.full(c._n_obs, c.low)
++++++-        return Box(low, np.ones_like(low))
++++++-
++++++-    @property
++++++-    def action_space(c):
++++++-        if c.vinitsky:
++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++-            assert c.lc_av in [False, 'binary']
++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++-            return Discrete(c.n_actions)
++++++-
++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++-        if c.vinitsky:
++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
++++++-        log = c.get_log_ii(ii, n_ii)
++++++-        step_obs_ = rollout.obs
++++++-        step_obs = step_obs_[:-1]
++++++-
++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++-
++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++-
++++++-        step_id_ = rollout.pop('id')
++++++-        id = np.concatenate(step_id_[:-1])
++++++-        id_unique = np.unique(id)
++++++-
++++++-        reward = np.array(rollout.pop('reward'))
++++++-
++++++-        log(**stats)
++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++-        log(
++++++-            n_veh_step_mean=n_veh.mean(), 
++++++-            n_veh_step_sum=n_veh.sum(), 
++++++-            n_veh_unique=len(id_unique),
++++++-            
++++++-            reward_mean=np.mean(reward),
++++++-            reward_std=np.std(reward),        
++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++-            ssm_mean=np.mean(rollout.ssm),
++++++-            ssm_std=np.std(rollout.ssm),
++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++-
++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++-            # nom_action = np.mean(rollout.nom_action),
++++++-            # res_action = np.mean(rollout.res_action),
++++++-            )
++++++-        return rollout
++++++-
++++++-if __name__ == '__main__':
++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
++++++-        warmup_steps=1000,
++++++-        horizon=2000,
++++++-        n_steps=100,
++++++-        step_save=5,
++++++-
++++++-        av_frac=0.2,
++++++-        sim_step=0.5,
++++++-        depart_speed=0,
++++++-        edge_lengths=[100, 100, 50],
++++++-        n_lanes=[4, 2, 1],
++++++-        max_speed=30,
++++++-
++++++-        lc_av=False,
++++++-        flow_rate=2300,
++++++-        flow_rate_range=None,
++++++-        split_flow=True,
++++++-        generic_type='rand',
++++++-        speed_mode=SPEED_MODE.all_checks,
++++++-        lc_mode=LC_MODE.off,
++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++-
++++++-        veh_junction=False,
++++++-        act_type='accel_discrete',
++++++-        max_accel=2.6,
++++++-        max_decel=4.5,
++++++-        tau=1.0,
++++++-        min_gap=2.5,
++++++-        delta=4,
++++++-        n_actions=3,
++++++-        low=-1,
++++++-        handcraft=False,
++++++-        vinitsky=False,
++++++-
++++++-        render=False,
++++++-
++++++-        alg=PG,
++++++-        lr=1e-3,
++++++-
++++++-        gamma=0.99,
++++++-        adv_norm=False,
++++++-        batch_concat=True,
++++++-
++++++-        beta=0,
++++++-        scale_ttc=1,
++++++-        scale_drac=1,
++++++-        seed_np=False,
++++++-        seed_torch = False,
++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++-
++++++-    )
++++++-    
++++++-    if c.seed_torch:
++++++-        # Set seed for PyTorch CPU operations
++++++-        torch.manual_seed(c.seed_torch)
++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++-        if torch.cuda.is_available():
++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++-    if c.seed_np:
++++++-        np.random.seed(c.seed_np)
++++++-        
++++++-    if c.vinitsky:
++++++-        c.piece_length = 20
++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
++++++-        c._n_action = sum(n_actions[:-1])
++++++-        c._n_obs = sum(n_actions) * 4 + 1
++++++-        c.batch_concat = False
++++++-    else:
++++++-        c._n_obs = 2 + 2 + 2
++++++-        
++++++-    if c.mrtl:
++++++-        c._n_obs += 1 # modified for mrtl related
++++++-        
++++++-    c.redef_sumo = bool(c.flow_rate_range)
++++++-    c.run()
++++++\ No newline at end of file
++++++diff --git a/highway_ramp.py b/highway_ramp.py
++++++deleted file mode 100644
++++++index ef0358f..0000000
++++++--- a/highway_ramp.py
+++++++++ /dev/null
++++++@@ -1,325 +0,0 @@
++++++-from automatic_vehicular_control.exp import *
++++++-from automatic_vehicular_control.env import *
++++++-from automatic_vehicular_control.u import *
++++++-
++++++-class RampEnv(Env):
++++++-    # https://flow-project.github.io/papers/08569485.pdf
++++++-    def def_sumo(self):
++++++-        c = self.c
++++++-        builder = NetBuilder()
++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
++++++-            (0, 0),
++++++-            (c.premerge_distance, 0),
++++++-            (c.premerge_distance + c.merge_distance, 0),
++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
++++++-        ])
++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
++++++-            {}, {'numLanes': 2}, {}
++++++-        ], lane_maps=[
++++++-            {0: 1}, {0: 0, 1: 0}
++++++-        ], route_id='highway')
++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
++++++-            {}, {'numLanes': 2}, {}
++++++-        ], lane_maps=[
++++++-            {0: 0}, {0: 0, 1: 0}
++++++-        ], route_id='ramp')
++++++-        nodes, edges, connections, routes = builder.build()
++++++-        nodes[2].type = 'zipper'
++++++-
++++++-        routes = E('routes',
++++++-            *routes,
++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
++++++-        )
++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
++++++-        additional = E('additional',
++++++-            E('vType', id='generic', **idm),
++++++-            E('vType', id='rl', **idm),
++++++-            E('vType', id='human', **idm),
++++++-        )
++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++-
++++++-    def step(self, action=[]):
++++++-        c = self.c
++++++-        ts = self.ts
++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
++++++-        max_speed = c.max_speed
++++++-        human_type = ts.types.human
++++++-        rl_type = ts.types.rl
++++++-
++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++-        for rl, act in zip(prev_rls, action):
++++++-            if c.handcraft:
++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
++++++-                leader, dist = rl.leader()
++++++-                level = 1
++++++-                if edge.id == 'e_n_0.0_n_400.0':
++++++-                    if rl.laneposition < 100:
++++++-                        leaders = list(rl.leaders())
++++++-                        if len(leaders) > 20:
++++++-                            level = 0
++++++-                        else:
++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++-                continue
++++++-            if not isinstance(act, (int, np.integer)):
++++++-                act = (act - c.low) / (1 - c.low)
++++++-            if c.act_type.startswith('accel'):
++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++-            else:
++++++-                if c.act_type == 'continuous':
++++++-                    level = act[0]
++++++-                elif c.act_type == 'discretize':
++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++-                elif c.act_type == 'discrete':
++++++-                    level = act / (c.n_actions - 1)
++++++-                ts.set_max_speed(rl, max_speed * level)
++++++-
++++++-        super().step()
++++++-
++++++-        route = ts.routes.highway
++++++-        obs, ids = [], []
++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++-            if hasattr(veh, 'edge'):
++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++-                merge_dist = max_dist
++++++-
++++++-                lead_speed = follow_speed = other_speed = 0
++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
++++++-
++++++-                leader, dist = veh.leader()
++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
++++++-
++++++-                follower, dist = veh.follower()
++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
++++++-
++++++-                if c.global_obs:
++++++-                    jun_edge = edge.next(route)
++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
++++++-                        jun_edge = jun_edge.next(route)
++++++-                    if jun_edge:
++++++-                        merge_dist = lane.length - veh.laneposition
++++++-                        next_edge = edge.next(route)
++++++-                        while next_edge is not jun_edge:
++++++-                            merge_dist += next_edge.length
++++++-                            next_edge = next_edge.next(route)
++++++-
++++++-                        other_lane = jun_edge.lanes[0]
++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
++++++-                            other_speed = other_veh.speed
++++++-                            break
++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
++++++-                else:
++++++-                    next_lane = lane.next(route)
++++++-                    if next_lane and next_lane.get('junction'):
++++++-                        if len(edge.lanes) == 2:
++++++-                            other_lane = edge.lanes[0]
++++++-                            pos = veh.laneposition
++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
++++++-                                other_speed = other_veh.speed
++++++-                                break
++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
++++++-                ids.append(veh.id)
++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
++++++-        if c.mrtl:
++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++-        
++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++-
++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++-        drac = np.clip(drac/10, -1, 1)
++++++-
++++++-        raw_pet = self.calc_pet()
++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++-        pet = np.clip(pet, -1, 1)
++++++-
++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++-        
++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++-        return returned
++++++-        
++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++-    
++++++-    def calc_ttc(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        ttcs = []
++++++-        for v in cur_veh_list:
++++++-            if hasattr(v, 'edge'):
++++++-                leader, headway = v.leader()
++++++-                if leader:
++++++-                    v_speed = v.speed
++++++-                    leader_speed = leader.speed
++++++-                    if leader_speed < v_speed:
++++++-                        ttc =  headway/(v_speed-leader_speed)
++++++-                    else:
++++++-                        ttc = np.nan
++++++-                    ttcs.append(ttc)
++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++-        return fleet_ttc
++++++-    
++++++-    def calc_drac(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        dracs = []
++++++-        for v in cur_veh_list:
++++++-            if hasattr(v, 'edge'):
++++++-                leader, headway = v.leader()
++++++-                if leader:
++++++-                    v_speed = v.speed
++++++-                    leader_speed = leader.speed
++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++-                    dracs.append(drac)
++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++-        return fleet_drac
++++++-
++++++-    def calc_pet(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        pets = []
++++++-        for v in cur_veh_list:
++++++-            if hasattr(v, 'edge'):
++++++-                leader, headway = v.leader()
++++++-                if leader:
++++++-                    v_speed = v.speed
++++++-                    if v_speed > 1e-16:
++++++-                        pet = headway/(v_speed)
++++++-                        pets.append(pet)
++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
++++++-        return fleet_pet
++++++-
++++++-class Ramp(Main):
++++++-    def create_env(c):
++++++-        return RampEnv(c)
++++++-
++++++-    @property
++++++-    def observation_space(c):
++++++-        low = np.full(c._n_obs, c.low)
++++++-        return Box(low, np.ones_like(low))
++++++-
++++++-    @property
++++++-    def action_space(c):
++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++-            return Discrete(c.n_actions)
++++++-
++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++-        log = c.get_log_ii(ii, n_ii)
++++++-        step_obs_ = rollout.obs
++++++-        step_obs = step_obs_[:-1]
++++++-
++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++-
++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++-
++++++-        step_id_ = rollout.pop('id')
++++++-        id = np.concatenate(step_id_[:-1])
++++++-        id_unique = np.unique(id)
++++++-
++++++-        reward = np.array(rollout.pop('reward'))
++++++-
++++++-        log(**stats)
++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++-        log(
++++++-            n_veh_step_mean=n_veh.mean(), 
++++++-            n_veh_step_sum=n_veh.sum(), 
++++++-            n_veh_unique=len(id_unique),
++++++-            
++++++-            reward_mean=np.mean(reward),
++++++-            reward_std=np.std(reward),        
++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++-            ssm_mean=np.mean(rollout.ssm),
++++++-            ssm_std=np.std(rollout.ssm),
++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++-
++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++-            # nom_action = np.mean(rollout.nom_action),
++++++-            # res_action = np.mean(rollout.res_action),
++++++-            )
++++++-        return rollout
++++++-
++++++-if __name__ == '__main__':
++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
++++++-        warmup_steps=100,
++++++-        horizon=2000,
++++++-        n_steps=100,
++++++-        step_save=5,
++++++-
++++++-        premerge_distance=400,
++++++-        merge_distance=100,
++++++-        postmerge_distance=30,
++++++-        av_frac=0.1,
++++++-        sim_step=0.5,
++++++-        max_speed=30,
++++++-        highway_depart_speed=10,
++++++-        ramp_depart_speed=0,
++++++-        highway_flow_rate=2000,
++++++-        ramp_flow_rate=300,
++++++-        global_obs=False,
++++++-        handcraft=False,
++++++-
++++++-        generic_type='default',
++++++-        speed_mode=SPEED_MODE.all_checks,
++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++-
++++++-        act_type='accel_discrete',
++++++-        max_accel=1,
++++++-        max_decel=1.5,
++++++-        n_actions=3,
++++++-        low=-1,
++++++-
++++++-        render=False,
++++++-
++++++-        alg=PG,
++++++-        lr=1e-3,
++++++-
++++++-        gamma=0.99,
++++++-        adv_norm=False,
++++++-        batch_concat=True,
++++++-
++++++-        beta=0,
++++++-        scale_ttc=1,
++++++-        scale_drac=1,
++++++-        seed_np=False,
++++++-        seed_torch = False,
++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++-
++++++-    )
++++++-    
++++++-    if c.seed_torch:
++++++-        # Set seed for PyTorch CPU operations
++++++-        torch.manual_seed(c.seed_torch)
++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++-        if torch.cuda.is_available():
++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++-    if c.seed_np:
++++++-        np.random.seed(c.seed_np)
++++++-        
++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
++++++-    if c.mrtl:
++++++-        c._n_obs += 1 # modified for mrtl related
++++++-    c.run()
++++++\ No newline at end of file
++++++diff --git a/intersection.py b/intersection.py
++++++deleted file mode 100644
++++++index e38a84f..0000000
++++++--- a/intersection.py
+++++++++ /dev/null
++++++@@ -1,489 +0,0 @@
++++++-from automatic_vehicular_control.u import *
++++++-from automatic_vehicular_control.exp import *
++++++-from automatic_vehicular_control.env import *
++++++-
++++++-class Platoon(Entity):
++++++-    pass
++++++-
++++++-class IntersectionEnv(Env):
++++++-    def def_sumo(self):
++++++-        c = self.c
++++++-
++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
++++++-        ] if params.get('vehsPerHour')]
++++++-
++++++-        builder = NetBuilder()
++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
++++++-        if c.enter_length:
++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++-            xys[1:, :, 0] += c.enter_length - c.length
++++++-            xys[:, 1:, 1] += c.enter_length - c.length
++++++-            xys = xys.reshape(-1, 2)
++++++-        if c.short_exit:
++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++-            xys[-1, :, 0] += c.short_exit - c.length
++++++-            xys[:, -1, 1] += c.short_exit - c.length
++++++-            xys = xys.reshape(-1, 2)
++++++-        nodes = builder.add_nodes(
++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
++++++-        # import pdb; pdb.set_trace()
++++++-
++++++-        tl = c.setdefault('tl', False)
++++++-        if tl:
++++++-            c.av_frac = 0
++++++-            c.pop('av_range', None)
++++++-            c.speed_mode = SPEED_MODE.all_checks
++++++-
++++++-        flows = []
++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
++++++-        for direction in c.directions:
++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
++++++-
++++++-            edge_attrs = dict(priority=int(direction in priority))
++++++-            if c.get('set_edge_speed', True):
++++++-                edge_attrs['speed'] = c.max_speed
++++++-
++++++-            for i, chain in enumerate(chains[1:-1]):
++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
++++++-
++++++-        tls = []
++++++-        if tl:
++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
++++++-            tl_offset = c.get('tl_offset', 'auto')
++++++-            yellow = c.get('yellow', 0.5)
++++++-            if tl_offset == 'auto':
++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
++++++-            elif tl_offset == 'same':
++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
++++++-                node.type = 'traffic_light'
++++++-                phase_multiple = len(c.directions) // 2
++++++-                tls.append(E('tlLogic',
++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
++++++-                id=node.id, offset=offset, type='static', programID='1'))
++++++-
++++++-        nodes, edges, connections, routes = builder.build()
++++++-        additional = E('additional', *types, *routes, *flows, *tls)
++++++-        return super().def_sumo(nodes, edges, connections, additional)
++++++-
++++++-    def build_platoon(self):
++++++-        ts = self.ts
++++++-        rl_type = ts.types.rl
++++++-        for route in ts.routes:
++++++-            vehs = []
++++++-            route_offset = 0
++++++-            for edge in route.edges:
++++++-                for veh in edge.vehicles:
++++++-                    veh.route_position = route_offset + veh.laneposition
++++++-                    vehs.append(veh)
++++++-                route_offset += edge.length
++++++-
++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
++++++-            rl_idxs, = rl_mask.nonzero()
++++++-            split_idxs = 1 + rl_idxs
++++++-
++++++-            prev = None
++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
++++++-                if not len(vehs_i):
++++++-                    continue # Last vehicle is RL, so the last split is empty
++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
++++++-                )
++++++-                if prev is not None:
++++++-                    prev.next = platoon
++++++-                prev = platoon
++++++-                for veh in vehs_i:
++++++-                    veh.platoon = platoon
++++++-            if prev is not None:
++++++-                prev.next = None
++++++-
++++++-    def reset(self):
++++++-        c = self.c
++++++-        if c.e is False:
++++++-            if 'length_range' in c:
++++++-                min_, max_ = c.length_range
++++++-                c.setdefaults(max_length=max_)
++++++-                c.length = np.random.randint(min_, max_ + 1)
++++++-            if 'av_range' in c:
++++++-                min_, max_ = c.av_range
++++++-                c.av_frac = np.random.uniform(min_, max_)
++++++-        self.mp_tlast = 0
++++++-        while not self.reset_sumo():
++++++-            pass
++++++-        ret = super().init_env()
++++++-        return ret
++++++-
++++++-    def step(self, action=[]):
++++++-        c = self.c
++++++-        ts = self.ts
++++++-        max_dist = c.max_dist
++++++-        depart_speed = c.depart_speed
++++++-        max_speed = c.max_speed
++++++-
++++++-        rl_type = ts.types.rl
++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++-
++++++-        for rl, act in zip(prev_rls, action):
++++++-            if c.handcraft or c.handcraft_tl:
++++++-                route, lane = rl.route, rl.lane
++++++-                junction = lane.next_junction
++++++-                level = 1
++++++-                if junction is not ts.sentinel_junction:
++++++-                    dist = junction.route_position[route] - rl.route_position
++++++-                    if c.handcraft:
++++++-                        for cross_lane in lane.next_cross_lanes:
++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
++++++-                    elif c.handcraft_tl and dist < 15:
++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
++++++-                        yellow_time = 0
++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
++++++-                        horizontal_go = 0 <= rem < t_h
++++++-                        vertical_go = t_h + yellow_time <= rem
++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
++++++-                        human_remain = False
++++++-                        for cross_lane in lane.next_cross_lanes:
++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
++++++-            elif c.act_type == 'accel':
++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
++++++-            else:
++++++-                level = act / (c.n_actions - 1)
++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++-
++++++-        if c.tl == 'MaxPressure':
++++++-            self.mp_tlast += c.sim_step
++++++-            tmin = c.get('mp_tmin', 0)
++++++-            if self.mp_tlast >= tmin:
++++++-                for tl in ts.traffic_lights:
++++++-                    if ts.get_program(tl) == 'off':
++++++-                        break
++++++-                    jun = tl.junction
++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
++++++-
++++++-                    total_pressures = []
++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
++++++-
++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
++++++-                self.mp_tlast = 0
++++++-
++++++-        super().step()
++++++-        self.build_platoon()
++++++-
++++++-        obs = {}
++++++-
++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
++++++-        for veh in rl_type.vehicles:
++++++-            if hasattr(veh, 'lane'):
++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
++++++-                junction = lane.next_junction
++++++-
++++++-                head, tail = veh, platoon.tail
++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
++++++-
++++++-                if junction is ts.sentinel_junction:
++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
++++++-                else:
++++++-                    for jun_lane in lane.next_junction_lanes:
++++++-                        # Defaults for jun_lane
++++++-                        jun_headtails = vehs_default()
++++++-
++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
++++++-
++++++-                        if jun_veh:
++++++-                            if jun_veh.type is rl_type:
++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
++++++-                                platoon = jun_veh.platoon.prev
++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++-                                    if platoon is None: break
++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++-                                    platoon = platoon.prev
++++++-                            else:
++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
++++++-                                jun_headtails[0] = jun_veh.platoon.tail
++++++-                                next_cross_platoon = jun_veh.platoon.prev
++++++-                                if next_cross_platoon:
++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
++++++-                                    platoon = next_cross_platoon.prev
++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++-                                        if platoon is None: break
++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++-                                        platoon = platoon.prev
++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
++++++-
++++++-                dist_features, speed_features = [], []
++++++-                for route, vehs in route_vehs:
++++++-                    j_pos = junction.route_position[route]
++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
++++++-
++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++-
++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
++++++-        ids = sorted(obs)
++++++-        if c.mrtl:
++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
++++++-        if c.rew_type == 'outflow':
++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++-        elif c.rew_type == 'time_penalty':
++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
++++++-        
++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++-
++++++-        raw_drac = self.calc_drac()
++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++-        drac = np.clip(drac/10, -1, 1)
++++++-        raw_pet = self.calc_pet()
++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++-        pet = np.clip(pet/6, -1, 1)
++++++-
++++++-        raw_ttc = self.calc_ttc()
++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++-
++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++-
++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++-        return returned
++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++-        
++++++-    def calc_drac(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        dracs = []
++++++-        for v in cur_veh_list:
++++++-            if hasattr(v, 'lane'):
++++++-                leader, headway = v.leader()
++++++-                v_speed = v.speed
++++++-                leader_speed = leader.speed
++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++-                dracs.append(drac)
++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++-        return fleet_drac
++++++-    
++++++-    def calc_pet(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        pets = []
++++++-        for v in cur_veh_list:
++++++-            if hasattr(v, 'lane'):
++++++-                leader, headway = v.leader()
++++++-                v_speed = v.speed
++++++-                if v_speed > 1e-16:
++++++-                    pet = headway/(v_speed)
++++++-                    pets.append(pet)
++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++-        return fleet_pet
++++++-
++++++-    def calc_ttc(self):
++++++-        cur_veh_list = self.ts.vehicles
++++++-        ttcs = []
++++++-        for v in cur_veh_list:
++++++-            if hasattr(v, 'lane'):
++++++-                leader, headway = v.leader()
++++++-                v_speed = v.speed
++++++-                leader_speed = leader.speed
++++++-                if leader_speed < v_speed:
++++++-                    ttc =  headway/(v_speed-leader_speed)
++++++-                else:
++++++-                    ttc = np.nan
++++++-                ttcs.append(ttc)
++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++-        return fleet_ttc
++++++-
++++++-    def append_step_info(self):
++++++-        super().append_step_info()
++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
++++++-
++++++-    @property
++++++-    def stats(self):
++++++-        c = self.c
++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
++++++-        stats['backlog_step'] = mean(info['backlog'])
++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
++++++-
++++++-        stats['beta'] = c.beta
++++++-
++++++-        if c.multi_flowrate:
++++++-            stats['flow_horizontal'] = c.flow_rate_h
++++++-            stats['flow_vertical'] = c.flow_rate_v
++++++-        return stats
++++++-
++++++-class Intersection(Main):
++++++-    def create_env(c):
++++++-        if c.multi_flowrate:
++++++-            return NormEnv(c, IntersectionEnv(c))
++++++-        else:
++++++-            c._norm = NormEnv(c, None)
++++++-            return IntersectionEnv(c)
++++++-
++++++-    @property
++++++-    def observation_space(c):
++++++-        low = np.full(c._n_obs, c.low)
++++++-        return Box(low, np.ones_like(low))
++++++-
++++++-    @property
++++++-    def action_space(c):
++++++-        if c.act_type == 'accel':
++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++-        else:
++++++-            return Discrete(c.n_actions)
++++++-
++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++-        log = c.get_log_ii(ii, n_ii)
++++++-        step_obs_ = rollout.obs
++++++-        step_obs = step_obs_[:-1]
++++++-
++++++-        if not c.multi_flowrate:
++++++-            rollout.raw_reward = rollout.reward
++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
++++++-
++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++-
++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++-
++++++-        step_id_ = rollout.pop('id')
++++++-        id = np.concatenate(step_id_[:-1])
++++++-        id_unique = np.unique(id)
++++++-
++++++-        reward = np.array(rollout.pop('reward'))
++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
++++++-
++++++-        log(**stats)
++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++-        log(
++++++-            n_veh_step_mean=n_veh.mean(), 
++++++-            n_veh_step_sum=n_veh.sum(), 
++++++-            n_veh_unique=len(id_unique),
++++++-            
++++++-            reward_mean=np.mean(reward),
++++++-            reward_std=np.std(reward),        
++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++-            ssm_mean=np.mean(rollout.ssm),
++++++-            ssm_std=np.std(rollout.ssm),
++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++-
++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++-            # nom_action = np.mean(rollout.nom_action),
++++++-            # res_action = np.mean(rollout.res_action),
++++++-            )
++++++-        
++++++-        return rollout
++++++-
++++++-if __name__ == '__main__':
++++++-    c = Intersection.from_args(globals(), locals())
++++++-    c.setdefaults(
++++++-        n_steps=200,
++++++-        step_save=5,
++++++-
++++++-        depart_speed=0,
++++++-        max_speed=13,
++++++-        max_dist=100,
++++++-        max_accel=1.5,
++++++-        max_decel=3.5,
++++++-        sim_step=0.5,
++++++-        generic_type=True,
++++++-        n_actions=3,
++++++-
++++++-        adv_norm=False,
++++++-        batch_concat=True,
++++++-
++++++-        render=False,
++++++-
++++++-        warmup_steps=100,
++++++-        horizon=2000,
++++++-        directions='4way',
++++++-        av_frac=0.15,
++++++-        handcraft=False,
++++++-        handcraft_tl=None,
++++++-        flow_rate=700,
++++++-        length=100,
++++++-        n_rows=1,
++++++-        n_cols=1,
++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
++++++-
++++++-        act_type='accel_discrete',
++++++-        low=-1,
++++++-
++++++-        alg=PG,
++++++-        n_gds=1,
++++++-        lr=1e-3,
++++++-        gamma=0.99,
++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++-
++++++-        enter_length=False,
++++++-        short_exit=False,
++++++-
++++++-        rew_type='outflow',
++++++-        norm_reward=True,
++++++-        center_reward=True,
++++++-        multi_flowrate=False,
++++++-        opt='RMSprop',
++++++-
++++++-        obs_tail=True,
++++++-        obs_next_cross_platoons=1,
++++++-
++++++-        beta=0,
++++++-        scale_pet=1,
++++++-        scale_drac=1,
++++++-        seed_np=False,
++++++-        seed_torch = False,
++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++-    )
++++++-
++++++-    if c.seed_torch:
++++++-        # Set seed for PyTorch CPU operations
++++++-        torch.manual_seed(c.seed_torch)
++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++-        if torch.cuda.is_available():
++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++-    if c.seed_np:
++++++-        np.random.seed(c.seed_np)
++++++-
++++++-    if c.directions == '4way':
++++++-        c.directions = ['up', 'right', 'down', 'left']
++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
++++++-    if c.mrtl:
++++++-        c._n_obs += 1
++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
++++++-    c.redef_sumo = 'length_range' in c
++++++-    c.run()
++++++\ No newline at end of file
++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++index d4c3dac..2ab8505 100644
++++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++@@ -1,600 +1,14009 @@
++++++-diff --git a/README.md b/README.md
++++++-index b591747..127f484 100644
++++++---- a/README.md
++++++-+++ b/README.md
++++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
++++++- ### 1.2 Set the environmental variables
++++++- ```
++++++- # Code directory
++++++--export F=automatic_vehicular_control/automatic_vehicular_control
++++++-+export F=automatic_vehicular_control
++++++- 
++++++- # Results directory extracted from the zip file
++++++- export R=results
++++++-@@ -48,10 +48,8 @@ export R=results
++++++- ## 2. Directory Structure
++++++- 
++++++- The code directory structure is
++++++--```
++++++-+``` 
++++++- automatic_vehicular_control/
++++++--│
++++++--├── automatic_vehicular_control/
++++++- │   ├── __pycache__/                # Compiled Python files
++++++- │   ├── evaluations/                # Evaluation results and metrics
++++++- │   ├── models/                     # Model checkpoints
++++++ diff --git a/env.py b/env.py
++++++-index 4ab3d95..c83a674 100644
+++++++index c83a674..3ef7822 100644
++++++ --- a/env.py
++++++ +++ b/env.py
++++++-@@ -724,9 +724,11 @@ class TrafficState:
++++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
++++++- 
++++++-         segments = {}
+++++++@@ -852,12 +852,15 @@ class TrafficState:
+++++++         subscribes.sim = SubscribeDef(tc.simulation, [
+++++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
+++++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
++++++ +        
++++++-         def add_from_to(from_, to):
++++++-             from_.tos.add(to)
++++++-             to.froms.add(from_)
++++++-+            
++++++-         for con in map(values_str_to_val, net.children('connection')):
++++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
++++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
++++++-@@ -888,89 +890,109 @@ class TrafficState:
++++++- 
++++++-     def step(self):
++++++-         """
++++++--        Take a simulation step and update state
++++++-+        Take a simulation step and update state.
++++++-         """
++++++--        c = self.c
++++++--        tc = self.tc
++++++--        subscribes = self.subscribes
++++++-+        c = self.c  # Configuration object for the simulation
++++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
++++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
++++++- 
++++++-         # Actual SUMO step
++++++--        tc.simulationStep()
++++++--        sim_res = subscribes.sim.get()
++++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
++++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
++++++- 
++++++-+        # Clear references to current vehicle edges and lanes for the next update
++++++-         for veh in self.vehicles:
++++++--            veh.unvar('edge', 'lane')
++++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
++++++-+
++++++-+        # Clear current vehicle data from edges and lanes
++++++-         for ent in itertools.chain(self.edges, self.lanes):
++++++--            ent.vehicles.clear()
++++++--            ent.positions.clear()
++++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
++++++-+            ent.positions.clear()  # Clear vehicle positions
++++++- 
++++++-+        # Update traffic light states
++++++-         for tl_id, tl in self.traffic_lights.items():
++++++--            tl.update(subscribes.tl.get(tl_id))
++++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
++++++- 
++++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
++++++-         for veh_id in sim_res.loaded_vehicles_ids:
++++++--            flow_id, _ = veh_id.rsplit('.')
++++++--            flow = self.flows[flow_id]
++++++--            flow.backlog.add(veh_id)
++++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
++++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
++++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
++++++- 
++++++-+        # Initialize a set for newly departed vehicles
++++++-         self.new_departed = set()
++++++-+
++++++-+        # Handle vehicles that have departed (entered the network)
++++++-         for veh_id in sim_res.departed_vehicles_ids:
++++++--            subscribes.veh.subscribe(veh_id)
++++++--            type_id = tc.vehicle.getTypeID(veh_id)
++++++--            # import pdb; pdb.set_trace()
++++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
++++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
++++++-+            # If vehicle type is 'generic', compute specific type
++++++-             if type_id == 'generic':
++++++-                 type_id = self.compute_type(veh_id)
++++++--            type_ = self.types[type_id]
++++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
++++++--            length = tc.vehicle.getLength(veh_id)
++++++--            road_id = tc.vehicle.getRoadID(veh_id)
++++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
++++++--            type_.vehicles.add(veh)
++++++-+            type_ = self.types[type_id]  # Get vehicle type object
++++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
++++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
++++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
++++++-+
++++++-+            # Create a new vehicle object and add it to the list of vehicles
++++++-+            self.vehicles[veh_id] = veh = Vehicle(
++++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
++++++-+            )
++++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
++++++- 
++++++-+            # Set color if rendering is enabled
++++++-             if c.render:
++++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
++++++--                self.set_color(veh, color_fn(veh))
++++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
++++++- 
++++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
++++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
++++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
++++++-+
++++++-+            # Add to new_departed set
++++++-             self.new_departed.add(veh)
++++++-+
++++++-+            # Remove vehicle from backlog if necessary
++++++-             if '.' in veh_id:
++++++-                 flow_id, _ = veh_id.rsplit('.')
++++++-                 if flow_id in self.flows:
++++++-                     flow = self.flows[flow_id]
++++++-                     flow.backlog.remove(veh_id)
++++++- 
++++++-+        # Handle newly arrived and collided vehicles
++++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
++++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+++++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
+++++++             TL.red_yellow_green_state])
++++++ +        
++++++-+        # Remove newly arrived vehicles from tracking if they collided
++++++-         for veh in self.new_arrived:
++++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
++++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
++++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
++++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
++++++- 
++++++-+        # Update vehicle positions on edges and lanes
++++++-         for veh_id, veh in self.vehicles.items():
++++++--            veh.prev_speed = veh.get('speed', None)
++++++--            veh.update(subscribes.veh.get(veh_id))
++++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
++++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
++++++-             if veh_id not in sim_res.colliding_vehicles_ids:
++++++--                edge = self.edges[veh.road_id]
++++++--                edge.vehicles.append(veh)
++++++--                veh.edge = edge
++++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
++++++--            # edge = self.edges[veh.road_id]
++++++--            # edge.vehicles.append(veh)
++++++--            # veh.edge = edge
++++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
++++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
++++++-+                veh.edge = edge  # Set vehicle's edge attribute
++++++- 
++++++-+        # Update vehicle sorting and lane positions
++++++-         for edge in self.edges:
++++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
++++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
++++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
++++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
++++++-             for edge_i, veh in enumerate(edge.vehicles):
++++++--                veh.edge_i = edge_i
++++++--                veh.lane = lane = edge.lanes[veh.lane_index]
++++++--                veh.lane_i = len(lane.vehicles)
++++++--                lane.vehicles.append(veh)
++++++--                lane.positions.append(veh.laneposition)
++++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
++++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
++++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
++++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
++++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
++++++- 
++++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
++++++-         self.all_arrived.append(self.new_arrived)
++++++-         self.all_departed.append(self.new_departed)
++++++-         self.all_collided.append(self.new_collided)
++++++--
++++++-+            
++++++-     def reset(self, tc):
++++++-         self.tc = tc
++++++-         self.subscribes.clear()
++++++-@@ -1043,6 +1065,7 @@ class Env:
++++++-     """
++++++-     Offers a similar reinforcement learning environment interface as gym.Env
++++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
++++++-+    c: Ring class
++++++-     """
++++++-     def __init__(self, c):
++++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
++++++-@@ -1056,6 +1079,7 @@ class Env:
++++++-             if c.get('save_agent'):
++++++-                 self._agent_info = []
++++++-         self._step = 0
++++++-+        self.mean_speed = 0
++++++- 
++++++-     def def_sumo(self, *args, **kwargs):
++++++-         """ Override this with code defining the SUMO network """
++++++-@@ -1094,49 +1118,91 @@ class Env:
++++++-         """
++++++-         return True
++++++- 
++++++-+   # Method to reset or initialize the SUMO traffic simulation environment
++++++-     def reset_sumo(self):
++++++-+        # Shortcuts for configuration and SUMO definition objects
++++++-         c = self.c
++++++-         sumo_def = self.sumo_def
++++++--
++++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+++++++         subscribes.veh = SubscribeDef(tc.vehicle, [
+++++++             V.road_id, V.lane_index, V.laneposition,
+++++++             V.speed, V.position, V.angle,
+++++++             V.fuelconsumption, V.noxemission])
++++++ +        
++++++-+        # Determine if new SUMO definitions need to be generated
++++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
++++++-+        
++++++-         if generate_def:
++++++--            kwargs = self.def_sumo()
++++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
++++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
++++++-+            # Generate new definitions if necessary
++++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
++++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
++++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++++++-+        
++++++-+        # Start SUMO with the current traffic controller (tc)
++++++-         self.tc = sumo_def.start_sumo(self.tc)
++++++-+        
++++++-         if generate_def:
++++++-+            # If new definitions were generated, store relevant SUMO file paths
++++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
++++++-+            
++++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
++++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
++++++--            self.ts = TrafficState(c, self.tc, **defs)
++++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
++++++-         else:
++++++-+            # If not generating new definitions, simply reset the existing traffic state
++++++-             self.ts.reset(self.tc)
++++++-+        
++++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
++++++-         self.ts.setup()
++++++-+        
++++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
++++++-         success = self.init_vehicles()
++++++-+        
++++++-+        # Return whether the SUMO reset and vehicle initialization were successful
++++++-         return success
+++++++         for tl_id in self.traffic_lights.keys():
+++++++             subscribes.tl.subscribe(tl_id)
++++ +  
++++-+
++++-     def run(c):
++++-         # Determine whether to train or evaluate based on configuration
++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++-diff --git a/ring.py b/ring.py
++++-index 94d632d..ee1372b 100644
++++---- a/ring.py
++++-+++ b/ring.py
++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++-         )
++++--
++++-         # Function to generate the shape of the edges (circular arcs)
++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++- 
++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
++++-         if c.circumference_range:  # Check if the circumference should be randomized
++++-             # Randomly set the circumference within the specified range
++++-             c.circumference = np.random.randint(*c.circumference_range)
++++-+        
++++-+        if self.flow_log:
++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
++++-+            self.episode_flow.append(average_flow)
++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
++++-+        
++++-+        # Reset flow counters for the new episode
++++-+        self.flow_counter = 0
++++-+        self.flow_log = []
++++-+        self.last_vehicle_times = {}
++++-+        
++++-         return super().reset_sumo()  # Reset the simulation
++++++-+    # Method to initialize the environment after SUMO reset
++++++-     def init_env(self):
++++++-+        # Reference to the traffic state
++++++-         ts = self.ts
++++++-+    
++++++-+        # Create an empty data structure to store rollout information
++++++-         self.rollout_info = NamedArrays()
++++++-+        
++++++-+        # Turn off all traffic lights in the network
++++++-         for tl in ts.traffic_lights:
++++++--            ts.set_program(tl, 'off')
++++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
++++++-+        
++++++-+        # Reset the step counter to 0
++++++-         self._step = 0
++++++-+        
++++++-+        # Take the first step in the simulation
++++++-         ret = self.step()
++++++-+        
++++++-+        # Run the simulation for a number of warmup steps
++++++-         for _ in range(self.c.warmup_steps):
++++++--            ret = self.step()
++++++-+            ret = self.step()  # Advance the simulation one step
++++++-+            
++++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
++++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
++++++-                 return None
++++++-+        
++++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
++++++-         for tl in ts.traffic_lights:
++++++--            ts.set_program(tl, '1')
++++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
++++++-+        
++++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
++++++-         if isinstance(ret, tuple):
++++++--            return ret[0]
++++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
++++++--
++++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
++++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
++++++-+        
++++++-+    # Reset the entire environment, retrying until successful
++++++-     def reset(self):
++++++--        while True:
++++++-+        self.mean_speed = 0
++++++-+        while True:  # Infinite loop until the environment is successfully reset
++++++-+            # Attempt to reset the SUMO simulation
+++++++@@ -1197,6 +1200,7 @@ class Env:
+++++++         while True:  # Infinite loop until the environment is successfully reset
+++++++             # Attempt to reset the SUMO simulation
++++++              if not self.reset_sumo():
++++++--                continue
++++++-+                continue  # If reset_sumo fails, retry the loop
++++++-+            
++++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++++-             if (obs := self.init_env()) is not None:
++++++--                return obs
++++++-+                return obs  # Successfully initialized, return the observation
++++++-+
++++++- 
++++++-     def append_step_info(self):
++++++-         """
++++++-@@ -1231,6 +1297,8 @@ class Env:
++++++- class NormEnv(gym.Env):
++++++-     """
++++++-     Reward normalization with running average https://github.com/joschu/modular_rl
++++++-+    self.c: Ring parameters 
++++++-+    self.env: RingEnv class
++++++-     """
++++++-     def __init__(self, c, env):
++++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
++++++++                
+++++++                 continue  # If reset_sumo fails, retry the loop
+++++++             
+++++++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++++ diff --git a/exp.py b/exp.py
++++++-index ead4652..7f7cee5 100644
+++++++index 7f7cee5..6f16d66 100644
++++++ --- a/exp.py
++++++ +++ b/exp.py
++++++-@@ -169,9 +169,9 @@ class Main(Config):
++++++- 
++++++-     def on_train_start(c):
++++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
++++++--        c.setdefaults(alg='Algorithm')
++++++--        c._env = c.create_env()
++++++--
++++++-+        c.setdefaults(alg='Algorithm') 
++++++-+        c._env = c.create_env() # Create NormEnv
++++++-+ 
++++++-         # Instantiate the algorithm (e.g., PPO, DQN)
++++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
++++++-         c.set_model()
++++++-@@ -222,8 +222,8 @@ class Main(Config):
++++++- 
++++++-     def on_step_start(c, stats={}):
++++++-         # Update the learning rate and log stats at the start of a training step
++++++--        lr = c._lr
++++++--        for g in c._opt.param_groups:
++++++-+        lr = c._lr # Update Learning Rate
++++++-+        for g in c._opt.param_groups: # Log Statistics
++++++-             g['lr'] = float(lr)
++++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
++++++- 
++++++-@@ -285,10 +285,14 @@ class Main(Config):
+++++++@@ -285,7 +285,6 @@ class Main(Config):
++++++              ret = dict(obs=ret)
++++++          rollout = NamedArrays()
++++++          rollout.append(**ret)
++++++--
++++++-+        rollout_flow_each_step = []
+++++++-        rollout_flow_each_step = []
++++++          done = False
++++++          a_space = c.action_space
++++++          step = 0
+++++++@@ -406,9 +405,8 @@ class Main(Config):
+++++++ 
+++++++     def train(c):
+++++++         # Main training loop
+++++++-        c.on_train_start()
++++++++        c.on_train_start() # Ring Env
+++++++         while c._i < c.n_steps:
+++++++-            c.on_step_start() # save stat 
+++++++             with torch.no_grad():
+++++++                 # Collect rollouts without computing gradients
+++++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++++@@ -497,3 +495,32 @@ class Main(Config):
+++++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
+++++++             c.train()
+++++++         c.log('job done!')
++++++++
++++++++    def run_2(c):
++++++++        # Determine whether to train or evaluate based on configuration
++++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
++++++++        
++++++++        c.on_train_start()
++++++++        c._env = c.create_env() # Create NormEnv
++++++++        ret = c._env.reset()
++++++++        c.set_model()
++++++++        step = 0
++++++ +        density = 20/(250*1e-3)
++++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++++++-+
++++++-         while step < c.horizon + c.skip_stat_steps and not done:
++++++-             # Generate an action from the model's policy
++++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
++++++-@@ -309,6 +313,12 @@ class Main(Config):
++++++-             rollout.append(**ret)
++++++-             step += 1
++++++-         # Collect stats from the environment
++++++++        done = False
++++++++        while step < c.horizon + c.skip_stat_steps and not done:
++++++++            # Take a step in the environment
++++++++            ret = c._env.step()
++++++++            if isinstance(ret, tuple):
++++++++                obs, reward, done, info = ret
++++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
++++++++            done = ret.setdefault('done', False)
++++++++            step += 1
++++++++        # Collect stats from the environment
++++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++++++ +        density = 20/(250 * 1e-3)
++++++ +        vehicle_flow = c._env.mean_speed * density 
++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++++++-+
++++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
++++++-         return rollout, stats
++++++- 
++++++-@@ -398,10 +408,10 @@ class Main(Config):
++++++-         # Main training loop
++++++-         c.on_train_start()
++++++-         while c._i < c.n_steps:
++++++--            c.on_step_start()
++++++-+            c.on_step_start() # save stat 
++++++-             with torch.no_grad():
++++++-                 # Collect rollouts without computing gradients
++++++--                rollouts = c.rollouts()
++++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++-             gd_stats = {}
++++++-             if len(rollouts.obs):
++++++-                 t_start = time()
++++++-@@ -410,7 +420,7 @@ class Main(Config):
++++++-                 gd_stats.update(gd_time=time() - t_start)
++++++-             c.on_step_end(gd_stats)
++++++-             c._i += 1
++++++--        c.on_step_start()  # last step
++++++-+        c.on_step_start()  # save stat
++++++-         gd_stats = {}
++++++-         with torch.no_grad():
++++++-             rollouts = c.rollouts()
++++++-@@ -450,6 +460,8 @@ class Main(Config):
++++++-         if hasattr(c._env, 'close'):
++++++-             c._env.close()
++++++- 
+++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
+++++++deleted file mode 100644
+++++++index 6b9ba52..0000000
+++++++--- a/highway_bottleneck.py
++++++++++ /dev/null
+++++++@@ -1,381 +0,0 @@
+++++++-from automatic_vehicular_control.exp import *
+++++++-from automatic_vehicular_control.env import *
+++++++-from automatic_vehicular_control.u import *
+++++++-
+++++++-class BNeckEnv(Env):
+++++++-    def def_sumo(self):
+++++++-        c = self.c
+++++++-        nodes = E('nodes',
+++++++-            E('node', id='n_0', x=0, y=0), *(
+++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
+++++++-        ))
+++++++-        edges = E('edges', *(
+++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
+++++++-                'numLanes': n_lane,
+++++++-                'speed': c.max_speed
+++++++-            }) for i, n_lane in enumerate(c.n_lanes)
+++++++-        ))
+++++++-        connections = E('connections', *(
+++++++-            E('connection', **{
+++++++-                'from': prev.id,
+++++++-                'to': curr.id,
+++++++-                'fromLane': i,
+++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
+++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
+++++++-        ))
+++++++-
+++++++-        if c.split_flow:
+++++++-            n_inflow_lanes = c.n_lanes[0]
+++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
+++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
+++++++-                for i in range(n_inflow_lanes)
+++++++-            ]
+++++++-        else:
+++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
+++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
+++++++-            ]
+++++++-        routes = E('routes',
+++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
+++++++-            *flows
+++++++-        )
+++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
+++++++-        additional = E('additional',
+++++++-            E('vType', id='generic', **idm_params),
+++++++-            E('vType', id='rl', **idm_params),
+++++++-            E('vType', id='human', **idm_params),
+++++++-        )
+++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++-
+++++++-    def reset_sumo(self):
+++++++-        c = self.c
+++++++-        if c.flow_rate_range:
+++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
+++++++-        ret = super().reset_sumo()
+++++++-        if c.vinitsky:
+++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
+++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
+++++++-                for i_start in range(round(edge.length) // c.piece_length)
+++++++-                for lane in edge.lanes
+++++++-            ]
+++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
+++++++-            self.last_outflows = []
+++++++-        return ret
+++++++-
+++++++-    def step(self, action=[]):
+++++++-        c = self.c
+++++++-        ts = self.ts
+++++++-        max_dist = 100
+++++++-        max_speed = c.max_speed
+++++++-        human_type = ts.types.human
+++++++-        rl_type = ts.types.rl
+++++++-
+++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++-        if c.vinitsky:
+++++++-            if len(action):
+++++++-                assert len(action) == len(self.control_lanes)
+++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
+++++++-                    self.control_lanes[lane, piece_start] = np.clip(
+++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
+++++++-                        0.1, max_speed
+++++++-                    )
+++++++-                for veh in prev_rls:
+++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
+++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
+++++++-        else:
+++++++-            for veh, act in zip(prev_rls, action):
+++++++-                if c.handcraft:
+++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
+++++++-                    next_lane = lane.next(veh.route)
+++++++-                    level = 1
+++++++-                    if next_lane and next_lane.get('junction'):
+++++++-                        merge_dist = lane.length - veh.laneposition
+++++++-                        if merge_dist < c.handcraft:
+++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
+++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
+++++++-                                level = 0
+++++++-                    if c.act_type.startswith('accel'):
+++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++-                    else:
+++++++-                        ts.set_max_speed(veh, max_speed * level)
+++++++-                    continue
+++++++-                if not isinstance(act, (int, np.integer)):
+++++++-                    act = (act - c.low) / (1 - c.low)
+++++++-                if c.act_type.startswith('accel'):
+++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++-                else:
+++++++-                    if c.act_type == 'continuous':
+++++++-                        level = act[0]
+++++++-                    elif c.act_type == 'discretize':
+++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++-                    elif c.act_type == 'discrete':
+++++++-                        level = act / (c.n_actions - 1)
+++++++-                    ts.set_max_speed(veh, max_speed * level)
+++++++-
+++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
+++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
+++++++-
+++++++-        super().step()
+++++++-
+++++++-        if c.vinitsky:
+++++++-            n_last_outflows = 20
+++++++-            max_vehs = 4
+++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
+++++++-            obs = []
+++++++-            for lane, piece_start in self.obs_lanes:
+++++++-                piece_end = piece_start + c.piece_length
+++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
+++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
+++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
+++++++-                obs.extend([
+++++++-                    len(lane_humans) / max_vehs,
+++++++-                    len(lane_avs) / max_vehs,
+++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
+++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
+++++++-                ])
+++++++-            if len(self.last_outflows) == n_last_outflows:
+++++++-                self.last_outflows = self.last_outflows[1:]
+++++++-            self.last_outflows.append(len(ts.new_arrived))
+++++++-            reward = np.mean(self.last_outflows)
+++++++-            obs.append(reward / max_veh_outflows)
+++++++-            obs = np.array(obs, dtype=np.float32)
+++++++-            assert 0 <= obs.min() and obs.max() <= 1
+++++++-            return obs, reward, False, None
+++++++-        route = nexti(ts.routes)
+++++++-        obs, ids = [], []
+++++++-        default_close = [0, max_speed]
+++++++-        default_far = [max_dist, 0]
+++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++-            merge_dist = max_dist
+++++++-            default_human = default_far
+++++++-
+++++++-            other_info = {}
+++++++-            next_lane = lane.next(veh.route)
+++++++-            if next_lane and next_lane.get('junction'):
+++++++-                merge_dist = lane.length - veh.laneposition
+++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
+++++++-                # Look for veh on other lane but do not extend past that lane
+++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
+++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
+++++++-                    if other_veh.type is rl_type:
+++++++-                        default_human = default_close
+++++++-                        break
+++++++-
+++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
+++++++-            ids.append(veh.id)
+++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
+++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++-        
+++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++-
+++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++-        drac = np.clip(drac/10, -1, 1)
+++++++-
+++++++-        raw_pet = self.calc_pet()
+++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++-        pet = np.clip(pet, -1, 1)
+++++++-
+++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++-        
+++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++-        return returned
+++++++-        
+++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++-    
+++++++-    def calc_ttc(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        ttcs = []
+++++++-        for v in cur_veh_list:
+++++++-            leader, headway = v.leader()
+++++++-            v_speed = v.speed
+++++++-            leader_speed = leader.speed
+++++++-            if leader_speed < v_speed:
+++++++-                ttc =  headway/(v_speed-leader_speed)
+++++++-            else:
+++++++-                ttc = np.nan
+++++++-            ttcs.append(ttc)
+++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++-        return fleet_ttc
+++++++-    
+++++++-    def calc_drac(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        dracs = []
+++++++-        for v in cur_veh_list:
+++++++-            leader, headway = v.leader()
+++++++-            v_speed = v.speed
+++++++-            leader_speed = leader.speed
+++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++-            dracs.append(drac)
+++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++-        return fleet_drac
+++++++-
+++++++-    def calc_pet(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        pets = []
+++++++-        for v in cur_veh_list:
+++++++-            leader, headway = v.leader()
+++++++-            v_speed = v.speed
+++++++-            if v_speed > 1e-16:
+++++++-                pet = headway/(v_speed)
+++++++-                pets.append(pet)
+++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++-        return fleet_pet
+++++++-
+++++++-class BNeck(Main):
+++++++-    def create_env(c):
+++++++-        return BNeckEnv(c)
+++++++-
+++++++-    @property
+++++++-    def observation_space(c):
+++++++-        low = np.full(c._n_obs, c.low)
+++++++-        return Box(low, np.ones_like(low))
+++++++-
+++++++-    @property
+++++++-    def action_space(c):
+++++++-        if c.vinitsky:
+++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
+++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++-            assert c.lc_av in [False, 'binary']
+++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
+++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++-            return Discrete(c.n_actions)
+++++++-
+++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++-        if c.vinitsky:
+++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
+++++++-        log = c.get_log_ii(ii, n_ii)
+++++++-        step_obs_ = rollout.obs
+++++++-        step_obs = step_obs_[:-1]
+++++++-
+++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++-
+++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++-
+++++++-        step_id_ = rollout.pop('id')
+++++++-        id = np.concatenate(step_id_[:-1])
+++++++-        id_unique = np.unique(id)
+++++++-
+++++++-        reward = np.array(rollout.pop('reward'))
+++++++-
+++++++-        log(**stats)
+++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++-        log(
+++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++-            n_veh_unique=len(id_unique),
+++++++-            
+++++++-            reward_mean=np.mean(reward),
+++++++-            reward_std=np.std(reward),        
+++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++-            ssm_std=np.std(rollout.ssm),
+++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++-
+++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++-            # res_action = np.mean(rollout.res_action),
+++++++-            )
+++++++-        return rollout
+++++++-
+++++++-if __name__ == '__main__':
+++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
+++++++-        warmup_steps=1000,
+++++++-        horizon=2000,
+++++++-        n_steps=100,
+++++++-        step_save=5,
+++++++-
+++++++-        av_frac=0.2,
+++++++-        sim_step=0.5,
+++++++-        depart_speed=0,
+++++++-        edge_lengths=[100, 100, 50],
+++++++-        n_lanes=[4, 2, 1],
+++++++-        max_speed=30,
+++++++-
+++++++-        lc_av=False,
+++++++-        flow_rate=2300,
+++++++-        flow_rate_range=None,
+++++++-        split_flow=True,
+++++++-        generic_type='rand',
+++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++-        lc_mode=LC_MODE.off,
+++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++-
+++++++-        veh_junction=False,
+++++++-        act_type='accel_discrete',
+++++++-        max_accel=2.6,
+++++++-        max_decel=4.5,
+++++++-        tau=1.0,
+++++++-        min_gap=2.5,
+++++++-        delta=4,
+++++++-        n_actions=3,
+++++++-        low=-1,
+++++++-        handcraft=False,
+++++++-        vinitsky=False,
+++++++-
+++++++-        render=False,
+++++++-
+++++++-        alg=PG,
+++++++-        lr=1e-3,
+++++++-
+++++++-        gamma=0.99,
+++++++-        adv_norm=False,
+++++++-        batch_concat=True,
+++++++-
+++++++-        beta=0,
+++++++-        scale_ttc=1,
+++++++-        scale_drac=1,
+++++++-        seed_np=False,
+++++++-        seed_torch = False,
+++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++-
+++++++-    )
+++++++-    
+++++++-    if c.seed_torch:
+++++++-        # Set seed for PyTorch CPU operations
+++++++-        torch.manual_seed(c.seed_torch)
+++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++-        if torch.cuda.is_available():
+++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++-    if c.seed_np:
+++++++-        np.random.seed(c.seed_np)
+++++++-        
+++++++-    if c.vinitsky:
+++++++-        c.piece_length = 20
+++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
+++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
+++++++-        c._n_action = sum(n_actions[:-1])
+++++++-        c._n_obs = sum(n_actions) * 4 + 1
+++++++-        c.batch_concat = False
+++++++-    else:
+++++++-        c._n_obs = 2 + 2 + 2
+++++++-        
+++++++-    if c.mrtl:
+++++++-        c._n_obs += 1 # modified for mrtl related
+++++++-        
+++++++-    c.redef_sumo = bool(c.flow_rate_range)
+++++++-    c.run()
+++++++\ No newline at end of file
+++++++diff --git a/highway_ramp.py b/highway_ramp.py
+++++++deleted file mode 100644
+++++++index ef0358f..0000000
+++++++--- a/highway_ramp.py
++++++++++ /dev/null
+++++++@@ -1,325 +0,0 @@
+++++++-from automatic_vehicular_control.exp import *
+++++++-from automatic_vehicular_control.env import *
+++++++-from automatic_vehicular_control.u import *
+++++++-
+++++++-class RampEnv(Env):
+++++++-    # https://flow-project.github.io/papers/08569485.pdf
+++++++-    def def_sumo(self):
+++++++-        c = self.c
+++++++-        builder = NetBuilder()
+++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
+++++++-            (0, 0),
+++++++-            (c.premerge_distance, 0),
+++++++-            (c.premerge_distance + c.merge_distance, 0),
+++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
+++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
+++++++-        ])
+++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
+++++++-            {}, {'numLanes': 2}, {}
+++++++-        ], lane_maps=[
+++++++-            {0: 1}, {0: 0, 1: 0}
+++++++-        ], route_id='highway')
+++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
+++++++-            {}, {'numLanes': 2}, {}
+++++++-        ], lane_maps=[
+++++++-            {0: 0}, {0: 0, 1: 0}
+++++++-        ], route_id='ramp')
+++++++-        nodes, edges, connections, routes = builder.build()
+++++++-        nodes[2].type = 'zipper'
+++++++-
+++++++-        routes = E('routes',
+++++++-            *routes,
+++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
+++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
+++++++-        )
+++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
+++++++-        additional = E('additional',
+++++++-            E('vType', id='generic', **idm),
+++++++-            E('vType', id='rl', **idm),
+++++++-            E('vType', id='human', **idm),
+++++++-        )
+++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++-
+++++++-    def step(self, action=[]):
+++++++-        c = self.c
+++++++-        ts = self.ts
+++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
+++++++-        max_speed = c.max_speed
+++++++-        human_type = ts.types.human
+++++++-        rl_type = ts.types.rl
+++++++-
+++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++-        for rl, act in zip(prev_rls, action):
+++++++-            if c.handcraft:
+++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
+++++++-                leader, dist = rl.leader()
+++++++-                level = 1
+++++++-                if edge.id == 'e_n_0.0_n_400.0':
+++++++-                    if rl.laneposition < 100:
+++++++-                        leaders = list(rl.leaders())
+++++++-                        if len(leaders) > 20:
+++++++-                            level = 0
+++++++-                        else:
+++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++-                continue
+++++++-            if not isinstance(act, (int, np.integer)):
+++++++-                act = (act - c.low) / (1 - c.low)
+++++++-            if c.act_type.startswith('accel'):
+++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++-            else:
+++++++-                if c.act_type == 'continuous':
+++++++-                    level = act[0]
+++++++-                elif c.act_type == 'discretize':
+++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++-                elif c.act_type == 'discrete':
+++++++-                    level = act / (c.n_actions - 1)
+++++++-                ts.set_max_speed(rl, max_speed * level)
+++++++-
+++++++-        super().step()
+++++++-
+++++++-        route = ts.routes.highway
+++++++-        obs, ids = [], []
+++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++-            if hasattr(veh, 'edge'):
+++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++-                merge_dist = max_dist
+++++++-
+++++++-                lead_speed = follow_speed = other_speed = 0
+++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
+++++++-
+++++++-                leader, dist = veh.leader()
+++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
+++++++-
+++++++-                follower, dist = veh.follower()
+++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
+++++++-
+++++++-                if c.global_obs:
+++++++-                    jun_edge = edge.next(route)
+++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
+++++++-                        jun_edge = jun_edge.next(route)
+++++++-                    if jun_edge:
+++++++-                        merge_dist = lane.length - veh.laneposition
+++++++-                        next_edge = edge.next(route)
+++++++-                        while next_edge is not jun_edge:
+++++++-                            merge_dist += next_edge.length
+++++++-                            next_edge = next_edge.next(route)
+++++++-
+++++++-                        other_lane = jun_edge.lanes[0]
+++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
+++++++-                            other_speed = other_veh.speed
+++++++-                            break
+++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
+++++++-                else:
+++++++-                    next_lane = lane.next(route)
+++++++-                    if next_lane and next_lane.get('junction'):
+++++++-                        if len(edge.lanes) == 2:
+++++++-                            other_lane = edge.lanes[0]
+++++++-                            pos = veh.laneposition
+++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
+++++++-                                other_speed = other_veh.speed
+++++++-                                break
+++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
+++++++-                ids.append(veh.id)
+++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
+++++++-        if c.mrtl:
+++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++-        
+++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++-
+++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++-        drac = np.clip(drac/10, -1, 1)
+++++++-
+++++++-        raw_pet = self.calc_pet()
+++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++-        pet = np.clip(pet, -1, 1)
+++++++-
+++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++-        
+++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++-        return returned
+++++++-        
+++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++-    
+++++++-    def calc_ttc(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        ttcs = []
+++++++-        for v in cur_veh_list:
+++++++-            if hasattr(v, 'edge'):
+++++++-                leader, headway = v.leader()
+++++++-                if leader:
+++++++-                    v_speed = v.speed
+++++++-                    leader_speed = leader.speed
+++++++-                    if leader_speed < v_speed:
+++++++-                        ttc =  headway/(v_speed-leader_speed)
+++++++-                    else:
+++++++-                        ttc = np.nan
+++++++-                    ttcs.append(ttc)
+++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++-        return fleet_ttc
+++++++-    
+++++++-    def calc_drac(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        dracs = []
+++++++-        for v in cur_veh_list:
+++++++-            if hasattr(v, 'edge'):
+++++++-                leader, headway = v.leader()
+++++++-                if leader:
+++++++-                    v_speed = v.speed
+++++++-                    leader_speed = leader.speed
+++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++-                    dracs.append(drac)
+++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++-        return fleet_drac
+++++++-
+++++++-    def calc_pet(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        pets = []
+++++++-        for v in cur_veh_list:
+++++++-            if hasattr(v, 'edge'):
+++++++-                leader, headway = v.leader()
+++++++-                if leader:
+++++++-                    v_speed = v.speed
+++++++-                    if v_speed > 1e-16:
+++++++-                        pet = headway/(v_speed)
+++++++-                        pets.append(pet)
+++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
+++++++-        return fleet_pet
+++++++-
+++++++-class Ramp(Main):
+++++++-    def create_env(c):
+++++++-        return RampEnv(c)
+++++++-
+++++++-    @property
+++++++-    def observation_space(c):
+++++++-        low = np.full(c._n_obs, c.low)
+++++++-        return Box(low, np.ones_like(low))
+++++++-
+++++++-    @property
+++++++-    def action_space(c):
+++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++-            return Discrete(c.n_actions)
+++++++-
+++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++-        log = c.get_log_ii(ii, n_ii)
+++++++-        step_obs_ = rollout.obs
+++++++-        step_obs = step_obs_[:-1]
+++++++-
+++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++-
+++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++-
+++++++-        step_id_ = rollout.pop('id')
+++++++-        id = np.concatenate(step_id_[:-1])
+++++++-        id_unique = np.unique(id)
+++++++-
+++++++-        reward = np.array(rollout.pop('reward'))
+++++++-
+++++++-        log(**stats)
+++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++-        log(
+++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++-            n_veh_unique=len(id_unique),
+++++++-            
+++++++-            reward_mean=np.mean(reward),
+++++++-            reward_std=np.std(reward),        
+++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++-            ssm_std=np.std(rollout.ssm),
+++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++-
+++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++-            # res_action = np.mean(rollout.res_action),
+++++++-            )
+++++++-        return rollout
+++++++-
+++++++-if __name__ == '__main__':
+++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
+++++++-        warmup_steps=100,
+++++++-        horizon=2000,
+++++++-        n_steps=100,
+++++++-        step_save=5,
+++++++-
+++++++-        premerge_distance=400,
+++++++-        merge_distance=100,
+++++++-        postmerge_distance=30,
+++++++-        av_frac=0.1,
+++++++-        sim_step=0.5,
+++++++-        max_speed=30,
+++++++-        highway_depart_speed=10,
+++++++-        ramp_depart_speed=0,
+++++++-        highway_flow_rate=2000,
+++++++-        ramp_flow_rate=300,
+++++++-        global_obs=False,
+++++++-        handcraft=False,
+++++++-
+++++++-        generic_type='default',
+++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++-
+++++++-        act_type='accel_discrete',
+++++++-        max_accel=1,
+++++++-        max_decel=1.5,
+++++++-        n_actions=3,
+++++++-        low=-1,
+++++++-
+++++++-        render=False,
+++++++-
+++++++-        alg=PG,
+++++++-        lr=1e-3,
+++++++-
+++++++-        gamma=0.99,
+++++++-        adv_norm=False,
+++++++-        batch_concat=True,
+++++++-
+++++++-        beta=0,
+++++++-        scale_ttc=1,
+++++++-        scale_drac=1,
+++++++-        seed_np=False,
+++++++-        seed_torch = False,
+++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++-
+++++++-    )
+++++++-    
+++++++-    if c.seed_torch:
+++++++-        # Set seed for PyTorch CPU operations
+++++++-        torch.manual_seed(c.seed_torch)
+++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++-        if torch.cuda.is_available():
+++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++-    if c.seed_np:
+++++++-        np.random.seed(c.seed_np)
+++++++-        
+++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
+++++++-    if c.mrtl:
+++++++-        c._n_obs += 1 # modified for mrtl related
+++++++-    c.run()
+++++++\ No newline at end of file
+++++++diff --git a/intersection.py b/intersection.py
+++++++deleted file mode 100644
+++++++index e38a84f..0000000
+++++++--- a/intersection.py
++++++++++ /dev/null
+++++++@@ -1,489 +0,0 @@
+++++++-from automatic_vehicular_control.u import *
+++++++-from automatic_vehicular_control.exp import *
+++++++-from automatic_vehicular_control.env import *
+++++++-
+++++++-class Platoon(Entity):
+++++++-    pass
+++++++-
+++++++-class IntersectionEnv(Env):
+++++++-    def def_sumo(self):
+++++++-        c = self.c
+++++++-
+++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
+++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
+++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
+++++++-        ] if params.get('vehsPerHour')]
+++++++-
+++++++-        builder = NetBuilder()
+++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
+++++++-        if c.enter_length:
+++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++-            xys[1:, :, 0] += c.enter_length - c.length
+++++++-            xys[:, 1:, 1] += c.enter_length - c.length
+++++++-            xys = xys.reshape(-1, 2)
+++++++-        if c.short_exit:
+++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++-            xys[-1, :, 0] += c.short_exit - c.length
+++++++-            xys[:, -1, 1] += c.short_exit - c.length
+++++++-            xys = xys.reshape(-1, 2)
+++++++-        nodes = builder.add_nodes(
+++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
+++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
+++++++-        # import pdb; pdb.set_trace()
+++++++-
+++++++-        tl = c.setdefault('tl', False)
+++++++-        if tl:
+++++++-            c.av_frac = 0
+++++++-            c.pop('av_range', None)
+++++++-            c.speed_mode = SPEED_MODE.all_checks
+++++++-
+++++++-        flows = []
+++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
+++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
+++++++-        for direction in c.directions:
+++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
+++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
+++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
+++++++-
+++++++-            edge_attrs = dict(priority=int(direction in priority))
+++++++-            if c.get('set_edge_speed', True):
+++++++-                edge_attrs['speed'] = c.max_speed
+++++++-
+++++++-            for i, chain in enumerate(chains[1:-1]):
+++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
+++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
+++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
+++++++-
+++++++-        tls = []
+++++++-        if tl:
+++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
+++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
+++++++-            tl_offset = c.get('tl_offset', 'auto')
+++++++-            yellow = c.get('yellow', 0.5)
+++++++-            if tl_offset == 'auto':
+++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
+++++++-            elif tl_offset == 'same':
+++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
+++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
+++++++-                node.type = 'traffic_light'
+++++++-                phase_multiple = len(c.directions) // 2
+++++++-                tls.append(E('tlLogic',
+++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
+++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
+++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
+++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
+++++++-                id=node.id, offset=offset, type='static', programID='1'))
+++++++-
+++++++-        nodes, edges, connections, routes = builder.build()
+++++++-        additional = E('additional', *types, *routes, *flows, *tls)
+++++++-        return super().def_sumo(nodes, edges, connections, additional)
+++++++-
+++++++-    def build_platoon(self):
+++++++-        ts = self.ts
+++++++-        rl_type = ts.types.rl
+++++++-        for route in ts.routes:
+++++++-            vehs = []
+++++++-            route_offset = 0
+++++++-            for edge in route.edges:
+++++++-                for veh in edge.vehicles:
+++++++-                    veh.route_position = route_offset + veh.laneposition
+++++++-                    vehs.append(veh)
+++++++-                route_offset += edge.length
+++++++-
+++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
+++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
+++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
+++++++-            rl_idxs, = rl_mask.nonzero()
+++++++-            split_idxs = 1 + rl_idxs
+++++++-
+++++++-            prev = None
+++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
+++++++-                if not len(vehs_i):
+++++++-                    continue # Last vehicle is RL, so the last split is empty
+++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
+++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
+++++++-                )
+++++++-                if prev is not None:
+++++++-                    prev.next = platoon
+++++++-                prev = platoon
+++++++-                for veh in vehs_i:
+++++++-                    veh.platoon = platoon
+++++++-            if prev is not None:
+++++++-                prev.next = None
+++++++-
+++++++-    def reset(self):
+++++++-        c = self.c
+++++++-        if c.e is False:
+++++++-            if 'length_range' in c:
+++++++-                min_, max_ = c.length_range
+++++++-                c.setdefaults(max_length=max_)
+++++++-                c.length = np.random.randint(min_, max_ + 1)
+++++++-            if 'av_range' in c:
+++++++-                min_, max_ = c.av_range
+++++++-                c.av_frac = np.random.uniform(min_, max_)
+++++++-        self.mp_tlast = 0
+++++++-        while not self.reset_sumo():
+++++++-            pass
+++++++-        ret = super().init_env()
+++++++-        return ret
+++++++-
+++++++-    def step(self, action=[]):
+++++++-        c = self.c
+++++++-        ts = self.ts
+++++++-        max_dist = c.max_dist
+++++++-        depart_speed = c.depart_speed
+++++++-        max_speed = c.max_speed
+++++++-
+++++++-        rl_type = ts.types.rl
+++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++-
+++++++-        for rl, act in zip(prev_rls, action):
+++++++-            if c.handcraft or c.handcraft_tl:
+++++++-                route, lane = rl.route, rl.lane
+++++++-                junction = lane.next_junction
+++++++-                level = 1
+++++++-                if junction is not ts.sentinel_junction:
+++++++-                    dist = junction.route_position[route] - rl.route_position
+++++++-                    if c.handcraft:
+++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
+++++++-                    elif c.handcraft_tl and dist < 15:
+++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
+++++++-                        yellow_time = 0
+++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
+++++++-                        horizontal_go = 0 <= rem < t_h
+++++++-                        vertical_go = t_h + yellow_time <= rem
+++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
+++++++-                        human_remain = False
+++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
+++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
+++++++-            elif c.act_type == 'accel':
+++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
+++++++-            else:
+++++++-                level = act / (c.n_actions - 1)
+++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++-
+++++++-        if c.tl == 'MaxPressure':
+++++++-            self.mp_tlast += c.sim_step
+++++++-            tmin = c.get('mp_tmin', 0)
+++++++-            if self.mp_tlast >= tmin:
+++++++-                for tl in ts.traffic_lights:
+++++++-                    if ts.get_program(tl) == 'off':
+++++++-                        break
+++++++-                    jun = tl.junction
+++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
+++++++-
+++++++-                    total_pressures = []
+++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
+++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
+++++++-
+++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
+++++++-                self.mp_tlast = 0
+++++++-
+++++++-        super().step()
+++++++-        self.build_platoon()
+++++++-
+++++++-        obs = {}
+++++++-
+++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
+++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
+++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
+++++++-        for veh in rl_type.vehicles:
+++++++-            if hasattr(veh, 'lane'):
+++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
+++++++-                junction = lane.next_junction
+++++++-
+++++++-                head, tail = veh, platoon.tail
+++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
+++++++-
+++++++-                if junction is ts.sentinel_junction:
+++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
+++++++-                else:
+++++++-                    for jun_lane in lane.next_junction_lanes:
+++++++-                        # Defaults for jun_lane
+++++++-                        jun_headtails = vehs_default()
+++++++-
+++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
+++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
+++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
+++++++-
+++++++-                        if jun_veh:
+++++++-                            if jun_veh.type is rl_type:
+++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
+++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
+++++++-                                platoon = jun_veh.platoon.prev
+++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++-                                    if platoon is None: break
+++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++-                                    platoon = platoon.prev
+++++++-                            else:
+++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
+++++++-                                jun_headtails[0] = jun_veh.platoon.tail
+++++++-                                next_cross_platoon = jun_veh.platoon.prev
+++++++-                                if next_cross_platoon:
+++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
+++++++-                                    platoon = next_cross_platoon.prev
+++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++-                                        if platoon is None: break
+++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++-                                        platoon = platoon.prev
+++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
+++++++-
+++++++-                dist_features, speed_features = [], []
+++++++-                for route, vehs in route_vehs:
+++++++-                    j_pos = junction.route_position[route]
+++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
+++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
+++++++-
+++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++-
+++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
+++++++-        ids = sorted(obs)
+++++++-        if c.mrtl:
+++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
+++++++-        if c.rew_type == 'outflow':
+++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++-        elif c.rew_type == 'time_penalty':
+++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
+++++++-        
+++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++-
+++++++-        raw_drac = self.calc_drac()
+++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++-        drac = np.clip(drac/10, -1, 1)
+++++++-        raw_pet = self.calc_pet()
+++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++-        pet = np.clip(pet/6, -1, 1)
+++++++-
+++++++-        raw_ttc = self.calc_ttc()
+++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++-
+++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
+++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++-
+++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++-        return returned
+++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++-        
+++++++-    def calc_drac(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        dracs = []
+++++++-        for v in cur_veh_list:
+++++++-            if hasattr(v, 'lane'):
+++++++-                leader, headway = v.leader()
+++++++-                v_speed = v.speed
+++++++-                leader_speed = leader.speed
+++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++-                dracs.append(drac)
+++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++-        return fleet_drac
+++++++-    
+++++++-    def calc_pet(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        pets = []
+++++++-        for v in cur_veh_list:
+++++++-            if hasattr(v, 'lane'):
+++++++-                leader, headway = v.leader()
+++++++-                v_speed = v.speed
+++++++-                if v_speed > 1e-16:
+++++++-                    pet = headway/(v_speed)
+++++++-                    pets.append(pet)
+++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++-        return fleet_pet
+++++++-
+++++++-    def calc_ttc(self):
+++++++-        cur_veh_list = self.ts.vehicles
+++++++-        ttcs = []
+++++++-        for v in cur_veh_list:
+++++++-            if hasattr(v, 'lane'):
+++++++-                leader, headway = v.leader()
+++++++-                v_speed = v.speed
+++++++-                leader_speed = leader.speed
+++++++-                if leader_speed < v_speed:
+++++++-                    ttc =  headway/(v_speed-leader_speed)
+++++++-                else:
+++++++-                    ttc = np.nan
+++++++-                ttcs.append(ttc)
+++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++-        return fleet_ttc
+++++++-
+++++++-    def append_step_info(self):
+++++++-        super().append_step_info()
+++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
+++++++-
+++++++-    @property
+++++++-    def stats(self):
+++++++-        c = self.c
+++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
+++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
+++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
+++++++-        stats['backlog_step'] = mean(info['backlog'])
+++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
+++++++-
+++++++-        stats['beta'] = c.beta
+++++++-
+++++++-        if c.multi_flowrate:
+++++++-            stats['flow_horizontal'] = c.flow_rate_h
+++++++-            stats['flow_vertical'] = c.flow_rate_v
+++++++-        return stats
+++++++-
+++++++-class Intersection(Main):
+++++++-    def create_env(c):
+++++++-        if c.multi_flowrate:
+++++++-            return NormEnv(c, IntersectionEnv(c))
+++++++-        else:
+++++++-            c._norm = NormEnv(c, None)
+++++++-            return IntersectionEnv(c)
+++++++-
+++++++-    @property
+++++++-    def observation_space(c):
+++++++-        low = np.full(c._n_obs, c.low)
+++++++-        return Box(low, np.ones_like(low))
+++++++-
+++++++-    @property
+++++++-    def action_space(c):
+++++++-        if c.act_type == 'accel':
+++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++-        else:
+++++++-            return Discrete(c.n_actions)
+++++++-
+++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++-        log = c.get_log_ii(ii, n_ii)
+++++++-        step_obs_ = rollout.obs
+++++++-        step_obs = step_obs_[:-1]
+++++++-
+++++++-        if not c.multi_flowrate:
+++++++-            rollout.raw_reward = rollout.reward
+++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
+++++++-
+++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++-
+++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++-
+++++++-        step_id_ = rollout.pop('id')
+++++++-        id = np.concatenate(step_id_[:-1])
+++++++-        id_unique = np.unique(id)
+++++++-
+++++++-        reward = np.array(rollout.pop('reward'))
+++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
+++++++-
+++++++-        log(**stats)
+++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
+++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++-        log(
+++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++-            n_veh_unique=len(id_unique),
+++++++-            
+++++++-            reward_mean=np.mean(reward),
+++++++-            reward_std=np.std(reward),        
+++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++-            ssm_std=np.std(rollout.ssm),
+++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++-
+++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++-            # res_action = np.mean(rollout.res_action),
+++++++-            )
+++++++-        
+++++++-        return rollout
+++++++-
+++++++-if __name__ == '__main__':
+++++++-    c = Intersection.from_args(globals(), locals())
+++++++-    c.setdefaults(
+++++++-        n_steps=200,
+++++++-        step_save=5,
+++++++-
+++++++-        depart_speed=0,
+++++++-        max_speed=13,
+++++++-        max_dist=100,
+++++++-        max_accel=1.5,
+++++++-        max_decel=3.5,
+++++++-        sim_step=0.5,
+++++++-        generic_type=True,
+++++++-        n_actions=3,
+++++++-
+++++++-        adv_norm=False,
+++++++-        batch_concat=True,
+++++++-
+++++++-        render=False,
+++++++-
+++++++-        warmup_steps=100,
+++++++-        horizon=2000,
+++++++-        directions='4way',
+++++++-        av_frac=0.15,
+++++++-        handcraft=False,
+++++++-        handcraft_tl=None,
+++++++-        flow_rate=700,
+++++++-        length=100,
+++++++-        n_rows=1,
+++++++-        n_cols=1,
+++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
+++++++-
+++++++-        act_type='accel_discrete',
+++++++-        low=-1,
+++++++-
+++++++-        alg=PG,
+++++++-        n_gds=1,
+++++++-        lr=1e-3,
+++++++-        gamma=0.99,
+++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++-
+++++++-        enter_length=False,
+++++++-        short_exit=False,
+++++++-
+++++++-        rew_type='outflow',
+++++++-        norm_reward=True,
+++++++-        center_reward=True,
+++++++-        multi_flowrate=False,
+++++++-        opt='RMSprop',
+++++++-
+++++++-        obs_tail=True,
+++++++-        obs_next_cross_platoons=1,
+++++++-
+++++++-        beta=0,
+++++++-        scale_pet=1,
+++++++-        scale_drac=1,
+++++++-        seed_np=False,
+++++++-        seed_torch = False,
+++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++-    )
+++++++-
+++++++-    if c.seed_torch:
+++++++-        # Set seed for PyTorch CPU operations
+++++++-        torch.manual_seed(c.seed_torch)
+++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++-        if torch.cuda.is_available():
+++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++-    if c.seed_np:
+++++++-        np.random.seed(c.seed_np)
+++++++-
+++++++-    if c.directions == '4way':
+++++++-        c.directions = ['up', 'right', 'down', 'left']
+++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
+++++++-    if c.mrtl:
+++++++-        c._n_obs += 1
+++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
+++++++-    c.redef_sumo = 'length_range' in c
+++++++-    c.run()
+++++++\ No newline at end of file
+++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++index d4c3dac..2400eae 100644
+++++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++@@ -1,600 +1,11908 @@
+++++++-diff --git a/README.md b/README.md
+++++++-index b591747..127f484 100644
+++++++---- a/README.md
+++++++-+++ b/README.md
+++++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
+++++++- ### 1.2 Set the environmental variables
+++++++- ```
+++++++- # Code directory
+++++++--export F=automatic_vehicular_control/automatic_vehicular_control
+++++++-+export F=automatic_vehicular_control
+++++++- 
+++++++- # Results directory extracted from the zip file
+++++++- export R=results
+++++++-@@ -48,10 +48,8 @@ export R=results
+++++++- ## 2. Directory Structure
+++++++- 
+++++++- The code directory structure is
+++++++--```
+++++++-+``` 
+++++++- automatic_vehicular_control/
+++++++--│
+++++++--├── automatic_vehicular_control/
+++++++- │   ├── __pycache__/                # Compiled Python files
+++++++- │   ├── evaluations/                # Evaluation results and metrics
+++++++- │   ├── models/                     # Model checkpoints
+++++++ diff --git a/env.py b/env.py
+++++++-index 4ab3d95..c83a674 100644
++++++++index c83a674..3ef7822 100644
+++++++ --- a/env.py
+++++++ +++ b/env.py
+++++++-@@ -724,9 +724,11 @@ class TrafficState:
+++++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
+++++++- 
+++++++-         segments = {}
+++++++-+        
+++++++-         def add_from_to(from_, to):
+++++++-             from_.tos.add(to)
+++++++-             to.froms.add(from_)
+++++++-+            
+++++++-         for con in map(values_str_to_val, net.children('connection')):
+++++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
+++++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
+++++++-@@ -888,89 +890,109 @@ class TrafficState:
+++++++- 
+++++++-     def step(self):
+++++++-         """
+++++++--        Take a simulation step and update state
+++++++-+        Take a simulation step and update state.
+++++++-         """
+++++++--        c = self.c
+++++++--        tc = self.tc
+++++++--        subscribes = self.subscribes
+++++++-+        c = self.c  # Configuration object for the simulation
+++++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
+++++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
+++++++- 
+++++++-         # Actual SUMO step
+++++++--        tc.simulationStep()
+++++++--        sim_res = subscribes.sim.get()
+++++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
+++++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
+++++++- 
+++++++-+        # Clear references to current vehicle edges and lanes for the next update
+++++++-         for veh in self.vehicles:
+++++++--            veh.unvar('edge', 'lane')
+++++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
+++++++-+
+++++++-+        # Clear current vehicle data from edges and lanes
+++++++-         for ent in itertools.chain(self.edges, self.lanes):
+++++++--            ent.vehicles.clear()
+++++++--            ent.positions.clear()
+++++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
+++++++-+            ent.positions.clear()  # Clear vehicle positions
+++++++- 
+++++++-+        # Update traffic light states
+++++++-         for tl_id, tl in self.traffic_lights.items():
+++++++--            tl.update(subscribes.tl.get(tl_id))
+++++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
+++++++- 
+++++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
+++++++-         for veh_id in sim_res.loaded_vehicles_ids:
+++++++--            flow_id, _ = veh_id.rsplit('.')
+++++++--            flow = self.flows[flow_id]
+++++++--            flow.backlog.add(veh_id)
+++++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
+++++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
+++++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
+++++++- 
+++++++-+        # Initialize a set for newly departed vehicles
+++++++-         self.new_departed = set()
+++++++-+
+++++++-+        # Handle vehicles that have departed (entered the network)
+++++++-         for veh_id in sim_res.departed_vehicles_ids:
+++++++--            subscribes.veh.subscribe(veh_id)
+++++++--            type_id = tc.vehicle.getTypeID(veh_id)
+++++++--            # import pdb; pdb.set_trace()
+++++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
+++++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
+++++++-+            # If vehicle type is 'generic', compute specific type
+++++++-             if type_id == 'generic':
+++++++-                 type_id = self.compute_type(veh_id)
+++++++--            type_ = self.types[type_id]
+++++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
+++++++--            length = tc.vehicle.getLength(veh_id)
+++++++--            road_id = tc.vehicle.getRoadID(veh_id)
+++++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
+++++++--            type_.vehicles.add(veh)
+++++++-+            type_ = self.types[type_id]  # Get vehicle type object
+++++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
+++++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
+++++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
+++++++-+
+++++++-+            # Create a new vehicle object and add it to the list of vehicles
+++++++-+            self.vehicles[veh_id] = veh = Vehicle(
+++++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
+++++++-+            )
+++++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
+++++++- 
+++++++-+            # Set color if rendering is enabled
+++++++-             if c.render:
+++++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
+++++++--                self.set_color(veh, color_fn(veh))
+++++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
+++++++- 
+++++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
+++++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
+++++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
+++++++-+
+++++++-+            # Add to new_departed set
+++++++-             self.new_departed.add(veh)
+++++++-+
+++++++-+            # Remove vehicle from backlog if necessary
+++++++-             if '.' in veh_id:
+++++++-                 flow_id, _ = veh_id.rsplit('.')
+++++++-                 if flow_id in self.flows:
+++++++-                     flow = self.flows[flow_id]
+++++++-                     flow.backlog.remove(veh_id)
+++++++- 
+++++++-+        # Handle newly arrived and collided vehicles
+++++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
+++++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+++++++-+        
+++++++-+        # Remove newly arrived vehicles from tracking if they collided
+++++++-         for veh in self.new_arrived:
+++++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
+++++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
+++++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
+++++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
+++++++- 
+++++++-+        # Update vehicle positions on edges and lanes
+++++++-         for veh_id, veh in self.vehicles.items():
+++++++--            veh.prev_speed = veh.get('speed', None)
+++++++--            veh.update(subscribes.veh.get(veh_id))
+++++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
+++++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
+++++++-             if veh_id not in sim_res.colliding_vehicles_ids:
+++++++--                edge = self.edges[veh.road_id]
+++++++--                edge.vehicles.append(veh)
+++++++--                veh.edge = edge
+++++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
+++++++--            # edge = self.edges[veh.road_id]
+++++++--            # edge.vehicles.append(veh)
+++++++--            # veh.edge = edge
+++++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
+++++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
+++++++-+                veh.edge = edge  # Set vehicle's edge attribute
+++++++- 
+++++++-+        # Update vehicle sorting and lane positions
+++++++-         for edge in self.edges:
+++++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
+++++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
+++++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
+++++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
+++++++-             for edge_i, veh in enumerate(edge.vehicles):
+++++++--                veh.edge_i = edge_i
+++++++--                veh.lane = lane = edge.lanes[veh.lane_index]
+++++++--                veh.lane_i = len(lane.vehicles)
+++++++--                lane.vehicles.append(veh)
+++++++--                lane.positions.append(veh.laneposition)
+++++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
+++++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
+++++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
+++++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
+++++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
+++++++- 
+++++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
+++++++-         self.all_arrived.append(self.new_arrived)
+++++++-         self.all_departed.append(self.new_departed)
+++++++-         self.all_collided.append(self.new_collided)
+++++++--
+++++++-+            
+++++++-     def reset(self, tc):
+++++++-         self.tc = tc
+++++++-         self.subscribes.clear()
+++++++-@@ -1043,6 +1065,7 @@ class Env:
+++++++-     """
+++++++-     Offers a similar reinforcement learning environment interface as gym.Env
+++++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
+++++++-+    c: Ring class
+++++++-     """
+++++++-     def __init__(self, c):
+++++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
+++++++-@@ -1056,6 +1079,7 @@ class Env:
+++++++-             if c.get('save_agent'):
+++++++-                 self._agent_info = []
+++++++-         self._step = 0
+++++++-+        self.mean_speed = 0
+++++++- 
+++++++-     def def_sumo(self, *args, **kwargs):
+++++++-         """ Override this with code defining the SUMO network """
+++++++-@@ -1094,49 +1118,91 @@ class Env:
+++++++-         """
+++++++-         return True
+++++++- 
+++++++-+   # Method to reset or initialize the SUMO traffic simulation environment
+++++++-     def reset_sumo(self):
+++++++-+        # Shortcuts for configuration and SUMO definition objects
+++++++-         c = self.c
+++++++-         sumo_def = self.sumo_def
+++++++--
+++++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+++++++-+        
+++++++-+        # Determine if new SUMO definitions need to be generated
+++++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
+++++++-+        
+++++++-         if generate_def:
+++++++--            kwargs = self.def_sumo()
+++++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
+++++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
+++++++-+            # Generate new definitions if necessary
+++++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
+++++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
+++++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++++++++@@ -852,12 +852,15 @@ class TrafficState:
++++++++         subscribes.sim = SubscribeDef(tc.simulation, [
++++++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
++++++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
+++++++ +        
+++++++-+        # Start SUMO with the current traffic controller (tc)
+++++++-         self.tc = sumo_def.start_sumo(self.tc)
++++++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
++++++++             TL.red_yellow_green_state])
+++++++ +        
+++++++-         if generate_def:
+++++++-+            # If new definitions were generated, store relevant SUMO file paths
+++++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
+++++++-+            
+++++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
+++++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
+++++++--            self.ts = TrafficState(c, self.tc, **defs)
+++++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
+++++++-         else:
+++++++-+            # If not generating new definitions, simply reset the existing traffic state
+++++++-             self.ts.reset(self.tc)
++++++++         subscribes.veh = SubscribeDef(tc.vehicle, [
++++++++             V.road_id, V.lane_index, V.laneposition,
++++++++             V.speed, V.position, V.angle,
++++++++             V.fuelconsumption, V.noxemission])
+++++++ +        
+++++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
+++++++-         self.ts.setup()
+++++++-+        
+++++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+++++++-         success = self.init_vehicles()
+++++++-+        
+++++++-+        # Return whether the SUMO reset and vehicle initialization were successful
+++++++-         return success
++++++++         for tl_id in self.traffic_lights.keys():
++++++++             subscribes.tl.subscribe(tl_id)
+++++++  
+++++++-+    # Method to initialize the environment after SUMO reset
+++++++-     def init_env(self):
+++++++-+        # Reference to the traffic state
+++++++-         ts = self.ts
+++++++-+    
+++++++-+        # Create an empty data structure to store rollout information
+++++++-         self.rollout_info = NamedArrays()
+++++++-+        
+++++++-+        # Turn off all traffic lights in the network
+++++++-         for tl in ts.traffic_lights:
+++++++--            ts.set_program(tl, 'off')
+++++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
+++++++-+        
+++++++-+        # Reset the step counter to 0
+++++++-         self._step = 0
+++++++-+        
+++++++-+        # Take the first step in the simulation
+++++++-         ret = self.step()
+++++++-+        
+++++++-+        # Run the simulation for a number of warmup steps
+++++++-         for _ in range(self.c.warmup_steps):
+++++++--            ret = self.step()
+++++++-+            ret = self.step()  # Advance the simulation one step
+++++++-+            
+++++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
+++++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
+++++++-                 return None
+++++++-+        
+++++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
+++++++-         for tl in ts.traffic_lights:
+++++++--            ts.set_program(tl, '1')
+++++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
+++++++-+        
+++++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
+++++++-         if isinstance(ret, tuple):
+++++++--            return ret[0]
+++++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
+++++++--
+++++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
+++++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
+++++++-+        
+++++++-+    # Reset the entire environment, retrying until successful
+++++++-     def reset(self):
+++++++--        while True:
+++++++-+        self.mean_speed = 0
+++++++-+        while True:  # Infinite loop until the environment is successfully reset
+++++++-+            # Attempt to reset the SUMO simulation
++++++++@@ -1197,6 +1200,7 @@ class Env:
++++++++         while True:  # Infinite loop until the environment is successfully reset
++++++++             # Attempt to reset the SUMO simulation
+++++++              if not self.reset_sumo():
+++++++--                continue
+++++++-+                continue  # If reset_sumo fails, retry the loop
+++++++-+            
+++++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++++++-             if (obs := self.init_env()) is not None:
+++++++--                return obs
+++++++-+                return obs  # Successfully initialized, return the observation
+++++++-+
+++++++- 
+++++++-     def append_step_info(self):
+++++++-         """
+++++++-@@ -1231,6 +1297,8 @@ class Env:
+++++++- class NormEnv(gym.Env):
+++++++-     """
+++++++-     Reward normalization with running average https://github.com/joschu/modular_rl
+++++++-+    self.c: Ring parameters 
+++++++-+    self.env: RingEnv class
+++++++-     """
+++++++-     def __init__(self, c, env):
+++++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
+++++++++                
++++++++                 continue  # If reset_sumo fails, retry the loop
++++++++             
++++++++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++++++ diff --git a/exp.py b/exp.py
+++++++-index ead4652..7f7cee5 100644
++++++++index 7f7cee5..6f16d66 100644
+++++++ --- a/exp.py
+++++++ +++ b/exp.py
+++++++-@@ -169,9 +169,9 @@ class Main(Config):
+++++++- 
+++++++-     def on_train_start(c):
+++++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
+++++++--        c.setdefaults(alg='Algorithm')
+++++++--        c._env = c.create_env()
+++++++--
+++++++-+        c.setdefaults(alg='Algorithm') 
+++++++-+        c._env = c.create_env() # Create NormEnv
+++++++-+ 
+++++++-         # Instantiate the algorithm (e.g., PPO, DQN)
+++++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
+++++++-         c.set_model()
+++++++-@@ -222,8 +222,8 @@ class Main(Config):
+++++++- 
+++++++-     def on_step_start(c, stats={}):
+++++++-         # Update the learning rate and log stats at the start of a training step
+++++++--        lr = c._lr
+++++++--        for g in c._opt.param_groups:
+++++++-+        lr = c._lr # Update Learning Rate
+++++++-+        for g in c._opt.param_groups: # Log Statistics
+++++++-             g['lr'] = float(lr)
+++++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
+++++++- 
+++++++-@@ -285,10 +285,14 @@ class Main(Config):
++++++++@@ -285,7 +285,6 @@ class Main(Config):
+++++++              ret = dict(obs=ret)
+++++++          rollout = NamedArrays()
+++++++          rollout.append(**ret)
+++++++--
+++++++-+        rollout_flow_each_step = []
++++++++-        rollout_flow_each_step = []
+++++++          done = False
+++++++          a_space = c.action_space
+++++++          step = 0
++++++++@@ -406,9 +405,8 @@ class Main(Config):
++++++++ 
++++++++     def train(c):
++++++++         # Main training loop
++++++++-        c.on_train_start()
+++++++++        c.on_train_start() # Ring Env
++++++++         while c._i < c.n_steps:
++++++++-            c.on_step_start() # save stat 
++++++++             with torch.no_grad():
++++++++                 # Collect rollouts without computing gradients
++++++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++++@@ -497,3 +495,32 @@ class Main(Config):
++++++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
++++++++             c.train()
++++++++         c.log('job done!')
+++++++++
+++++++++    def run_2(c):
+++++++++        # Determine whether to train or evaluate based on configuration
+++++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
+++++++++        
+++++++++        c.on_train_start()
+++++++++        c._env = c.create_env() # Create NormEnv
+++++++++        ret = c._env.reset()
+++++++++        c.set_model()
+++++++++        step = 0
+++++++ +        density = 20/(250*1e-3)
+++++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
+++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+++++++-+
+++++++-         while step < c.horizon + c.skip_stat_steps and not done:
+++++++-             # Generate an action from the model's policy
+++++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
+++++++-@@ -309,6 +313,12 @@ class Main(Config):
+++++++-             rollout.append(**ret)
+++++++-             step += 1
+++++++-         # Collect stats from the environment
+++++++++        done = False
+++++++++        while step < c.horizon + c.skip_stat_steps and not done:
+++++++++            # Take a step in the environment
+++++++++            ret = c._env.step()
+++++++++            if isinstance(ret, tuple):
+++++++++                obs, reward, done, info = ret
+++++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
+++++++++            done = ret.setdefault('done', False)
+++++++++            step += 1
+++++++++        # Collect stats from the environment
+++++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+++++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+++++++ +        density = 20/(250 * 1e-3)
+++++++ +        vehicle_flow = c._env.mean_speed * density 
+++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+++++++-+
+++++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
+++++++-         return rollout, stats
++++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
++++++++deleted file mode 100644
++++++++index 6b9ba52..0000000
++++++++--- a/highway_bottleneck.py
+++++++++++ /dev/null
++++++++@@ -1,381 +0,0 @@
++++++++-from automatic_vehicular_control.exp import *
++++++++-from automatic_vehicular_control.env import *
++++++++-from automatic_vehicular_control.u import *
++++++++-
++++++++-class BNeckEnv(Env):
++++++++-    def def_sumo(self):
++++++++-        c = self.c
++++++++-        nodes = E('nodes',
++++++++-            E('node', id='n_0', x=0, y=0), *(
++++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
++++++++-        ))
++++++++-        edges = E('edges', *(
++++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
++++++++-                'numLanes': n_lane,
++++++++-                'speed': c.max_speed
++++++++-            }) for i, n_lane in enumerate(c.n_lanes)
++++++++-        ))
++++++++-        connections = E('connections', *(
++++++++-            E('connection', **{
++++++++-                'from': prev.id,
++++++++-                'to': curr.id,
++++++++-                'fromLane': i,
++++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
++++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
++++++++-        ))
++++++++-
++++++++-        if c.split_flow:
++++++++-            n_inflow_lanes = c.n_lanes[0]
++++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
++++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
++++++++-                for i in range(n_inflow_lanes)
++++++++-            ]
++++++++-        else:
++++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
++++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
++++++++-            ]
++++++++-        routes = E('routes',
++++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
++++++++-            *flows
++++++++-        )
++++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
++++++++-        additional = E('additional',
++++++++-            E('vType', id='generic', **idm_params),
++++++++-            E('vType', id='rl', **idm_params),
++++++++-            E('vType', id='human', **idm_params),
++++++++-        )
++++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++++-
++++++++-    def reset_sumo(self):
++++++++-        c = self.c
++++++++-        if c.flow_rate_range:
++++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
++++++++-        ret = super().reset_sumo()
++++++++-        if c.vinitsky:
++++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
++++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
++++++++-                for i_start in range(round(edge.length) // c.piece_length)
++++++++-                for lane in edge.lanes
++++++++-            ]
++++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
++++++++-            self.last_outflows = []
++++++++-        return ret
++++++++-
++++++++-    def step(self, action=[]):
++++++++-        c = self.c
++++++++-        ts = self.ts
++++++++-        max_dist = 100
++++++++-        max_speed = c.max_speed
++++++++-        human_type = ts.types.human
++++++++-        rl_type = ts.types.rl
++++++++-
++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++-        if c.vinitsky:
++++++++-            if len(action):
++++++++-                assert len(action) == len(self.control_lanes)
++++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
++++++++-                    self.control_lanes[lane, piece_start] = np.clip(
++++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
++++++++-                        0.1, max_speed
++++++++-                    )
++++++++-                for veh in prev_rls:
++++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
++++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
++++++++-        else:
++++++++-            for veh, act in zip(prev_rls, action):
++++++++-                if c.handcraft:
++++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
++++++++-                    next_lane = lane.next(veh.route)
++++++++-                    level = 1
++++++++-                    if next_lane and next_lane.get('junction'):
++++++++-                        merge_dist = lane.length - veh.laneposition
++++++++-                        if merge_dist < c.handcraft:
++++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
++++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
++++++++-                                level = 0
++++++++-                    if c.act_type.startswith('accel'):
++++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++-                    else:
++++++++-                        ts.set_max_speed(veh, max_speed * level)
++++++++-                    continue
++++++++-                if not isinstance(act, (int, np.integer)):
++++++++-                    act = (act - c.low) / (1 - c.low)
++++++++-                if c.act_type.startswith('accel'):
++++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++-                else:
++++++++-                    if c.act_type == 'continuous':
++++++++-                        level = act[0]
++++++++-                    elif c.act_type == 'discretize':
++++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++++-                    elif c.act_type == 'discrete':
++++++++-                        level = act / (c.n_actions - 1)
++++++++-                    ts.set_max_speed(veh, max_speed * level)
++++++++-
++++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
++++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
++++++++-
++++++++-        super().step()
++++++++-
++++++++-        if c.vinitsky:
++++++++-            n_last_outflows = 20
++++++++-            max_vehs = 4
++++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
++++++++-            obs = []
++++++++-            for lane, piece_start in self.obs_lanes:
++++++++-                piece_end = piece_start + c.piece_length
++++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
++++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
++++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
++++++++-                obs.extend([
++++++++-                    len(lane_humans) / max_vehs,
++++++++-                    len(lane_avs) / max_vehs,
++++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
++++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
++++++++-                ])
++++++++-            if len(self.last_outflows) == n_last_outflows:
++++++++-                self.last_outflows = self.last_outflows[1:]
++++++++-            self.last_outflows.append(len(ts.new_arrived))
++++++++-            reward = np.mean(self.last_outflows)
++++++++-            obs.append(reward / max_veh_outflows)
++++++++-            obs = np.array(obs, dtype=np.float32)
++++++++-            assert 0 <= obs.min() and obs.max() <= 1
++++++++-            return obs, reward, False, None
++++++++-        route = nexti(ts.routes)
++++++++-        obs, ids = [], []
++++++++-        default_close = [0, max_speed]
++++++++-        default_far = [max_dist, 0]
++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++++-            merge_dist = max_dist
++++++++-            default_human = default_far
++++++++-
++++++++-            other_info = {}
++++++++-            next_lane = lane.next(veh.route)
++++++++-            if next_lane and next_lane.get('junction'):
++++++++-                merge_dist = lane.length - veh.laneposition
++++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
++++++++-                # Look for veh on other lane but do not extend past that lane
++++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
++++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
++++++++-                    if other_veh.type is rl_type:
++++++++-                        default_human = default_close
++++++++-                        break
++++++++-
++++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
++++++++-            ids.append(veh.id)
++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++-        
++++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++-
++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++-
++++++++-        raw_pet = self.calc_pet()
++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++-        pet = np.clip(pet, -1, 1)
++++++++-
++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++-        
++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++-        return returned
++++++++-        
++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++-    
++++++++-    def calc_ttc(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        ttcs = []
++++++++-        for v in cur_veh_list:
++++++++-            leader, headway = v.leader()
++++++++-            v_speed = v.speed
++++++++-            leader_speed = leader.speed
++++++++-            if leader_speed < v_speed:
++++++++-                ttc =  headway/(v_speed-leader_speed)
++++++++-            else:
++++++++-                ttc = np.nan
++++++++-            ttcs.append(ttc)
++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++-        return fleet_ttc
++++++++-    
++++++++-    def calc_drac(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        dracs = []
++++++++-        for v in cur_veh_list:
++++++++-            leader, headway = v.leader()
++++++++-            v_speed = v.speed
++++++++-            leader_speed = leader.speed
++++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++-            dracs.append(drac)
++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++-        return fleet_drac
++++++++-
++++++++-    def calc_pet(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        pets = []
++++++++-        for v in cur_veh_list:
++++++++-            leader, headway = v.leader()
++++++++-            v_speed = v.speed
++++++++-            if v_speed > 1e-16:
++++++++-                pet = headway/(v_speed)
++++++++-                pets.append(pet)
++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++-        return fleet_pet
++++++++-
++++++++-class BNeck(Main):
++++++++-    def create_env(c):
++++++++-        return BNeckEnv(c)
++++++++-
++++++++-    @property
++++++++-    def observation_space(c):
++++++++-        low = np.full(c._n_obs, c.low)
++++++++-        return Box(low, np.ones_like(low))
++++++++-
++++++++-    @property
++++++++-    def action_space(c):
++++++++-        if c.vinitsky:
++++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++++-            assert c.lc_av in [False, 'binary']
++++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++++-            return Discrete(c.n_actions)
++++++++-
++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++-        if c.vinitsky:
++++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++-        step_obs_ = rollout.obs
++++++++-        step_obs = step_obs_[:-1]
++++++++-
++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++-
++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++-
++++++++-        step_id_ = rollout.pop('id')
++++++++-        id = np.concatenate(step_id_[:-1])
++++++++-        id_unique = np.unique(id)
++++++++-
++++++++-        reward = np.array(rollout.pop('reward'))
++++++++-
++++++++-        log(**stats)
++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++-        log(
++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++-            n_veh_unique=len(id_unique),
++++++++-            
++++++++-            reward_mean=np.mean(reward),
++++++++-            reward_std=np.std(reward),        
++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++-            ssm_std=np.std(rollout.ssm),
++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++-
++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++-            # res_action = np.mean(rollout.res_action),
++++++++-            )
++++++++-        return rollout
++++++++-
++++++++-if __name__ == '__main__':
++++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
++++++++-        warmup_steps=1000,
++++++++-        horizon=2000,
++++++++-        n_steps=100,
++++++++-        step_save=5,
++++++++-
++++++++-        av_frac=0.2,
++++++++-        sim_step=0.5,
++++++++-        depart_speed=0,
++++++++-        edge_lengths=[100, 100, 50],
++++++++-        n_lanes=[4, 2, 1],
++++++++-        max_speed=30,
++++++++-
++++++++-        lc_av=False,
++++++++-        flow_rate=2300,
++++++++-        flow_rate_range=None,
++++++++-        split_flow=True,
++++++++-        generic_type='rand',
++++++++-        speed_mode=SPEED_MODE.all_checks,
++++++++-        lc_mode=LC_MODE.off,
++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++-
++++++++-        veh_junction=False,
++++++++-        act_type='accel_discrete',
++++++++-        max_accel=2.6,
++++++++-        max_decel=4.5,
++++++++-        tau=1.0,
++++++++-        min_gap=2.5,
++++++++-        delta=4,
++++++++-        n_actions=3,
++++++++-        low=-1,
++++++++-        handcraft=False,
++++++++-        vinitsky=False,
++++++++-
++++++++-        render=False,
++++++++-
++++++++-        alg=PG,
++++++++-        lr=1e-3,
++++++++-
++++++++-        gamma=0.99,
++++++++-        adv_norm=False,
++++++++-        batch_concat=True,
++++++++-
++++++++-        beta=0,
++++++++-        scale_ttc=1,
++++++++-        scale_drac=1,
++++++++-        seed_np=False,
++++++++-        seed_torch = False,
++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++-
++++++++-    )
++++++++-    
++++++++-    if c.seed_torch:
++++++++-        # Set seed for PyTorch CPU operations
++++++++-        torch.manual_seed(c.seed_torch)
++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++-        if torch.cuda.is_available():
++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++-    if c.seed_np:
++++++++-        np.random.seed(c.seed_np)
++++++++-        
++++++++-    if c.vinitsky:
++++++++-        c.piece_length = 20
++++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
++++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
++++++++-        c._n_action = sum(n_actions[:-1])
++++++++-        c._n_obs = sum(n_actions) * 4 + 1
++++++++-        c.batch_concat = False
++++++++-    else:
++++++++-        c._n_obs = 2 + 2 + 2
++++++++-        
++++++++-    if c.mrtl:
++++++++-        c._n_obs += 1 # modified for mrtl related
++++++++-        
++++++++-    c.redef_sumo = bool(c.flow_rate_range)
++++++++-    c.run()
++++++++\ No newline at end of file
++++++++diff --git a/highway_ramp.py b/highway_ramp.py
++++++++deleted file mode 100644
++++++++index ef0358f..0000000
++++++++--- a/highway_ramp.py
+++++++++++ /dev/null
++++++++@@ -1,325 +0,0 @@
++++++++-from automatic_vehicular_control.exp import *
++++++++-from automatic_vehicular_control.env import *
++++++++-from automatic_vehicular_control.u import *
++++++++-
++++++++-class RampEnv(Env):
++++++++-    # https://flow-project.github.io/papers/08569485.pdf
++++++++-    def def_sumo(self):
++++++++-        c = self.c
++++++++-        builder = NetBuilder()
++++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
++++++++-            (0, 0),
++++++++-            (c.premerge_distance, 0),
++++++++-            (c.premerge_distance + c.merge_distance, 0),
++++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
++++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
++++++++-        ])
++++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
++++++++-            {}, {'numLanes': 2}, {}
++++++++-        ], lane_maps=[
++++++++-            {0: 1}, {0: 0, 1: 0}
++++++++-        ], route_id='highway')
++++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
++++++++-            {}, {'numLanes': 2}, {}
++++++++-        ], lane_maps=[
++++++++-            {0: 0}, {0: 0, 1: 0}
++++++++-        ], route_id='ramp')
++++++++-        nodes, edges, connections, routes = builder.build()
++++++++-        nodes[2].type = 'zipper'
++++++++-
++++++++-        routes = E('routes',
++++++++-            *routes,
++++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
++++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
++++++++-        )
++++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
++++++++-        additional = E('additional',
++++++++-            E('vType', id='generic', **idm),
++++++++-            E('vType', id='rl', **idm),
++++++++-            E('vType', id='human', **idm),
++++++++-        )
++++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++++-
++++++++-    def step(self, action=[]):
++++++++-        c = self.c
++++++++-        ts = self.ts
++++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
++++++++-        max_speed = c.max_speed
++++++++-        human_type = ts.types.human
++++++++-        rl_type = ts.types.rl
++++++++-
++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++-        for rl, act in zip(prev_rls, action):
++++++++-            if c.handcraft:
++++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
++++++++-                leader, dist = rl.leader()
++++++++-                level = 1
++++++++-                if edge.id == 'e_n_0.0_n_400.0':
++++++++-                    if rl.laneposition < 100:
++++++++-                        leaders = list(rl.leaders())
++++++++-                        if len(leaders) > 20:
++++++++-                            level = 0
++++++++-                        else:
++++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
++++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++-                continue
++++++++-            if not isinstance(act, (int, np.integer)):
++++++++-                act = (act - c.low) / (1 - c.low)
++++++++-            if c.act_type.startswith('accel'):
++++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++-            else:
++++++++-                if c.act_type == 'continuous':
++++++++-                    level = act[0]
++++++++-                elif c.act_type == 'discretize':
++++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++++-                elif c.act_type == 'discrete':
++++++++-                    level = act / (c.n_actions - 1)
++++++++-                ts.set_max_speed(rl, max_speed * level)
++++++++-
++++++++-        super().step()
++++++++-
++++++++-        route = ts.routes.highway
++++++++-        obs, ids = [], []
++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++++-            if hasattr(veh, 'edge'):
++++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++++-                merge_dist = max_dist
++++++++-
++++++++-                lead_speed = follow_speed = other_speed = 0
++++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
++++++++-
++++++++-                leader, dist = veh.leader()
++++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
++++++++-
++++++++-                follower, dist = veh.follower()
++++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
++++++++-
++++++++-                if c.global_obs:
++++++++-                    jun_edge = edge.next(route)
++++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
++++++++-                        jun_edge = jun_edge.next(route)
++++++++-                    if jun_edge:
++++++++-                        merge_dist = lane.length - veh.laneposition
++++++++-                        next_edge = edge.next(route)
++++++++-                        while next_edge is not jun_edge:
++++++++-                            merge_dist += next_edge.length
++++++++-                            next_edge = next_edge.next(route)
++++++++-
++++++++-                        other_lane = jun_edge.lanes[0]
++++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
++++++++-                            other_speed = other_veh.speed
++++++++-                            break
++++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
++++++++-                else:
++++++++-                    next_lane = lane.next(route)
++++++++-                    if next_lane and next_lane.get('junction'):
++++++++-                        if len(edge.lanes) == 2:
++++++++-                            other_lane = edge.lanes[0]
++++++++-                            pos = veh.laneposition
++++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
++++++++-                                other_speed = other_veh.speed
++++++++-                                break
++++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
++++++++-                ids.append(veh.id)
++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
++++++++-        if c.mrtl:
++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++-        
++++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++-
++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++-
++++++++-        raw_pet = self.calc_pet()
++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++-        pet = np.clip(pet, -1, 1)
++++++++-
++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++-        
++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++-        return returned
++++++++-        
++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++-    
++++++++-    def calc_ttc(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        ttcs = []
++++++++-        for v in cur_veh_list:
++++++++-            if hasattr(v, 'edge'):
++++++++-                leader, headway = v.leader()
++++++++-                if leader:
++++++++-                    v_speed = v.speed
++++++++-                    leader_speed = leader.speed
++++++++-                    if leader_speed < v_speed:
++++++++-                        ttc =  headway/(v_speed-leader_speed)
++++++++-                    else:
++++++++-                        ttc = np.nan
++++++++-                    ttcs.append(ttc)
++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++-        return fleet_ttc
++++++++-    
++++++++-    def calc_drac(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        dracs = []
++++++++-        for v in cur_veh_list:
++++++++-            if hasattr(v, 'edge'):
++++++++-                leader, headway = v.leader()
++++++++-                if leader:
++++++++-                    v_speed = v.speed
++++++++-                    leader_speed = leader.speed
++++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++-                    dracs.append(drac)
++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++-        return fleet_drac
++++++++-
++++++++-    def calc_pet(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        pets = []
++++++++-        for v in cur_veh_list:
++++++++-            if hasattr(v, 'edge'):
++++++++-                leader, headway = v.leader()
++++++++-                if leader:
++++++++-                    v_speed = v.speed
++++++++-                    if v_speed > 1e-16:
++++++++-                        pet = headway/(v_speed)
++++++++-                        pets.append(pet)
++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
++++++++-        return fleet_pet
++++++++-
++++++++-class Ramp(Main):
++++++++-    def create_env(c):
++++++++-        return RampEnv(c)
++++++++-
++++++++-    @property
++++++++-    def observation_space(c):
++++++++-        low = np.full(c._n_obs, c.low)
++++++++-        return Box(low, np.ones_like(low))
++++++++-
++++++++-    @property
++++++++-    def action_space(c):
++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++++-            return Discrete(c.n_actions)
++++++++-
++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++-        step_obs_ = rollout.obs
++++++++-        step_obs = step_obs_[:-1]
++++++++-
++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++-
++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++-
++++++++-        step_id_ = rollout.pop('id')
++++++++-        id = np.concatenate(step_id_[:-1])
++++++++-        id_unique = np.unique(id)
++++++++-
++++++++-        reward = np.array(rollout.pop('reward'))
++++++++-
++++++++-        log(**stats)
++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++-        log(
++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++-            n_veh_unique=len(id_unique),
++++++++-            
++++++++-            reward_mean=np.mean(reward),
++++++++-            reward_std=np.std(reward),        
++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++-            ssm_std=np.std(rollout.ssm),
++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++-
++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++-            # res_action = np.mean(rollout.res_action),
++++++++-            )
++++++++-        return rollout
++++++++-
++++++++-if __name__ == '__main__':
++++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
++++++++-        warmup_steps=100,
++++++++-        horizon=2000,
++++++++-        n_steps=100,
++++++++-        step_save=5,
++++++++-
++++++++-        premerge_distance=400,
++++++++-        merge_distance=100,
++++++++-        postmerge_distance=30,
++++++++-        av_frac=0.1,
++++++++-        sim_step=0.5,
++++++++-        max_speed=30,
++++++++-        highway_depart_speed=10,
++++++++-        ramp_depart_speed=0,
++++++++-        highway_flow_rate=2000,
++++++++-        ramp_flow_rate=300,
++++++++-        global_obs=False,
++++++++-        handcraft=False,
++++++++-
++++++++-        generic_type='default',
++++++++-        speed_mode=SPEED_MODE.all_checks,
++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++-
++++++++-        act_type='accel_discrete',
++++++++-        max_accel=1,
++++++++-        max_decel=1.5,
++++++++-        n_actions=3,
++++++++-        low=-1,
++++++++-
++++++++-        render=False,
++++++++-
++++++++-        alg=PG,
++++++++-        lr=1e-3,
++++++++-
++++++++-        gamma=0.99,
++++++++-        adv_norm=False,
++++++++-        batch_concat=True,
++++++++-
++++++++-        beta=0,
++++++++-        scale_ttc=1,
++++++++-        scale_drac=1,
++++++++-        seed_np=False,
++++++++-        seed_torch = False,
++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++-
++++++++-    )
++++++++-    
++++++++-    if c.seed_torch:
++++++++-        # Set seed for PyTorch CPU operations
++++++++-        torch.manual_seed(c.seed_torch)
++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++-        if torch.cuda.is_available():
++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++-    if c.seed_np:
++++++++-        np.random.seed(c.seed_np)
++++++++-        
++++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
++++++++-    if c.mrtl:
++++++++-        c._n_obs += 1 # modified for mrtl related
++++++++-    c.run()
++++++++\ No newline at end of file
++++++++diff --git a/intersection.py b/intersection.py
++++++++deleted file mode 100644
++++++++index e38a84f..0000000
++++++++--- a/intersection.py
+++++++++++ /dev/null
++++++++@@ -1,489 +0,0 @@
++++++++-from automatic_vehicular_control.u import *
++++++++-from automatic_vehicular_control.exp import *
++++++++-from automatic_vehicular_control.env import *
++++++++-
++++++++-class Platoon(Entity):
++++++++-    pass
++++++++-
++++++++-class IntersectionEnv(Env):
++++++++-    def def_sumo(self):
++++++++-        c = self.c
++++++++-
++++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
++++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
++++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
++++++++-        ] if params.get('vehsPerHour')]
++++++++-
++++++++-        builder = NetBuilder()
++++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
++++++++-        if c.enter_length:
++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++++-            xys[1:, :, 0] += c.enter_length - c.length
++++++++-            xys[:, 1:, 1] += c.enter_length - c.length
++++++++-            xys = xys.reshape(-1, 2)
++++++++-        if c.short_exit:
++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++++-            xys[-1, :, 0] += c.short_exit - c.length
++++++++-            xys[:, -1, 1] += c.short_exit - c.length
++++++++-            xys = xys.reshape(-1, 2)
++++++++-        nodes = builder.add_nodes(
++++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
++++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
++++++++-        # import pdb; pdb.set_trace()
++++++++-
++++++++-        tl = c.setdefault('tl', False)
++++++++-        if tl:
++++++++-            c.av_frac = 0
++++++++-            c.pop('av_range', None)
++++++++-            c.speed_mode = SPEED_MODE.all_checks
++++++++-
++++++++-        flows = []
++++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
++++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
++++++++-        for direction in c.directions:
++++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
++++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
++++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
++++++++-
++++++++-            edge_attrs = dict(priority=int(direction in priority))
++++++++-            if c.get('set_edge_speed', True):
++++++++-                edge_attrs['speed'] = c.max_speed
++++++++-
++++++++-            for i, chain in enumerate(chains[1:-1]):
++++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
++++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
++++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
++++++++-
++++++++-        tls = []
++++++++-        if tl:
++++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
++++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
++++++++-            tl_offset = c.get('tl_offset', 'auto')
++++++++-            yellow = c.get('yellow', 0.5)
++++++++-            if tl_offset == 'auto':
++++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
++++++++-            elif tl_offset == 'same':
++++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
++++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
++++++++-                node.type = 'traffic_light'
++++++++-                phase_multiple = len(c.directions) // 2
++++++++-                tls.append(E('tlLogic',
++++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
++++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
++++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
++++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
++++++++-                id=node.id, offset=offset, type='static', programID='1'))
++++++++-
++++++++-        nodes, edges, connections, routes = builder.build()
++++++++-        additional = E('additional', *types, *routes, *flows, *tls)
++++++++-        return super().def_sumo(nodes, edges, connections, additional)
++++++++-
++++++++-    def build_platoon(self):
++++++++-        ts = self.ts
++++++++-        rl_type = ts.types.rl
++++++++-        for route in ts.routes:
++++++++-            vehs = []
++++++++-            route_offset = 0
++++++++-            for edge in route.edges:
++++++++-                for veh in edge.vehicles:
++++++++-                    veh.route_position = route_offset + veh.laneposition
++++++++-                    vehs.append(veh)
++++++++-                route_offset += edge.length
++++++++-
++++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
++++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
++++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
++++++++-            rl_idxs, = rl_mask.nonzero()
++++++++-            split_idxs = 1 + rl_idxs
++++++++-
++++++++-            prev = None
++++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
++++++++-                if not len(vehs_i):
++++++++-                    continue # Last vehicle is RL, so the last split is empty
++++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
++++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
++++++++-                )
++++++++-                if prev is not None:
++++++++-                    prev.next = platoon
++++++++-                prev = platoon
++++++++-                for veh in vehs_i:
++++++++-                    veh.platoon = platoon
++++++++-            if prev is not None:
++++++++-                prev.next = None
++++++++-
++++++++-    def reset(self):
++++++++-        c = self.c
++++++++-        if c.e is False:
++++++++-            if 'length_range' in c:
++++++++-                min_, max_ = c.length_range
++++++++-                c.setdefaults(max_length=max_)
++++++++-                c.length = np.random.randint(min_, max_ + 1)
++++++++-            if 'av_range' in c:
++++++++-                min_, max_ = c.av_range
++++++++-                c.av_frac = np.random.uniform(min_, max_)
++++++++-        self.mp_tlast = 0
++++++++-        while not self.reset_sumo():
++++++++-            pass
++++++++-        ret = super().init_env()
++++++++-        return ret
++++++++-
++++++++-    def step(self, action=[]):
++++++++-        c = self.c
++++++++-        ts = self.ts
++++++++-        max_dist = c.max_dist
++++++++-        depart_speed = c.depart_speed
++++++++-        max_speed = c.max_speed
++++++++-
++++++++-        rl_type = ts.types.rl
++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++-
++++++++-        for rl, act in zip(prev_rls, action):
++++++++-            if c.handcraft or c.handcraft_tl:
++++++++-                route, lane = rl.route, rl.lane
++++++++-                junction = lane.next_junction
++++++++-                level = 1
++++++++-                if junction is not ts.sentinel_junction:
++++++++-                    dist = junction.route_position[route] - rl.route_position
++++++++-                    if c.handcraft:
++++++++-                        for cross_lane in lane.next_cross_lanes:
++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
++++++++-                    elif c.handcraft_tl and dist < 15:
++++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
++++++++-                        yellow_time = 0
++++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
++++++++-                        horizontal_go = 0 <= rem < t_h
++++++++-                        vertical_go = t_h + yellow_time <= rem
++++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
++++++++-                        human_remain = False
++++++++-                        for cross_lane in lane.next_cross_lanes:
++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
++++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
++++++++-            elif c.act_type == 'accel':
++++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
++++++++-            else:
++++++++-                level = act / (c.n_actions - 1)
++++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++-
++++++++-        if c.tl == 'MaxPressure':
++++++++-            self.mp_tlast += c.sim_step
++++++++-            tmin = c.get('mp_tmin', 0)
++++++++-            if self.mp_tlast >= tmin:
++++++++-                for tl in ts.traffic_lights:
++++++++-                    if ts.get_program(tl) == 'off':
++++++++-                        break
++++++++-                    jun = tl.junction
++++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
++++++++-
++++++++-                    total_pressures = []
++++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
++++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
++++++++-
++++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
++++++++-                self.mp_tlast = 0
++++++++-
++++++++-        super().step()
++++++++-        self.build_platoon()
++++++++-
++++++++-        obs = {}
++++++++-
++++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
++++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
++++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
++++++++-        for veh in rl_type.vehicles:
++++++++-            if hasattr(veh, 'lane'):
++++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
++++++++-                junction = lane.next_junction
++++++++-
++++++++-                head, tail = veh, platoon.tail
++++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
++++++++-
++++++++-                if junction is ts.sentinel_junction:
++++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
++++++++-                else:
++++++++-                    for jun_lane in lane.next_junction_lanes:
++++++++-                        # Defaults for jun_lane
++++++++-                        jun_headtails = vehs_default()
++++++++-
++++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
++++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
++++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
++++++++-
++++++++-                        if jun_veh:
++++++++-                            if jun_veh.type is rl_type:
++++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
++++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
++++++++-                                platoon = jun_veh.platoon.prev
++++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++++-                                    if platoon is None: break
++++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++++-                                    platoon = platoon.prev
++++++++-                            else:
++++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
++++++++-                                jun_headtails[0] = jun_veh.platoon.tail
++++++++-                                next_cross_platoon = jun_veh.platoon.prev
++++++++-                                if next_cross_platoon:
++++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
++++++++-                                    platoon = next_cross_platoon.prev
++++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++++-                                        if platoon is None: break
++++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++++-                                        platoon = platoon.prev
++++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
++++++++-
++++++++-                dist_features, speed_features = [], []
++++++++-                for route, vehs in route_vehs:
++++++++-                    j_pos = junction.route_position[route]
++++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
++++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
++++++++-
++++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++-
++++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
++++++++-        ids = sorted(obs)
++++++++-        if c.mrtl:
++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
++++++++-        if c.rew_type == 'outflow':
++++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++-        elif c.rew_type == 'time_penalty':
++++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
++++++++-        
++++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++-
++++++++-        raw_drac = self.calc_drac()
++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++-        raw_pet = self.calc_pet()
++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++-        pet = np.clip(pet/6, -1, 1)
++++++++-
++++++++-        raw_ttc = self.calc_ttc()
++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++-
++++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++-
++++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++-        return returned
++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++-        
++++++++-    def calc_drac(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        dracs = []
++++++++-        for v in cur_veh_list:
++++++++-            if hasattr(v, 'lane'):
++++++++-                leader, headway = v.leader()
++++++++-                v_speed = v.speed
++++++++-                leader_speed = leader.speed
++++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++-                dracs.append(drac)
++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++-        return fleet_drac
++++++++-    
++++++++-    def calc_pet(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        pets = []
++++++++-        for v in cur_veh_list:
++++++++-            if hasattr(v, 'lane'):
++++++++-                leader, headway = v.leader()
++++++++-                v_speed = v.speed
++++++++-                if v_speed > 1e-16:
++++++++-                    pet = headway/(v_speed)
++++++++-                    pets.append(pet)
++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++-        return fleet_pet
++++++++-
++++++++-    def calc_ttc(self):
++++++++-        cur_veh_list = self.ts.vehicles
++++++++-        ttcs = []
++++++++-        for v in cur_veh_list:
++++++++-            if hasattr(v, 'lane'):
++++++++-                leader, headway = v.leader()
++++++++-                v_speed = v.speed
++++++++-                leader_speed = leader.speed
++++++++-                if leader_speed < v_speed:
++++++++-                    ttc =  headway/(v_speed-leader_speed)
++++++++-                else:
++++++++-                    ttc = np.nan
++++++++-                ttcs.append(ttc)
++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++-        return fleet_ttc
++++++++-
++++++++-    def append_step_info(self):
++++++++-        super().append_step_info()
++++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
++++++++-
++++++++-    @property
++++++++-    def stats(self):
++++++++-        c = self.c
++++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
++++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
++++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
++++++++-        stats['backlog_step'] = mean(info['backlog'])
++++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
++++++++-
++++++++-        stats['beta'] = c.beta
++++++++-
++++++++-        if c.multi_flowrate:
++++++++-            stats['flow_horizontal'] = c.flow_rate_h
++++++++-            stats['flow_vertical'] = c.flow_rate_v
++++++++-        return stats
++++++++-
++++++++-class Intersection(Main):
++++++++-    def create_env(c):
++++++++-        if c.multi_flowrate:
++++++++-            return NormEnv(c, IntersectionEnv(c))
++++++++-        else:
++++++++-            c._norm = NormEnv(c, None)
++++++++-            return IntersectionEnv(c)
++++++++-
++++++++-    @property
++++++++-    def observation_space(c):
++++++++-        low = np.full(c._n_obs, c.low)
++++++++-        return Box(low, np.ones_like(low))
++++++++-
++++++++-    @property
++++++++-    def action_space(c):
++++++++-        if c.act_type == 'accel':
++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++++-        else:
++++++++-            return Discrete(c.n_actions)
++++++++-
++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++-        step_obs_ = rollout.obs
++++++++-        step_obs = step_obs_[:-1]
++++++++-
++++++++-        if not c.multi_flowrate:
++++++++-            rollout.raw_reward = rollout.reward
++++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
++++++++-
++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++-
++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++-
++++++++-        step_id_ = rollout.pop('id')
++++++++-        id = np.concatenate(step_id_[:-1])
++++++++-        id_unique = np.unique(id)
++++++++-
++++++++-        reward = np.array(rollout.pop('reward'))
++++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
++++++++-
++++++++-        log(**stats)
++++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++-        log(
++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++-            n_veh_unique=len(id_unique),
++++++++-            
++++++++-            reward_mean=np.mean(reward),
++++++++-            reward_std=np.std(reward),        
++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++-            ssm_std=np.std(rollout.ssm),
++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++-
++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++-            # res_action = np.mean(rollout.res_action),
++++++++-            )
++++++++-        
++++++++-        return rollout
++++++++-
++++++++-if __name__ == '__main__':
++++++++-    c = Intersection.from_args(globals(), locals())
++++++++-    c.setdefaults(
++++++++-        n_steps=200,
++++++++-        step_save=5,
++++++++-
++++++++-        depart_speed=0,
++++++++-        max_speed=13,
++++++++-        max_dist=100,
++++++++-        max_accel=1.5,
++++++++-        max_decel=3.5,
++++++++-        sim_step=0.5,
++++++++-        generic_type=True,
++++++++-        n_actions=3,
++++++++-
++++++++-        adv_norm=False,
++++++++-        batch_concat=True,
++++++++-
++++++++-        render=False,
++++++++-
++++++++-        warmup_steps=100,
++++++++-        horizon=2000,
++++++++-        directions='4way',
++++++++-        av_frac=0.15,
++++++++-        handcraft=False,
++++++++-        handcraft_tl=None,
++++++++-        flow_rate=700,
++++++++-        length=100,
++++++++-        n_rows=1,
++++++++-        n_cols=1,
++++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
++++++++-
++++++++-        act_type='accel_discrete',
++++++++-        low=-1,
++++++++-
++++++++-        alg=PG,
++++++++-        n_gds=1,
++++++++-        lr=1e-3,
++++++++-        gamma=0.99,
++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++-
++++++++-        enter_length=False,
++++++++-        short_exit=False,
++++++++-
++++++++-        rew_type='outflow',
++++++++-        norm_reward=True,
++++++++-        center_reward=True,
++++++++-        multi_flowrate=False,
++++++++-        opt='RMSprop',
++++++++-
++++++++-        obs_tail=True,
++++++++-        obs_next_cross_platoons=1,
++++++++-
++++++++-        beta=0,
++++++++-        scale_pet=1,
++++++++-        scale_drac=1,
++++++++-        seed_np=False,
++++++++-        seed_torch = False,
++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++-    )
++++++++-
++++++++-    if c.seed_torch:
++++++++-        # Set seed for PyTorch CPU operations
++++++++-        torch.manual_seed(c.seed_torch)
++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++-        if torch.cuda.is_available():
++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++-    if c.seed_np:
++++++++-        np.random.seed(c.seed_np)
++++++++-
++++++++-    if c.directions == '4way':
++++++++-        c.directions = ['up', 'right', 'down', 'left']
++++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
++++++++-    if c.mrtl:
++++++++-        c._n_obs += 1
++++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
++++++++-    c.redef_sumo = 'length_range' in c
++++++++-    c.run()
++++++++\ No newline at end of file
++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++index d4c3dac..f70823c 100644
++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++@@ -1,600 +1,9796 @@
++++++++-diff --git a/README.md b/README.md
++++++++-index b591747..127f484 100644
++++++++---- a/README.md
++++++++-+++ b/README.md
++++++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
++++++++- ### 1.2 Set the environmental variables
++++++++- ```
++++++++- # Code directory
++++++++--export F=automatic_vehicular_control/automatic_vehicular_control
++++++++-+export F=automatic_vehicular_control
++++++++- 
++++++++- # Results directory extracted from the zip file
++++++++- export R=results
++++++++-@@ -48,10 +48,8 @@ export R=results
++++++++- ## 2. Directory Structure
++++++++- 
++++++++- The code directory structure is
++++++++--```
++++++++-+``` 
++++++++- automatic_vehicular_control/
++++++++--│
++++++++--├── automatic_vehicular_control/
++++++++- │   ├── __pycache__/                # Compiled Python files
++++++++- │   ├── evaluations/                # Evaluation results and metrics
++++++++- │   ├── models/                     # Model checkpoints
++++++++ diff --git a/env.py b/env.py
++++++++-index 4ab3d95..c83a674 100644
+++++++++index c83a674..3ef7822 100644
++++++++ --- a/env.py
++++++++ +++ b/env.py
++++++++-@@ -724,9 +724,11 @@ class TrafficState:
++++++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
++++++++- 
++++++++-         segments = {}
++++++++-+        
++++++++-         def add_from_to(from_, to):
++++++++-             from_.tos.add(to)
++++++++-             to.froms.add(from_)
++++++++-+            
++++++++-         for con in map(values_str_to_val, net.children('connection')):
++++++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
++++++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
++++++++-@@ -888,89 +890,109 @@ class TrafficState:
++++++++- 
++++++++-     def step(self):
++++++++-         """
++++++++--        Take a simulation step and update state
++++++++-+        Take a simulation step and update state.
++++++++-         """
++++++++--        c = self.c
++++++++--        tc = self.tc
++++++++--        subscribes = self.subscribes
++++++++-+        c = self.c  # Configuration object for the simulation
++++++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
++++++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
++++++++- 
++++++++-         # Actual SUMO step
++++++++--        tc.simulationStep()
++++++++--        sim_res = subscribes.sim.get()
++++++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
++++++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
++++++++- 
++++++++-+        # Clear references to current vehicle edges and lanes for the next update
++++++++-         for veh in self.vehicles:
++++++++--            veh.unvar('edge', 'lane')
++++++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
++++++++-+
++++++++-+        # Clear current vehicle data from edges and lanes
++++++++-         for ent in itertools.chain(self.edges, self.lanes):
++++++++--            ent.vehicles.clear()
++++++++--            ent.positions.clear()
++++++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
++++++++-+            ent.positions.clear()  # Clear vehicle positions
++++++++- 
++++++++-+        # Update traffic light states
++++++++-         for tl_id, tl in self.traffic_lights.items():
++++++++--            tl.update(subscribes.tl.get(tl_id))
++++++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
++++++++- 
++++++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
++++++++-         for veh_id in sim_res.loaded_vehicles_ids:
++++++++--            flow_id, _ = veh_id.rsplit('.')
++++++++--            flow = self.flows[flow_id]
++++++++--            flow.backlog.add(veh_id)
++++++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
++++++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
++++++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
++++++++- 
++++++++-+        # Initialize a set for newly departed vehicles
++++++++-         self.new_departed = set()
++++++++-+
++++++++-+        # Handle vehicles that have departed (entered the network)
++++++++-         for veh_id in sim_res.departed_vehicles_ids:
++++++++--            subscribes.veh.subscribe(veh_id)
++++++++--            type_id = tc.vehicle.getTypeID(veh_id)
++++++++--            # import pdb; pdb.set_trace()
++++++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
++++++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
++++++++-+            # If vehicle type is 'generic', compute specific type
++++++++-             if type_id == 'generic':
++++++++-                 type_id = self.compute_type(veh_id)
++++++++--            type_ = self.types[type_id]
++++++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
++++++++--            length = tc.vehicle.getLength(veh_id)
++++++++--            road_id = tc.vehicle.getRoadID(veh_id)
++++++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
++++++++--            type_.vehicles.add(veh)
++++++++-+            type_ = self.types[type_id]  # Get vehicle type object
++++++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
++++++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
++++++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
++++++++-+
++++++++-+            # Create a new vehicle object and add it to the list of vehicles
++++++++-+            self.vehicles[veh_id] = veh = Vehicle(
++++++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
++++++++-+            )
++++++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
++++++++- 
++++++++-+            # Set color if rendering is enabled
++++++++-             if c.render:
++++++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
++++++++--                self.set_color(veh, color_fn(veh))
++++++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
++++++++- 
++++++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
++++++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
++++++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
++++++++-+
++++++++-+            # Add to new_departed set
++++++++-             self.new_departed.add(veh)
++++++++-+
++++++++-+            # Remove vehicle from backlog if necessary
++++++++-             if '.' in veh_id:
++++++++-                 flow_id, _ = veh_id.rsplit('.')
++++++++-                 if flow_id in self.flows:
++++++++-                     flow = self.flows[flow_id]
++++++++-                     flow.backlog.remove(veh_id)
++++++++- 
++++++++-+        # Handle newly arrived and collided vehicles
++++++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
++++++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
++++++++-+        
++++++++-+        # Remove newly arrived vehicles from tracking if they collided
++++++++-         for veh in self.new_arrived:
++++++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
++++++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
++++++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
++++++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
++++++++- 
++++++++-+        # Update vehicle positions on edges and lanes
++++++++-         for veh_id, veh in self.vehicles.items():
++++++++--            veh.prev_speed = veh.get('speed', None)
++++++++--            veh.update(subscribes.veh.get(veh_id))
++++++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
++++++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
++++++++-             if veh_id not in sim_res.colliding_vehicles_ids:
++++++++--                edge = self.edges[veh.road_id]
++++++++--                edge.vehicles.append(veh)
++++++++--                veh.edge = edge
++++++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
++++++++--            # edge = self.edges[veh.road_id]
++++++++--            # edge.vehicles.append(veh)
++++++++--            # veh.edge = edge
++++++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
++++++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
++++++++-+                veh.edge = edge  # Set vehicle's edge attribute
++++++++- 
++++++++-+        # Update vehicle sorting and lane positions
++++++++-         for edge in self.edges:
++++++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
++++++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
++++++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
++++++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
++++++++-             for edge_i, veh in enumerate(edge.vehicles):
++++++++--                veh.edge_i = edge_i
++++++++--                veh.lane = lane = edge.lanes[veh.lane_index]
++++++++--                veh.lane_i = len(lane.vehicles)
++++++++--                lane.vehicles.append(veh)
++++++++--                lane.positions.append(veh.laneposition)
++++++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
++++++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
++++++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
++++++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
++++++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
++++++++- 
++++++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
++++++++-         self.all_arrived.append(self.new_arrived)
++++++++-         self.all_departed.append(self.new_departed)
++++++++-         self.all_collided.append(self.new_collided)
++++++++--
++++++++-+            
++++++++-     def reset(self, tc):
++++++++-         self.tc = tc
++++++++-         self.subscribes.clear()
++++++++-@@ -1043,6 +1065,7 @@ class Env:
++++++++-     """
++++++++-     Offers a similar reinforcement learning environment interface as gym.Env
++++++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
++++++++-+    c: Ring class
++++++++-     """
++++++++-     def __init__(self, c):
++++++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
++++++++-@@ -1056,6 +1079,7 @@ class Env:
++++++++-             if c.get('save_agent'):
++++++++-                 self._agent_info = []
++++++++-         self._step = 0
++++++++-+        self.mean_speed = 0
++++++++- 
++++++++-     def def_sumo(self, *args, **kwargs):
++++++++-         """ Override this with code defining the SUMO network """
++++++++-@@ -1094,49 +1118,91 @@ class Env:
++++++++-         """
++++++++-         return True
++++++++- 
++++++++-+   # Method to reset or initialize the SUMO traffic simulation environment
++++++++-     def reset_sumo(self):
++++++++-+        # Shortcuts for configuration and SUMO definition objects
++++++++-         c = self.c
++++++++-         sumo_def = self.sumo_def
++++++++--
++++++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
++++++++-+        
++++++++-+        # Determine if new SUMO definitions need to be generated
++++++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
++++++++-+        
++++++++-         if generate_def:
++++++++--            kwargs = self.def_sumo()
++++++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
++++++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
++++++++-+            # Generate new definitions if necessary
++++++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
++++++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
++++++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
+++++++++@@ -852,12 +852,15 @@ class TrafficState:
+++++++++         subscribes.sim = SubscribeDef(tc.simulation, [
+++++++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
+++++++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
++++++++ +        
++++++++-+        # Start SUMO with the current traffic controller (tc)
++++++++-         self.tc = sumo_def.start_sumo(self.tc)
+++++++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
+++++++++             TL.red_yellow_green_state])
++++++++ +        
++++++++-         if generate_def:
++++++++-+            # If new definitions were generated, store relevant SUMO file paths
++++++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
++++++++-+            
++++++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
++++++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
++++++++--            self.ts = TrafficState(c, self.tc, **defs)
++++++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
++++++++-         else:
++++++++-+            # If not generating new definitions, simply reset the existing traffic state
++++++++-             self.ts.reset(self.tc)
+++++++++         subscribes.veh = SubscribeDef(tc.vehicle, [
+++++++++             V.road_id, V.lane_index, V.laneposition,
+++++++++             V.speed, V.position, V.angle,
+++++++++             V.fuelconsumption, V.noxemission])
++++++++ +        
++++++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
++++++++-         self.ts.setup()
++++++++-+        
++++++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
++++++++-         success = self.init_vehicles()
++++++++-+        
++++++++-+        # Return whether the SUMO reset and vehicle initialization were successful
++++++++-         return success
+++++++++         for tl_id in self.traffic_lights.keys():
+++++++++             subscribes.tl.subscribe(tl_id)
++++++ +  
++++++-+
++++++-     def run(c):
++++++-         # Determine whether to train or evaluate based on configuration
++++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++-diff --git a/ring.py b/ring.py
++++++-index 94d632d..ee1372b 100644
++++++---- a/ring.py
++++++-+++ b/ring.py
++++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++-         )
++++++--
++++++-         # Function to generate the shape of the edges (circular arcs)
++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++- 
++++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
++++++-         if c.circumference_range:  # Check if the circumference should be randomized
++++++-             # Randomly set the circumference within the specified range
++++++-             c.circumference = np.random.randint(*c.circumference_range)
++++++-+        
++++++-+        if self.flow_log:
++++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
++++++-+            self.episode_flow.append(average_flow)
++++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
++++++-+        
++++++-+        # Reset flow counters for the new episode
++++++-+        self.flow_counter = 0
++++++-+        self.flow_log = []
++++++-+        self.last_vehicle_times = {}
++++++-+        
++++++-         return super().reset_sumo()  # Reset the simulation
++++++++-+    # Method to initialize the environment after SUMO reset
++++++++-     def init_env(self):
++++++++-+        # Reference to the traffic state
++++++++-         ts = self.ts
++++++++-+    
++++++++-+        # Create an empty data structure to store rollout information
++++++++-         self.rollout_info = NamedArrays()
++++++++-+        
++++++++-+        # Turn off all traffic lights in the network
++++++++-         for tl in ts.traffic_lights:
++++++++--            ts.set_program(tl, 'off')
++++++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
++++++++-+        
++++++++-+        # Reset the step counter to 0
++++++++-         self._step = 0
++++++++-+        
++++++++-+        # Take the first step in the simulation
++++++++-         ret = self.step()
++++++++-+        
++++++++-+        # Run the simulation for a number of warmup steps
++++++++-         for _ in range(self.c.warmup_steps):
++++++++--            ret = self.step()
++++++++-+            ret = self.step()  # Advance the simulation one step
++++++++-+            
++++++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
++++++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
++++++++-                 return None
++++++++-+        
++++++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
++++++++-         for tl in ts.traffic_lights:
++++++++--            ts.set_program(tl, '1')
++++++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
++++++++-+        
++++++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
++++++++-         if isinstance(ret, tuple):
++++++++--            return ret[0]
++++++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
++++++++--
++++++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
++++++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
++++++++-+        
++++++++-+    # Reset the entire environment, retrying until successful
++++++++-     def reset(self):
++++++++--        while True:
++++++++-+        self.mean_speed = 0
++++++++-+        while True:  # Infinite loop until the environment is successfully reset
++++++++-+            # Attempt to reset the SUMO simulation
+++++++++@@ -1197,6 +1200,7 @@ class Env:
+++++++++         while True:  # Infinite loop until the environment is successfully reset
+++++++++             # Attempt to reset the SUMO simulation
++++++++              if not self.reset_sumo():
++++++++--                continue
++++++++-+                continue  # If reset_sumo fails, retry the loop
++++++++-+            
++++++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++++++-             if (obs := self.init_env()) is not None:
++++++++--                return obs
++++++++-+                return obs  # Successfully initialized, return the observation
++++++++-+
++++++++- 
++++++++-     def append_step_info(self):
++++++++-         """
++++++++-@@ -1231,6 +1297,8 @@ class Env:
++++++++- class NormEnv(gym.Env):
++++++++-     """
++++++++-     Reward normalization with running average https://github.com/joschu/modular_rl
++++++++-+    self.c: Ring parameters 
++++++++-+    self.env: RingEnv class
++++++++-     """
++++++++-     def __init__(self, c, env):
++++++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
++++++++++                
+++++++++                 continue  # If reset_sumo fails, retry the loop
+++++++++             
+++++++++             # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++++++ diff --git a/exp.py b/exp.py
++++++++-index ead4652..7f7cee5 100644
+++++++++index 7f7cee5..6f16d66 100644
++++++++ --- a/exp.py
++++++++ +++ b/exp.py
++++++++-@@ -169,9 +169,9 @@ class Main(Config):
++++++++- 
++++++++-     def on_train_start(c):
++++++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
++++++++--        c.setdefaults(alg='Algorithm')
++++++++--        c._env = c.create_env()
++++++++--
++++++++-+        c.setdefaults(alg='Algorithm') 
++++++++-+        c._env = c.create_env() # Create NormEnv
++++++++-+ 
++++++++-         # Instantiate the algorithm (e.g., PPO, DQN)
++++++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
++++++++-         c.set_model()
++++++++-@@ -222,8 +222,8 @@ class Main(Config):
++++++++- 
++++++++-     def on_step_start(c, stats={}):
++++++++-         # Update the learning rate and log stats at the start of a training step
++++++++--        lr = c._lr
++++++++--        for g in c._opt.param_groups:
++++++++-+        lr = c._lr # Update Learning Rate
++++++++-+        for g in c._opt.param_groups: # Log Statistics
++++++++-             g['lr'] = float(lr)
++++++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
++++++++- 
++++++++-@@ -285,10 +285,14 @@ class Main(Config):
+++++++++@@ -285,7 +285,6 @@ class Main(Config):
++++++++              ret = dict(obs=ret)
++++++++          rollout = NamedArrays()
++++++++          rollout.append(**ret)
++++++++--
++++++++-+        rollout_flow_each_step = []
+++++++++-        rollout_flow_each_step = []
++++++++          done = False
++++++++          a_space = c.action_space
++++++++          step = 0
+++++++++@@ -406,9 +405,8 @@ class Main(Config):
+++++++++ 
+++++++++     def train(c):
+++++++++         # Main training loop
+++++++++-        c.on_train_start()
++++++++++        c.on_train_start() # Ring Env
+++++++++         while c._i < c.n_steps:
+++++++++-            c.on_step_start() # save stat 
+++++++++             with torch.no_grad():
+++++++++                 # Collect rollouts without computing gradients
+++++++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++++++@@ -497,3 +495,32 @@ class Main(Config):
+++++++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
+++++++++             c.train()
+++++++++         c.log('job done!')
++++++++++
++++++++++    def run_2(c):
++++++++++        # Determine whether to train or evaluate based on configuration
++++++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
++++++++++        
++++++++++        c.on_train_start()
++++++++++        c._env = c.create_env() # Create NormEnv
++++++++++        ret = c._env.reset()
++++++++++        c.set_model()
++++++++++        step = 0
++++++++ +        density = 20/(250*1e-3)
++++++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++++++++-+
++++++++-         while step < c.horizon + c.skip_stat_steps and not done:
++++++++-             # Generate an action from the model's policy
++++++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
++++++++-@@ -309,6 +313,12 @@ class Main(Config):
++++++++-             rollout.append(**ret)
++++++++-             step += 1
++++++++-         # Collect stats from the environment
++++++++++        done = False
++++++++++        while step < c.horizon + c.skip_stat_steps and not done:
++++++++++            # Take a step in the environment
++++++++++            ret = c._env.step()
++++++++++            if isinstance(ret, tuple):
++++++++++                obs, reward, done, info = ret
++++++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
++++++++++            done = ret.setdefault('done', False)
++++++++++            step += 1
++++++++++        # Collect stats from the environment
++++++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++++++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++++++++ +        density = 20/(250 * 1e-3)
++++++++ +        vehicle_flow = c._env.mean_speed * density 
++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++++++++-+
++++++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
++++++++-         return rollout, stats
++++++++- 
++++++++-@@ -398,10 +408,10 @@ class Main(Config):
++++++++-         # Main training loop
++++++++-         c.on_train_start()
++++++++-         while c._i < c.n_steps:
++++++++--            c.on_step_start()
++++++++-+            c.on_step_start() # save stat 
++++++++-             with torch.no_grad():
++++++++-                 # Collect rollouts without computing gradients
++++++++--                rollouts = c.rollouts()
++++++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++++-             gd_stats = {}
++++++++-             if len(rollouts.obs):
++++++++-                 t_start = time()
++++++++-@@ -410,7 +420,7 @@ class Main(Config):
++++++++-                 gd_stats.update(gd_time=time() - t_start)
++++++++-             c.on_step_end(gd_stats)
++++++++-             c._i += 1
++++++++--        c.on_step_start()  # last step
++++++++-+        c.on_step_start()  # save stat
++++++++-         gd_stats = {}
++++++++-         with torch.no_grad():
++++++++-             rollouts = c.rollouts()
++++++++-@@ -450,6 +460,8 @@ class Main(Config):
++++++++-         if hasattr(c._env, 'close'):
++++++++-             c._env.close()
++++++++- 
++++++++-+  
++++++++-+
++++++++-     def run(c):
++++++++-         # Determine whether to train or evaluate based on configuration
++++++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++++-diff --git a/ring.py b/ring.py
++++++++-index 94d632d..ee1372b 100644
++++++++---- a/ring.py
++++++++-+++ b/ring.py
++++++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++++-         )
+++++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
+++++++++deleted file mode 100644
+++++++++index 6b9ba52..0000000
+++++++++--- a/highway_bottleneck.py
++++++++++++ /dev/null
+++++++++@@ -1,381 +0,0 @@
+++++++++-from automatic_vehicular_control.exp import *
+++++++++-from automatic_vehicular_control.env import *
+++++++++-from automatic_vehicular_control.u import *
++++++++ -
++++++++-         # Function to generate the shape of the edges (circular arcs)
++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++- 
++++++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
++++++++-         if c.circumference_range:  # Check if the circumference should be randomized
++++++++-             # Randomly set the circumference within the specified range
++++++++-             c.circumference = np.random.randint(*c.circumference_range)
++++++++-+        
++++++++-+        if self.flow_log:
++++++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
++++++++-+            self.episode_flow.append(average_flow)
++++++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
++++++++-+        
++++++++-+        # Reset flow counters for the new episode
++++++++-+        self.flow_counter = 0
++++++++-+        self.flow_log = []
++++++++-+        self.last_vehicle_times = {}
++++++++-+        
++++++++-         return super().reset_sumo()  # Reset the simulation
++++++++- 
++++++++-     @property
++++++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
++++++++-         }
++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
++++++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
++++++++-         return stats
++++++++--
++++++++-+    
++++++++-+    def calculate_flow(self):
++++++++-+        """
++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++++-+        """
++++++++-+        current_time = self.ts.time
++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++++-+
++++++++-+        for vehicle in vehicles_on_edge:
++++++++-+            # Check if vehicle has passed the observation point since the last timestep
++++++++-+            if vehicle.id not in self.last_vehicle_times:
++++++++-+                # If the vehicle was not previously recorded, count it as a new passage
++++++++-+                self.flow_counter += 1
++++++++-+            else:
++++++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
++++++++-+                last_time = self.last_vehicle_times[vehicle.id]
++++++++-+                if current_time - last_time > self.c.sim_step:
++++++++-+                    self.flow_counter += 1
++++++++-+
++++++++-+            # Update the last time the vehicle passed the point
++++++++-+            self.last_vehicle_times[vehicle.id] = current_time
++++++++-+
++++++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
++++++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
++++++++-+        self.flow_log.append(flow_per_hour)
++++++++-+        return flow_per_hour
++++++++-+    
++++++++-     def step(self, action=None):
++++++++-         c = self.c  # Configuration object
++++++++-         ts = self.ts  # Time step object
++++++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
++++++++-                     # Change to a specific lane
++++++++-                     ts.lane_change_to(rl, lc)
+++++++++-class BNeckEnv(Env):
+++++++++-    def def_sumo(self):
+++++++++-        c = self.c
+++++++++-        nodes = E('nodes',
+++++++++-            E('node', id='n_0', x=0, y=0), *(
+++++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
+++++++++-        ))
+++++++++-        edges = E('edges', *(
+++++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
+++++++++-                'numLanes': n_lane,
+++++++++-                'speed': c.max_speed
+++++++++-            }) for i, n_lane in enumerate(c.n_lanes)
+++++++++-        ))
+++++++++-        connections = E('connections', *(
+++++++++-            E('connection', **{
+++++++++-                'from': prev.id,
+++++++++-                'to': curr.id,
+++++++++-                'fromLane': i,
+++++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
+++++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
+++++++++-        ))
+++++++++-
+++++++++-        if c.split_flow:
+++++++++-            n_inflow_lanes = c.n_lanes[0]
+++++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
+++++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
+++++++++-                for i in range(n_inflow_lanes)
+++++++++-            ]
+++++++++-        else:
+++++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
+++++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
+++++++++-            ]
+++++++++-        routes = E('routes',
+++++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
+++++++++-            *flows
+++++++++-        )
+++++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
+++++++++-        additional = E('additional',
+++++++++-            E('vType', id='generic', **idm_params),
+++++++++-            E('vType', id='rl', **idm_params),
+++++++++-            E('vType', id='human', **idm_params),
+++++++++-        )
+++++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++++-
+++++++++-    def reset_sumo(self):
+++++++++-        c = self.c
+++++++++-        if c.flow_rate_range:
+++++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
+++++++++-        ret = super().reset_sumo()
+++++++++-        if c.vinitsky:
+++++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
+++++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
+++++++++-                for i_start in range(round(edge.length) // c.piece_length)
+++++++++-                for lane in edge.lanes
+++++++++-            ]
+++++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
+++++++++-            self.last_outflows = []
+++++++++-        return ret
+++++++++-
+++++++++-    def step(self, action=[]):
+++++++++-        c = self.c
+++++++++-        ts = self.ts
+++++++++-        max_dist = 100
+++++++++-        max_speed = c.max_speed
+++++++++-        human_type = ts.types.human
+++++++++-        rl_type = ts.types.rl
+++++++++-
+++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++-        if c.vinitsky:
+++++++++-            if len(action):
+++++++++-                assert len(action) == len(self.control_lanes)
+++++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
+++++++++-                    self.control_lanes[lane, piece_start] = np.clip(
+++++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
+++++++++-                        0.1, max_speed
+++++++++-                    )
+++++++++-                for veh in prev_rls:
+++++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
+++++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
+++++++++-        else:
+++++++++-            for veh, act in zip(prev_rls, action):
+++++++++-                if c.handcraft:
+++++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
+++++++++-                    next_lane = lane.next(veh.route)
+++++++++-                    level = 1
+++++++++-                    if next_lane and next_lane.get('junction'):
+++++++++-                        merge_dist = lane.length - veh.laneposition
+++++++++-                        if merge_dist < c.handcraft:
+++++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
+++++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
+++++++++-                                level = 0
+++++++++-                    if c.act_type.startswith('accel'):
+++++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++-                    else:
+++++++++-                        ts.set_max_speed(veh, max_speed * level)
+++++++++-                    continue
+++++++++-                if not isinstance(act, (int, np.integer)):
+++++++++-                    act = (act - c.low) / (1 - c.low)
+++++++++-                if c.act_type.startswith('accel'):
+++++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++-                else:
+++++++++-                    if c.act_type == 'continuous':
+++++++++-                        level = act[0]
+++++++++-                    elif c.act_type == 'discretize':
+++++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++++-                    elif c.act_type == 'discrete':
+++++++++-                        level = act / (c.n_actions - 1)
+++++++++-                    ts.set_max_speed(veh, max_speed * level)
+++++++++-
+++++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
+++++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
+++++++++-
+++++++++-        super().step()
+++++++++-
+++++++++-        if c.vinitsky:
+++++++++-            n_last_outflows = 20
+++++++++-            max_vehs = 4
+++++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
+++++++++-            obs = []
+++++++++-            for lane, piece_start in self.obs_lanes:
+++++++++-                piece_end = piece_start + c.piece_length
+++++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
+++++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
+++++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
+++++++++-                obs.extend([
+++++++++-                    len(lane_humans) / max_vehs,
+++++++++-                    len(lane_avs) / max_vehs,
+++++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
+++++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
+++++++++-                ])
+++++++++-            if len(self.last_outflows) == n_last_outflows:
+++++++++-                self.last_outflows = self.last_outflows[1:]
+++++++++-            self.last_outflows.append(len(ts.new_arrived))
+++++++++-            reward = np.mean(self.last_outflows)
+++++++++-            obs.append(reward / max_veh_outflows)
+++++++++-            obs = np.array(obs, dtype=np.float32)
+++++++++-            assert 0 <= obs.min() and obs.max() <= 1
+++++++++-            return obs, reward, False, None
+++++++++-        route = nexti(ts.routes)
+++++++++-        obs, ids = [], []
+++++++++-        default_close = [0, max_speed]
+++++++++-        default_far = [max_dist, 0]
+++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++++-            merge_dist = max_dist
+++++++++-            default_human = default_far
+++++++++-
+++++++++-            other_info = {}
+++++++++-            next_lane = lane.next(veh.route)
+++++++++-            if next_lane and next_lane.get('junction'):
+++++++++-                merge_dist = lane.length - veh.laneposition
+++++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
+++++++++-                # Look for veh on other lane but do not extend past that lane
+++++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
+++++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
+++++++++-                    if other_veh.type is rl_type:
+++++++++-                        default_human = default_close
+++++++++-                        break
+++++++++-
+++++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
+++++++++-            ids.append(veh.id)
+++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
+++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++-        
+++++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++-
+++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++-
+++++++++-        raw_pet = self.calc_pet()
+++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++-        pet = np.clip(pet, -1, 1)
+++++++++-
+++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++-        
+++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++-        return returned
+++++++++-        
+++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++-    
+++++++++-    def calc_ttc(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        ttcs = []
+++++++++-        for v in cur_veh_list:
+++++++++-            leader, headway = v.leader()
+++++++++-            v_speed = v.speed
+++++++++-            leader_speed = leader.speed
+++++++++-            if leader_speed < v_speed:
+++++++++-                ttc =  headway/(v_speed-leader_speed)
+++++++++-            else:
+++++++++-                ttc = np.nan
+++++++++-            ttcs.append(ttc)
+++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++-        return fleet_ttc
+++++++++-    
+++++++++-    def calc_drac(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        dracs = []
+++++++++-        for v in cur_veh_list:
+++++++++-            leader, headway = v.leader()
+++++++++-            v_speed = v.speed
+++++++++-            leader_speed = leader.speed
+++++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++-            dracs.append(drac)
+++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++-        return fleet_drac
+++++++++-
+++++++++-    def calc_pet(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        pets = []
+++++++++-        for v in cur_veh_list:
+++++++++-            leader, headway = v.leader()
+++++++++-            v_speed = v.speed
+++++++++-            if v_speed > 1e-16:
+++++++++-                pet = headway/(v_speed)
+++++++++-                pets.append(pet)
+++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++-        return fleet_pet
+++++++++-
+++++++++-class BNeck(Main):
+++++++++-    def create_env(c):
+++++++++-        return BNeckEnv(c)
+++++++++-
+++++++++-    @property
+++++++++-    def observation_space(c):
+++++++++-        low = np.full(c._n_obs, c.low)
+++++++++-        return Box(low, np.ones_like(low))
+++++++++-
+++++++++-    @property
+++++++++-    def action_space(c):
+++++++++-        if c.vinitsky:
+++++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
+++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++++-            assert c.lc_av in [False, 'binary']
+++++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
+++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++++-            return Discrete(c.n_actions)
+++++++++-
+++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++-        if c.vinitsky:
+++++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
+++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++-        step_obs_ = rollout.obs
+++++++++-        step_obs = step_obs_[:-1]
+++++++++-
+++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++-
+++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++-
+++++++++-        step_id_ = rollout.pop('id')
+++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++-        id_unique = np.unique(id)
+++++++++-
+++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++-
+++++++++-        log(**stats)
+++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++-        log(
+++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++-            n_veh_unique=len(id_unique),
+++++++++-            
+++++++++-            reward_mean=np.mean(reward),
+++++++++-            reward_std=np.std(reward),        
+++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++-
+++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++-            )
+++++++++-        return rollout
+++++++++-
+++++++++-if __name__ == '__main__':
+++++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
+++++++++-        warmup_steps=1000,
+++++++++-        horizon=2000,
+++++++++-        n_steps=100,
+++++++++-        step_save=5,
+++++++++-
+++++++++-        av_frac=0.2,
+++++++++-        sim_step=0.5,
+++++++++-        depart_speed=0,
+++++++++-        edge_lengths=[100, 100, 50],
+++++++++-        n_lanes=[4, 2, 1],
+++++++++-        max_speed=30,
+++++++++-
+++++++++-        lc_av=False,
+++++++++-        flow_rate=2300,
+++++++++-        flow_rate_range=None,
+++++++++-        split_flow=True,
+++++++++-        generic_type='rand',
+++++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++++-        lc_mode=LC_MODE.off,
+++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++-
+++++++++-        veh_junction=False,
+++++++++-        act_type='accel_discrete',
+++++++++-        max_accel=2.6,
+++++++++-        max_decel=4.5,
+++++++++-        tau=1.0,
+++++++++-        min_gap=2.5,
+++++++++-        delta=4,
+++++++++-        n_actions=3,
+++++++++-        low=-1,
+++++++++-        handcraft=False,
+++++++++-        vinitsky=False,
+++++++++-
+++++++++-        render=False,
+++++++++-
+++++++++-        alg=PG,
+++++++++-        lr=1e-3,
+++++++++-
+++++++++-        gamma=0.99,
+++++++++-        adv_norm=False,
+++++++++-        batch_concat=True,
+++++++++-
+++++++++-        beta=0,
+++++++++-        scale_ttc=1,
+++++++++-        scale_drac=1,
+++++++++-        seed_np=False,
+++++++++-        seed_torch = False,
+++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++-
+++++++++-    )
+++++++++-    
+++++++++-    if c.seed_torch:
+++++++++-        # Set seed for PyTorch CPU operations
+++++++++-        torch.manual_seed(c.seed_torch)
+++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++-        if torch.cuda.is_available():
+++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++-    if c.seed_np:
+++++++++-        np.random.seed(c.seed_np)
+++++++++-        
+++++++++-    if c.vinitsky:
+++++++++-        c.piece_length = 20
+++++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
+++++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
+++++++++-        c._n_action = sum(n_actions[:-1])
+++++++++-        c._n_obs = sum(n_actions) * 4 + 1
+++++++++-        c.batch_concat = False
+++++++++-    else:
+++++++++-        c._n_obs = 2 + 2 + 2
+++++++++-        
+++++++++-    if c.mrtl:
+++++++++-        c._n_obs += 1 # modified for mrtl related
+++++++++-        
+++++++++-    c.redef_sumo = bool(c.flow_rate_range)
+++++++++-    c.run()
+++++++++\ No newline at end of file
+++++++++diff --git a/highway_ramp.py b/highway_ramp.py
+++++++++deleted file mode 100644
+++++++++index ef0358f..0000000
+++++++++--- a/highway_ramp.py
++++++++++++ /dev/null
+++++++++@@ -1,325 +0,0 @@
+++++++++-from automatic_vehicular_control.exp import *
+++++++++-from automatic_vehicular_control.env import *
+++++++++-from automatic_vehicular_control.u import *
+++++++++-
+++++++++-class RampEnv(Env):
+++++++++-    # https://flow-project.github.io/papers/08569485.pdf
+++++++++-    def def_sumo(self):
+++++++++-        c = self.c
+++++++++-        builder = NetBuilder()
+++++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
+++++++++-            (0, 0),
+++++++++-            (c.premerge_distance, 0),
+++++++++-            (c.premerge_distance + c.merge_distance, 0),
+++++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
+++++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
+++++++++-        ])
+++++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
+++++++++-            {}, {'numLanes': 2}, {}
+++++++++-        ], lane_maps=[
+++++++++-            {0: 1}, {0: 0, 1: 0}
+++++++++-        ], route_id='highway')
+++++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
+++++++++-            {}, {'numLanes': 2}, {}
+++++++++-        ], lane_maps=[
+++++++++-            {0: 0}, {0: 0, 1: 0}
+++++++++-        ], route_id='ramp')
+++++++++-        nodes, edges, connections, routes = builder.build()
+++++++++-        nodes[2].type = 'zipper'
+++++++++-
+++++++++-        routes = E('routes',
+++++++++-            *routes,
+++++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
+++++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
+++++++++-        )
+++++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
+++++++++-        additional = E('additional',
+++++++++-            E('vType', id='generic', **idm),
+++++++++-            E('vType', id='rl', **idm),
+++++++++-            E('vType', id='human', **idm),
+++++++++-        )
+++++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++++-
+++++++++-    def step(self, action=[]):
+++++++++-        c = self.c
+++++++++-        ts = self.ts
+++++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
+++++++++-        max_speed = c.max_speed
+++++++++-        human_type = ts.types.human
+++++++++-        rl_type = ts.types.rl
+++++++++-
+++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++-        for rl, act in zip(prev_rls, action):
+++++++++-            if c.handcraft:
+++++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
+++++++++-                leader, dist = rl.leader()
+++++++++-                level = 1
+++++++++-                if edge.id == 'e_n_0.0_n_400.0':
+++++++++-                    if rl.laneposition < 100:
+++++++++-                        leaders = list(rl.leaders())
+++++++++-                        if len(leaders) > 20:
+++++++++-                            level = 0
+++++++++-                        else:
+++++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+++++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++-                continue
+++++++++-            if not isinstance(act, (int, np.integer)):
+++++++++-                act = (act - c.low) / (1 - c.low)
+++++++++-            if c.act_type.startswith('accel'):
+++++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++-            else:
+++++++++-                if c.act_type == 'continuous':
+++++++++-                    level = act[0]
+++++++++-                elif c.act_type == 'discretize':
+++++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++++-                elif c.act_type == 'discrete':
+++++++++-                    level = act / (c.n_actions - 1)
+++++++++-                ts.set_max_speed(rl, max_speed * level)
+++++++++-
+++++++++-        super().step()
+++++++++-
+++++++++-        route = ts.routes.highway
+++++++++-        obs, ids = [], []
+++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++++-            if hasattr(veh, 'edge'):
+++++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++++-                merge_dist = max_dist
+++++++++-
+++++++++-                lead_speed = follow_speed = other_speed = 0
+++++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
+++++++++-
+++++++++-                leader, dist = veh.leader()
+++++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
+++++++++-
+++++++++-                follower, dist = veh.follower()
+++++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
+++++++++-
+++++++++-                if c.global_obs:
+++++++++-                    jun_edge = edge.next(route)
+++++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
+++++++++-                        jun_edge = jun_edge.next(route)
+++++++++-                    if jun_edge:
+++++++++-                        merge_dist = lane.length - veh.laneposition
+++++++++-                        next_edge = edge.next(route)
+++++++++-                        while next_edge is not jun_edge:
+++++++++-                            merge_dist += next_edge.length
+++++++++-                            next_edge = next_edge.next(route)
+++++++++-
+++++++++-                        other_lane = jun_edge.lanes[0]
+++++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
+++++++++-                            other_speed = other_veh.speed
+++++++++-                            break
+++++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
+++++++++-                else:
+++++++++-                    next_lane = lane.next(route)
+++++++++-                    if next_lane and next_lane.get('junction'):
+++++++++-                        if len(edge.lanes) == 2:
+++++++++-                            other_lane = edge.lanes[0]
+++++++++-                            pos = veh.laneposition
+++++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
+++++++++-                                other_speed = other_veh.speed
+++++++++-                                break
+++++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
+++++++++-                ids.append(veh.id)
+++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
+++++++++-        if c.mrtl:
+++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++-        
+++++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++-
+++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++-
+++++++++-        raw_pet = self.calc_pet()
+++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++-        pet = np.clip(pet, -1, 1)
+++++++++-
+++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++-        
+++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++-        return returned
+++++++++-        
+++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++-    
+++++++++-    def calc_ttc(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        ttcs = []
+++++++++-        for v in cur_veh_list:
+++++++++-            if hasattr(v, 'edge'):
+++++++++-                leader, headway = v.leader()
+++++++++-                if leader:
+++++++++-                    v_speed = v.speed
+++++++++-                    leader_speed = leader.speed
+++++++++-                    if leader_speed < v_speed:
+++++++++-                        ttc =  headway/(v_speed-leader_speed)
+++++++++-                    else:
+++++++++-                        ttc = np.nan
+++++++++-                    ttcs.append(ttc)
+++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++-        return fleet_ttc
+++++++++-    
+++++++++-    def calc_drac(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        dracs = []
+++++++++-        for v in cur_veh_list:
+++++++++-            if hasattr(v, 'edge'):
+++++++++-                leader, headway = v.leader()
+++++++++-                if leader:
+++++++++-                    v_speed = v.speed
+++++++++-                    leader_speed = leader.speed
+++++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++-                    dracs.append(drac)
+++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++-        return fleet_drac
+++++++++-
+++++++++-    def calc_pet(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        pets = []
+++++++++-        for v in cur_veh_list:
+++++++++-            if hasattr(v, 'edge'):
+++++++++-                leader, headway = v.leader()
+++++++++-                if leader:
+++++++++-                    v_speed = v.speed
+++++++++-                    if v_speed > 1e-16:
+++++++++-                        pet = headway/(v_speed)
+++++++++-                        pets.append(pet)
+++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
+++++++++-        return fleet_pet
+++++++++-
+++++++++-class Ramp(Main):
+++++++++-    def create_env(c):
+++++++++-        return RampEnv(c)
+++++++++-
+++++++++-    @property
+++++++++-    def observation_space(c):
+++++++++-        low = np.full(c._n_obs, c.low)
+++++++++-        return Box(low, np.ones_like(low))
+++++++++-
+++++++++-    @property
+++++++++-    def action_space(c):
+++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++++-            return Discrete(c.n_actions)
+++++++++-
+++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++-        step_obs_ = rollout.obs
+++++++++-        step_obs = step_obs_[:-1]
+++++++++-
+++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++-
+++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++-
+++++++++-        step_id_ = rollout.pop('id')
+++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++-        id_unique = np.unique(id)
+++++++++-
+++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++-
+++++++++-        log(**stats)
+++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++-        log(
+++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++-            n_veh_unique=len(id_unique),
+++++++++-            
+++++++++-            reward_mean=np.mean(reward),
+++++++++-            reward_std=np.std(reward),        
+++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++-
+++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++-            )
+++++++++-        return rollout
+++++++++-
+++++++++-if __name__ == '__main__':
+++++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
+++++++++-        warmup_steps=100,
+++++++++-        horizon=2000,
+++++++++-        n_steps=100,
+++++++++-        step_save=5,
+++++++++-
+++++++++-        premerge_distance=400,
+++++++++-        merge_distance=100,
+++++++++-        postmerge_distance=30,
+++++++++-        av_frac=0.1,
+++++++++-        sim_step=0.5,
+++++++++-        max_speed=30,
+++++++++-        highway_depart_speed=10,
+++++++++-        ramp_depart_speed=0,
+++++++++-        highway_flow_rate=2000,
+++++++++-        ramp_flow_rate=300,
+++++++++-        global_obs=False,
+++++++++-        handcraft=False,
+++++++++-
+++++++++-        generic_type='default',
+++++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++-
+++++++++-        act_type='accel_discrete',
+++++++++-        max_accel=1,
+++++++++-        max_decel=1.5,
+++++++++-        n_actions=3,
+++++++++-        low=-1,
+++++++++-
+++++++++-        render=False,
+++++++++-
+++++++++-        alg=PG,
+++++++++-        lr=1e-3,
+++++++++-
+++++++++-        gamma=0.99,
+++++++++-        adv_norm=False,
+++++++++-        batch_concat=True,
+++++++++-
+++++++++-        beta=0,
+++++++++-        scale_ttc=1,
+++++++++-        scale_drac=1,
+++++++++-        seed_np=False,
+++++++++-        seed_torch = False,
+++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++-
+++++++++-    )
+++++++++-    
+++++++++-    if c.seed_torch:
+++++++++-        # Set seed for PyTorch CPU operations
+++++++++-        torch.manual_seed(c.seed_torch)
+++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++-        if torch.cuda.is_available():
+++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++-    if c.seed_np:
+++++++++-        np.random.seed(c.seed_np)
+++++++++-        
+++++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
+++++++++-    if c.mrtl:
+++++++++-        c._n_obs += 1 # modified for mrtl related
+++++++++-    c.run()
+++++++++\ No newline at end of file
+++++++++diff --git a/intersection.py b/intersection.py
+++++++++deleted file mode 100644
+++++++++index e38a84f..0000000
+++++++++--- a/intersection.py
++++++++++++ /dev/null
+++++++++@@ -1,489 +0,0 @@
+++++++++-from automatic_vehicular_control.u import *
+++++++++-from automatic_vehicular_control.exp import *
+++++++++-from automatic_vehicular_control.env import *
+++++++++-
+++++++++-class Platoon(Entity):
+++++++++-    pass
+++++++++-
+++++++++-class IntersectionEnv(Env):
+++++++++-    def def_sumo(self):
+++++++++-        c = self.c
+++++++++-
+++++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
+++++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
+++++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
+++++++++-        ] if params.get('vehsPerHour')]
+++++++++-
+++++++++-        builder = NetBuilder()
+++++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
+++++++++-        if c.enter_length:
+++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++++-            xys[1:, :, 0] += c.enter_length - c.length
+++++++++-            xys[:, 1:, 1] += c.enter_length - c.length
+++++++++-            xys = xys.reshape(-1, 2)
+++++++++-        if c.short_exit:
+++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++++-            xys[-1, :, 0] += c.short_exit - c.length
+++++++++-            xys[:, -1, 1] += c.short_exit - c.length
+++++++++-            xys = xys.reshape(-1, 2)
+++++++++-        nodes = builder.add_nodes(
+++++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
+++++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
+++++++++-        # import pdb; pdb.set_trace()
+++++++++-
+++++++++-        tl = c.setdefault('tl', False)
+++++++++-        if tl:
+++++++++-            c.av_frac = 0
+++++++++-            c.pop('av_range', None)
+++++++++-            c.speed_mode = SPEED_MODE.all_checks
+++++++++-
+++++++++-        flows = []
+++++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
+++++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
+++++++++-        for direction in c.directions:
+++++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
+++++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
+++++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
+++++++++-
+++++++++-            edge_attrs = dict(priority=int(direction in priority))
+++++++++-            if c.get('set_edge_speed', True):
+++++++++-                edge_attrs['speed'] = c.max_speed
+++++++++-
+++++++++-            for i, chain in enumerate(chains[1:-1]):
+++++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
+++++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
+++++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
+++++++++-
+++++++++-        tls = []
+++++++++-        if tl:
+++++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
+++++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
+++++++++-            tl_offset = c.get('tl_offset', 'auto')
+++++++++-            yellow = c.get('yellow', 0.5)
+++++++++-            if tl_offset == 'auto':
+++++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
+++++++++-            elif tl_offset == 'same':
+++++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
+++++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
+++++++++-                node.type = 'traffic_light'
+++++++++-                phase_multiple = len(c.directions) // 2
+++++++++-                tls.append(E('tlLogic',
+++++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
+++++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
+++++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
+++++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
+++++++++-                id=node.id, offset=offset, type='static', programID='1'))
+++++++++-
+++++++++-        nodes, edges, connections, routes = builder.build()
+++++++++-        additional = E('additional', *types, *routes, *flows, *tls)
+++++++++-        return super().def_sumo(nodes, edges, connections, additional)
+++++++++-
+++++++++-    def build_platoon(self):
+++++++++-        ts = self.ts
+++++++++-        rl_type = ts.types.rl
+++++++++-        for route in ts.routes:
+++++++++-            vehs = []
+++++++++-            route_offset = 0
+++++++++-            for edge in route.edges:
+++++++++-                for veh in edge.vehicles:
+++++++++-                    veh.route_position = route_offset + veh.laneposition
+++++++++-                    vehs.append(veh)
+++++++++-                route_offset += edge.length
+++++++++-
+++++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
+++++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
+++++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
+++++++++-            rl_idxs, = rl_mask.nonzero()
+++++++++-            split_idxs = 1 + rl_idxs
+++++++++-
+++++++++-            prev = None
+++++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
+++++++++-                if not len(vehs_i):
+++++++++-                    continue # Last vehicle is RL, so the last split is empty
+++++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
+++++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
+++++++++-                )
+++++++++-                if prev is not None:
+++++++++-                    prev.next = platoon
+++++++++-                prev = platoon
+++++++++-                for veh in vehs_i:
+++++++++-                    veh.platoon = platoon
+++++++++-            if prev is not None:
+++++++++-                prev.next = None
+++++++++-
+++++++++-    def reset(self):
+++++++++-        c = self.c
+++++++++-        if c.e is False:
+++++++++-            if 'length_range' in c:
+++++++++-                min_, max_ = c.length_range
+++++++++-                c.setdefaults(max_length=max_)
+++++++++-                c.length = np.random.randint(min_, max_ + 1)
+++++++++-            if 'av_range' in c:
+++++++++-                min_, max_ = c.av_range
+++++++++-                c.av_frac = np.random.uniform(min_, max_)
+++++++++-        self.mp_tlast = 0
+++++++++-        while not self.reset_sumo():
+++++++++-            pass
+++++++++-        ret = super().init_env()
+++++++++-        return ret
+++++++++-
+++++++++-    def step(self, action=[]):
+++++++++-        c = self.c
+++++++++-        ts = self.ts
+++++++++-        max_dist = c.max_dist
+++++++++-        depart_speed = c.depart_speed
+++++++++-        max_speed = c.max_speed
+++++++++-
+++++++++-        rl_type = ts.types.rl
+++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++-
+++++++++-        for rl, act in zip(prev_rls, action):
+++++++++-            if c.handcraft or c.handcraft_tl:
+++++++++-                route, lane = rl.route, rl.lane
+++++++++-                junction = lane.next_junction
+++++++++-                level = 1
+++++++++-                if junction is not ts.sentinel_junction:
+++++++++-                    dist = junction.route_position[route] - rl.route_position
+++++++++-                    if c.handcraft:
+++++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
+++++++++-                    elif c.handcraft_tl and dist < 15:
+++++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
+++++++++-                        yellow_time = 0
+++++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
+++++++++-                        horizontal_go = 0 <= rem < t_h
+++++++++-                        vertical_go = t_h + yellow_time <= rem
+++++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
+++++++++-                        human_remain = False
+++++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
+++++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
+++++++++-            elif c.act_type == 'accel':
+++++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
+++++++++-            else:
+++++++++-                level = act / (c.n_actions - 1)
+++++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++-
+++++++++-        if c.tl == 'MaxPressure':
+++++++++-            self.mp_tlast += c.sim_step
+++++++++-            tmin = c.get('mp_tmin', 0)
+++++++++-            if self.mp_tlast >= tmin:
+++++++++-                for tl in ts.traffic_lights:
+++++++++-                    if ts.get_program(tl) == 'off':
+++++++++-                        break
+++++++++-                    jun = tl.junction
+++++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
+++++++++-
+++++++++-                    total_pressures = []
+++++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
+++++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
+++++++++-
+++++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
+++++++++-                self.mp_tlast = 0
+++++++++-
+++++++++-        super().step()
+++++++++-        self.build_platoon()
+++++++++-
+++++++++-        obs = {}
+++++++++-
+++++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
+++++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
+++++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
+++++++++-        for veh in rl_type.vehicles:
+++++++++-            if hasattr(veh, 'lane'):
+++++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
+++++++++-                junction = lane.next_junction
+++++++++-
+++++++++-                head, tail = veh, platoon.tail
+++++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
+++++++++-
+++++++++-                if junction is ts.sentinel_junction:
+++++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
+++++++++-                else:
+++++++++-                    for jun_lane in lane.next_junction_lanes:
+++++++++-                        # Defaults for jun_lane
+++++++++-                        jun_headtails = vehs_default()
+++++++++-
+++++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
+++++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
+++++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
+++++++++-
+++++++++-                        if jun_veh:
+++++++++-                            if jun_veh.type is rl_type:
+++++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
+++++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
+++++++++-                                platoon = jun_veh.platoon.prev
+++++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++++-                                    if platoon is None: break
+++++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++++-                                    platoon = platoon.prev
+++++++++-                            else:
+++++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
+++++++++-                                jun_headtails[0] = jun_veh.platoon.tail
+++++++++-                                next_cross_platoon = jun_veh.platoon.prev
+++++++++-                                if next_cross_platoon:
+++++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
+++++++++-                                    platoon = next_cross_platoon.prev
+++++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++++-                                        if platoon is None: break
+++++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++++-                                        platoon = platoon.prev
+++++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
+++++++++-
+++++++++-                dist_features, speed_features = [], []
+++++++++-                for route, vehs in route_vehs:
+++++++++-                    j_pos = junction.route_position[route]
+++++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
+++++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
+++++++++-
+++++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++-
+++++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
+++++++++-        ids = sorted(obs)
+++++++++-        if c.mrtl:
+++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
+++++++++-        if c.rew_type == 'outflow':
+++++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++-        elif c.rew_type == 'time_penalty':
+++++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
+++++++++-        
+++++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++-
+++++++++-        raw_drac = self.calc_drac()
+++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++-        raw_pet = self.calc_pet()
+++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++-        pet = np.clip(pet/6, -1, 1)
+++++++++-
+++++++++-        raw_ttc = self.calc_ttc()
+++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++-
+++++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
+++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++-
+++++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++-        return returned
+++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++-        
+++++++++-    def calc_drac(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        dracs = []
+++++++++-        for v in cur_veh_list:
+++++++++-            if hasattr(v, 'lane'):
+++++++++-                leader, headway = v.leader()
+++++++++-                v_speed = v.speed
+++++++++-                leader_speed = leader.speed
+++++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++-                dracs.append(drac)
+++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++-        return fleet_drac
+++++++++-    
+++++++++-    def calc_pet(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        pets = []
+++++++++-        for v in cur_veh_list:
+++++++++-            if hasattr(v, 'lane'):
+++++++++-                leader, headway = v.leader()
+++++++++-                v_speed = v.speed
+++++++++-                if v_speed > 1e-16:
+++++++++-                    pet = headway/(v_speed)
+++++++++-                    pets.append(pet)
+++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++-        return fleet_pet
+++++++++-
+++++++++-    def calc_ttc(self):
+++++++++-        cur_veh_list = self.ts.vehicles
+++++++++-        ttcs = []
+++++++++-        for v in cur_veh_list:
+++++++++-            if hasattr(v, 'lane'):
+++++++++-                leader, headway = v.leader()
+++++++++-                v_speed = v.speed
+++++++++-                leader_speed = leader.speed
+++++++++-                if leader_speed < v_speed:
+++++++++-                    ttc =  headway/(v_speed-leader_speed)
+++++++++-                else:
+++++++++-                    ttc = np.nan
+++++++++-                ttcs.append(ttc)
+++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++-        return fleet_ttc
+++++++++-
+++++++++-    def append_step_info(self):
+++++++++-        super().append_step_info()
+++++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
+++++++++-
+++++++++-    @property
+++++++++-    def stats(self):
+++++++++-        c = self.c
+++++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
+++++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
+++++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
+++++++++-        stats['backlog_step'] = mean(info['backlog'])
+++++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
+++++++++-
+++++++++-        stats['beta'] = c.beta
+++++++++-
+++++++++-        if c.multi_flowrate:
+++++++++-            stats['flow_horizontal'] = c.flow_rate_h
+++++++++-            stats['flow_vertical'] = c.flow_rate_v
+++++++++-        return stats
+++++++++-
+++++++++-class Intersection(Main):
+++++++++-    def create_env(c):
+++++++++-        if c.multi_flowrate:
+++++++++-            return NormEnv(c, IntersectionEnv(c))
+++++++++-        else:
+++++++++-            c._norm = NormEnv(c, None)
+++++++++-            return IntersectionEnv(c)
+++++++++-
+++++++++-    @property
+++++++++-    def observation_space(c):
+++++++++-        low = np.full(c._n_obs, c.low)
+++++++++-        return Box(low, np.ones_like(low))
+++++++++-
+++++++++-    @property
+++++++++-    def action_space(c):
+++++++++-        if c.act_type == 'accel':
+++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++++-        else:
+++++++++-            return Discrete(c.n_actions)
+++++++++-
+++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++-        step_obs_ = rollout.obs
+++++++++-        step_obs = step_obs_[:-1]
+++++++++-
+++++++++-        if not c.multi_flowrate:
+++++++++-            rollout.raw_reward = rollout.reward
+++++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
+++++++++-
+++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++-
+++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++-
+++++++++-        step_id_ = rollout.pop('id')
+++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++-        id_unique = np.unique(id)
+++++++++-
+++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
+++++++++-
+++++++++-        log(**stats)
+++++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
+++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++-        log(
+++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++-            n_veh_unique=len(id_unique),
+++++++++-            
+++++++++-            reward_mean=np.mean(reward),
+++++++++-            reward_std=np.std(reward),        
+++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++-
+++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++-            )
+++++++++-        
+++++++++-        return rollout
+++++++++-
+++++++++-if __name__ == '__main__':
+++++++++-    c = Intersection.from_args(globals(), locals())
+++++++++-    c.setdefaults(
+++++++++-        n_steps=200,
+++++++++-        step_save=5,
+++++++++-
+++++++++-        depart_speed=0,
+++++++++-        max_speed=13,
+++++++++-        max_dist=100,
+++++++++-        max_accel=1.5,
+++++++++-        max_decel=3.5,
+++++++++-        sim_step=0.5,
+++++++++-        generic_type=True,
+++++++++-        n_actions=3,
+++++++++-
+++++++++-        adv_norm=False,
+++++++++-        batch_concat=True,
+++++++++-
+++++++++-        render=False,
+++++++++-
+++++++++-        warmup_steps=100,
+++++++++-        horizon=2000,
+++++++++-        directions='4way',
+++++++++-        av_frac=0.15,
+++++++++-        handcraft=False,
+++++++++-        handcraft_tl=None,
+++++++++-        flow_rate=700,
+++++++++-        length=100,
+++++++++-        n_rows=1,
+++++++++-        n_cols=1,
+++++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
+++++++++-
+++++++++-        act_type='accel_discrete',
+++++++++-        low=-1,
+++++++++-
+++++++++-        alg=PG,
+++++++++-        n_gds=1,
+++++++++-        lr=1e-3,
+++++++++-        gamma=0.99,
+++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++-
+++++++++-        enter_length=False,
+++++++++-        short_exit=False,
+++++++++-
+++++++++-        rew_type='outflow',
+++++++++-        norm_reward=True,
+++++++++-        center_reward=True,
+++++++++-        multi_flowrate=False,
+++++++++-        opt='RMSprop',
+++++++++-
+++++++++-        obs_tail=True,
+++++++++-        obs_next_cross_platoons=1,
+++++++++-
+++++++++-        beta=0,
+++++++++-        scale_pet=1,
+++++++++-        scale_drac=1,
+++++++++-        seed_np=False,
+++++++++-        seed_torch = False,
+++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++-    )
+++++++++-
+++++++++-    if c.seed_torch:
+++++++++-        # Set seed for PyTorch CPU operations
+++++++++-        torch.manual_seed(c.seed_torch)
+++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++-        if torch.cuda.is_available():
+++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++-    if c.seed_np:
+++++++++-        np.random.seed(c.seed_np)
+++++++++-
+++++++++-    if c.directions == '4way':
+++++++++-        c.directions = ['up', 'right', 'down', 'left']
+++++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
+++++++++-    if c.mrtl:
+++++++++-        c._n_obs += 1
+++++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
+++++++++-    c.redef_sumo = 'length_range' in c
+++++++++-    c.run()
+++++++++\ No newline at end of file
+++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++index d4c3dac..8e000fa 100644
+++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++@@ -1,600 +1,7677 @@
+++++++++-diff --git a/README.md b/README.md
+++++++++-index b591747..127f484 100644
+++++++++---- a/README.md
+++++++++-+++ b/README.md
+++++++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
+++++++++- ### 1.2 Set the environmental variables
+++++++++- ```
+++++++++- # Code directory
+++++++++--export F=automatic_vehicular_control/automatic_vehicular_control
+++++++++-+export F=automatic_vehicular_control
+++++++++- 
+++++++++- # Results directory extracted from the zip file
+++++++++- export R=results
+++++++++-@@ -48,10 +48,8 @@ export R=results
+++++++++- ## 2. Directory Structure
+++++++++- 
+++++++++- The code directory structure is
+++++++++--```
+++++++++-+``` 
+++++++++- automatic_vehicular_control/
+++++++++--│
+++++++++--├── automatic_vehicular_control/
+++++++++- │   ├── __pycache__/                # Compiled Python files
+++++++++- │   ├── evaluations/                # Evaluation results and metrics
+++++++++- │   ├── models/                     # Model checkpoints
+++++++++ diff --git a/env.py b/env.py
+++++++++-index 4ab3d95..c83a674 100644
++++++++++index c83a674..92ff463 100644
+++++++++ --- a/env.py
+++++++++ +++ b/env.py
+++++++++-@@ -724,9 +724,11 @@ class TrafficState:
+++++++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
+++++++++- 
+++++++++-         segments = {}
+++++++++-+        
+++++++++-         def add_from_to(from_, to):
+++++++++-             from_.tos.add(to)
+++++++++-             to.froms.add(from_)
+++++++++-+            
+++++++++-         for con in map(values_str_to_val, net.children('connection')):
+++++++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
+++++++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
+++++++++-@@ -888,89 +890,109 @@ class TrafficState:
+++++++++- 
+++++++++-     def step(self):
+++++++++-         """
+++++++++--        Take a simulation step and update state
+++++++++-+        Take a simulation step and update state.
+++++++++-         """
+++++++++--        c = self.c
+++++++++--        tc = self.tc
+++++++++--        subscribes = self.subscribes
+++++++++-+        c = self.c  # Configuration object for the simulation
+++++++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
+++++++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
+++++++++- 
+++++++++-         # Actual SUMO step
+++++++++--        tc.simulationStep()
+++++++++--        sim_res = subscribes.sim.get()
+++++++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
+++++++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
+++++++++- 
+++++++++-+        # Clear references to current vehicle edges and lanes for the next update
+++++++++-         for veh in self.vehicles:
+++++++++--            veh.unvar('edge', 'lane')
+++++++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
+++++++++-+
+++++++++-+        # Clear current vehicle data from edges and lanes
+++++++++-         for ent in itertools.chain(self.edges, self.lanes):
+++++++++--            ent.vehicles.clear()
+++++++++--            ent.positions.clear()
+++++++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
+++++++++-+            ent.positions.clear()  # Clear vehicle positions
+++++++++- 
+++++++++-+        # Update traffic light states
+++++++++-         for tl_id, tl in self.traffic_lights.items():
+++++++++--            tl.update(subscribes.tl.get(tl_id))
+++++++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
+++++++++- 
+++++++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
+++++++++-         for veh_id in sim_res.loaded_vehicles_ids:
+++++++++--            flow_id, _ = veh_id.rsplit('.')
+++++++++--            flow = self.flows[flow_id]
+++++++++--            flow.backlog.add(veh_id)
+++++++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
+++++++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
+++++++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
+++++++++- 
+++++++++-+        # Initialize a set for newly departed vehicles
+++++++++-         self.new_departed = set()
+++++++++-+
+++++++++-+        # Handle vehicles that have departed (entered the network)
+++++++++-         for veh_id in sim_res.departed_vehicles_ids:
+++++++++--            subscribes.veh.subscribe(veh_id)
+++++++++--            type_id = tc.vehicle.getTypeID(veh_id)
+++++++++--            # import pdb; pdb.set_trace()
+++++++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
+++++++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
+++++++++-+            # If vehicle type is 'generic', compute specific type
+++++++++-             if type_id == 'generic':
+++++++++-                 type_id = self.compute_type(veh_id)
+++++++++--            type_ = self.types[type_id]
+++++++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
+++++++++--            length = tc.vehicle.getLength(veh_id)
+++++++++--            road_id = tc.vehicle.getRoadID(veh_id)
+++++++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
+++++++++--            type_.vehicles.add(veh)
+++++++++-+            type_ = self.types[type_id]  # Get vehicle type object
+++++++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
+++++++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
+++++++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
+++++++++-+
+++++++++-+            # Create a new vehicle object and add it to the list of vehicles
+++++++++-+            self.vehicles[veh_id] = veh = Vehicle(
+++++++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
+++++++++-+            )
+++++++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
+++++++++- 
+++++++++-+            # Set color if rendering is enabled
+++++++++-             if c.render:
+++++++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
+++++++++--                self.set_color(veh, color_fn(veh))
+++++++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
+++++++++- 
+++++++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
+++++++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
+++++++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
+++++++++-+
+++++++++-+            # Add to new_departed set
+++++++++-             self.new_departed.add(veh)
+++++++++-+
+++++++++-+            # Remove vehicle from backlog if necessary
+++++++++-             if '.' in veh_id:
+++++++++-                 flow_id, _ = veh_id.rsplit('.')
+++++++++-                 if flow_id in self.flows:
+++++++++-                     flow = self.flows[flow_id]
+++++++++-                     flow.backlog.remove(veh_id)
+++++++++- 
+++++++++-+        # Handle newly arrived and collided vehicles
+++++++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
+++++++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
+++++++++-+        
+++++++++-+        # Remove newly arrived vehicles from tracking if they collided
+++++++++-         for veh in self.new_arrived:
+++++++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
+++++++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
+++++++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
+++++++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
+++++++++- 
+++++++++-+        # Update vehicle positions on edges and lanes
+++++++++-         for veh_id, veh in self.vehicles.items():
+++++++++--            veh.prev_speed = veh.get('speed', None)
+++++++++--            veh.update(subscribes.veh.get(veh_id))
+++++++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
+++++++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
+++++++++-             if veh_id not in sim_res.colliding_vehicles_ids:
+++++++++--                edge = self.edges[veh.road_id]
+++++++++--                edge.vehicles.append(veh)
+++++++++--                veh.edge = edge
+++++++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
+++++++++--            # edge = self.edges[veh.road_id]
+++++++++--            # edge.vehicles.append(veh)
+++++++++--            # veh.edge = edge
+++++++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
+++++++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
+++++++++-+                veh.edge = edge  # Set vehicle's edge attribute
+++++++++- 
+++++++++-+        # Update vehicle sorting and lane positions
+++++++++-         for edge in self.edges:
+++++++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
+++++++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
+++++++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
+++++++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
+++++++++-             for edge_i, veh in enumerate(edge.vehicles):
+++++++++--                veh.edge_i = edge_i
+++++++++--                veh.lane = lane = edge.lanes[veh.lane_index]
+++++++++--                veh.lane_i = len(lane.vehicles)
+++++++++--                lane.vehicles.append(veh)
+++++++++--                lane.positions.append(veh.laneposition)
+++++++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
+++++++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
+++++++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
+++++++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
+++++++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
+++++++++- 
+++++++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
+++++++++-         self.all_arrived.append(self.new_arrived)
+++++++++-         self.all_departed.append(self.new_departed)
+++++++++-         self.all_collided.append(self.new_collided)
+++++++++--
+++++++++-+            
+++++++++-     def reset(self, tc):
+++++++++-         self.tc = tc
+++++++++-         self.subscribes.clear()
+++++++++-@@ -1043,6 +1065,7 @@ class Env:
+++++++++-     """
+++++++++-     Offers a similar reinforcement learning environment interface as gym.Env
+++++++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
+++++++++-+    c: Ring class
+++++++++-     """
+++++++++-     def __init__(self, c):
+++++++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
+++++++++-@@ -1056,6 +1079,7 @@ class Env:
+++++++++-             if c.get('save_agent'):
+++++++++-                 self._agent_info = []
+++++++++-         self._step = 0
+++++++++-+        self.mean_speed = 0
+++++++++- 
+++++++++-     def def_sumo(self, *args, **kwargs):
+++++++++-         """ Override this with code defining the SUMO network """
+++++++++-@@ -1094,49 +1118,91 @@ class Env:
+++++++++-         """
+++++++++-         return True
+++++++++- 
+++++++++-+   # Method to reset or initialize the SUMO traffic simulation environment
+++++++++-     def reset_sumo(self):
+++++++++-+        # Shortcuts for configuration and SUMO definition objects
+++++++++-         c = self.c
+++++++++-         sumo_def = self.sumo_def
+++++++++--
+++++++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+++++++++-+        
+++++++++-+        # Determine if new SUMO definitions need to be generated
+++++++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
+++++++++-+        
+++++++++-         if generate_def:
+++++++++--            kwargs = self.def_sumo()
+++++++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
+++++++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
+++++++++-+            # Generate new definitions if necessary
+++++++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
+++++++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
+++++++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++++++++++@@ -852,12 +852,15 @@ class TrafficState:
++++++++++         subscribes.sim = SubscribeDef(tc.simulation, [
++++++++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
++++++++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
+++++++++ +        
+++++++++-+        # Start SUMO with the current traffic controller (tc)
+++++++++-         self.tc = sumo_def.start_sumo(self.tc)
+++++++++-+        
+++++++++-         if generate_def:
+++++++++-+            # If new definitions were generated, store relevant SUMO file paths
+++++++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
+++++++++-+            
+++++++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
+++++++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
+++++++++--            self.ts = TrafficState(c, self.tc, **defs)
+++++++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
+++++++++-         else:
+++++++++-+            # If not generating new definitions, simply reset the existing traffic state
+++++++++-             self.ts.reset(self.tc)
+++++++++-+        
+++++++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
+++++++++-         self.ts.setup()
++++++++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
++++++++++             TL.red_yellow_green_state])
+++++++++ +        
+++++++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+++++++++-         success = self.init_vehicles()
++++++++++         subscribes.veh = SubscribeDef(tc.vehicle, [
++++++++++             V.road_id, V.lane_index, V.laneposition,
++++++++++             V.speed, V.position, V.angle,
++++++++++             V.fuelconsumption, V.noxemission])
+++++++++ +        
+++++++++-+        # Return whether the SUMO reset and vehicle initialization were successful
+++++++++-         return success
++++++++++         for tl_id in self.traffic_lights.keys():
++++++++++             subscribes.tl.subscribe(tl_id)
+++++++++  
+++++++++-+    # Method to initialize the environment after SUMO reset
+++++++++-     def init_env(self):
+++++++++-+        # Reference to the traffic state
+++++++++-         ts = self.ts
+++++++++-+    
+++++++++-+        # Create an empty data structure to store rollout information
+++++++++-         self.rollout_info = NamedArrays()
+++++++++-+        
+++++++++-+        # Turn off all traffic lights in the network
+++++++++-         for tl in ts.traffic_lights:
+++++++++--            ts.set_program(tl, 'off')
+++++++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
+++++++++-+        
+++++++++-+        # Reset the step counter to 0
+++++++++-         self._step = 0
+++++++++-+        
+++++++++-+        # Take the first step in the simulation
+++++++++-         ret = self.step()
+++++++++-+        
+++++++++-+        # Run the simulation for a number of warmup steps
+++++++++-         for _ in range(self.c.warmup_steps):
+++++++++--            ret = self.step()
+++++++++-+            ret = self.step()  # Advance the simulation one step
+++++++++-+            
+++++++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
+++++++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
+++++++++-                 return None
+++++++++-+        
+++++++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
+++++++++-         for tl in ts.traffic_lights:
+++++++++--            ts.set_program(tl, '1')
+++++++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
+++++++++-+        
+++++++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
+++++++++-         if isinstance(ret, tuple):
+++++++++--            return ret[0]
+++++++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
+++++++++--
+++++++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
+++++++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
+++++++++-+        
+++++++++-+    # Reset the entire environment, retrying until successful
+++++++++-     def reset(self):
+++++++++--        while True:
+++++++++-+        self.mean_speed = 0
+++++++++-+        while True:  # Infinite loop until the environment is successfully reset
+++++++++-+            # Attempt to reset the SUMO simulation
+++++++++-             if not self.reset_sumo():
+++++++++--                continue
+++++++++-+                continue  # If reset_sumo fails, retry the loop
+++++++++-+            
+++++++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++++++++-             if (obs := self.init_env()) is not None:
+++++++++--                return obs
+++++++++-+                return obs  # Successfully initialized, return the observation
++++++++++@@ -1148,6 +1151,7 @@ class Env:
++++++++++             self.ts.reset(self.tc)
++++++++++         
++++++++++         # Set up the traffic state (e.g., initialize the simulation settings)
+++++++++ +
+++++++++- 
+++++++++-     def append_step_info(self):
+++++++++-         """
+++++++++-@@ -1231,6 +1297,8 @@ class Env:
+++++++++- class NormEnv(gym.Env):
+++++++++-     """
+++++++++-     Reward normalization with running average https://github.com/joschu/modular_rl
+++++++++-+    self.c: Ring parameters 
+++++++++-+    self.env: RingEnv class
+++++++++-     """
+++++++++-     def __init__(self, c, env):
+++++++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
++++++++++         self.ts.setup()
++++++++++         
++++++++++         # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+++++++++ diff --git a/exp.py b/exp.py
+++++++++-index ead4652..7f7cee5 100644
++++++++++index 7f7cee5..e6a53c6 100644
+++++++++ --- a/exp.py
+++++++++ +++ b/exp.py
+++++++++-@@ -169,9 +169,9 @@ class Main(Config):
+++++++++- 
+++++++++-     def on_train_start(c):
+++++++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
+++++++++--        c.setdefaults(alg='Algorithm')
+++++++++--        c._env = c.create_env()
+++++++++--
+++++++++-+        c.setdefaults(alg='Algorithm') 
++++++++++@@ -408,7 +408,6 @@ class Main(Config):
++++++++++         # Main training loop
++++++++++         c.on_train_start()
++++++++++         while c._i < c.n_steps:
++++++++++-            c.on_step_start() # save stat 
++++++++++             with torch.no_grad():
++++++++++                 # Collect rollouts without computing gradients
++++++++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++++++@@ -497,3 +496,29 @@ class Main(Config):
++++++++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
++++++++++             c.train()
++++++++++         c.log('job done!')
+++++++++++
+++++++++++    def run_2(c):
+++++++++++        # Determine whether to train or evaluate based on configuration
+++++++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
+++++++++ +        c._env = c.create_env() # Create NormEnv
+++++++++-+ 
+++++++++-         # Instantiate the algorithm (e.g., PPO, DQN)
+++++++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
+++++++++-         c.set_model()
+++++++++-@@ -222,8 +222,8 @@ class Main(Config):
+++++++++- 
+++++++++-     def on_step_start(c, stats={}):
+++++++++-         # Update the learning rate and log stats at the start of a training step
+++++++++--        lr = c._lr
+++++++++--        for g in c._opt.param_groups:
+++++++++-+        lr = c._lr # Update Learning Rate
+++++++++-+        for g in c._opt.param_groups: # Log Statistics
+++++++++-             g['lr'] = float(lr)
+++++++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
+++++++++- 
+++++++++-@@ -285,10 +285,14 @@ class Main(Config):
+++++++++-             ret = dict(obs=ret)
+++++++++-         rollout = NamedArrays()
+++++++++-         rollout.append(**ret)
+++++++++--
+++++++++-+        rollout_flow_each_step = []
+++++++++-         done = False
+++++++++-         a_space = c.action_space
+++++++++-         step = 0
+++++++++++        ret = c._env.reset()
+++++++++++        step = 0
+++++++++ +        density = 20/(250*1e-3)
+++++++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
+++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+++++++++-+
+++++++++-         while step < c.horizon + c.skip_stat_steps and not done:
+++++++++-             # Generate an action from the model's policy
+++++++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
+++++++++-@@ -309,6 +313,12 @@ class Main(Config):
+++++++++-             rollout.append(**ret)
+++++++++-             step += 1
+++++++++-         # Collect stats from the environment
+++++++++++        done = False
+++++++++++        while step < c.horizon + c.skip_stat_steps and not done:
+++++++++++            # Take a step in the environment
+++++++++++            ret = c._env.step()
+++++++++++            if isinstance(ret, tuple):
+++++++++++                obs, reward, done, info = ret
+++++++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
+++++++++++            done = ret.setdefault('done', False)
+++++++++++            step += 1
+++++++++++        # Collect stats from the environment
+++++++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+++++++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+++++++++ +        density = 20/(250 * 1e-3)
+++++++++ +        vehicle_flow = c._env.mean_speed * density 
+++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+++++++++-+
+++++++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
+++++++++-         return rollout, stats
+++++++++- 
+++++++++-@@ -398,10 +408,10 @@ class Main(Config):
+++++++++-         # Main training loop
+++++++++-         c.on_train_start()
+++++++++-         while c._i < c.n_steps:
+++++++++--            c.on_step_start()
+++++++++-+            c.on_step_start() # save stat 
+++++++++-             with torch.no_grad():
+++++++++-                 # Collect rollouts without computing gradients
+++++++++--                rollouts = c.rollouts()
+++++++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++++++-             gd_stats = {}
+++++++++-             if len(rollouts.obs):
+++++++++-                 t_start = time()
+++++++++-@@ -410,7 +420,7 @@ class Main(Config):
+++++++++-                 gd_stats.update(gd_time=time() - t_start)
+++++++++-             c.on_step_end(gd_stats)
+++++++++-             c._i += 1
+++++++++--        c.on_step_start()  # last step
+++++++++-+        c.on_step_start()  # save stat
+++++++++-         gd_stats = {}
+++++++++-         with torch.no_grad():
+++++++++-             rollouts = c.rollouts()
+++++++++-@@ -450,6 +460,8 @@ class Main(Config):
+++++++++-         if hasattr(c._env, 'close'):
+++++++++-             c._env.close()
+++++++++- 
+++++++++-+  
+++++++++-+
+++++++++-     def run(c):
+++++++++-         # Determine whether to train or evaluate based on configuration
+++++++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++++++-diff --git a/ring.py b/ring.py
+++++++++-index 94d632d..ee1372b 100644
+++++++++---- a/ring.py
+++++++++-+++ b/ring.py
+++++++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
+++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++++++-         )
++++++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
++++++++++deleted file mode 100644
++++++++++index 6b9ba52..0000000
++++++++++--- a/highway_bottleneck.py
+++++++++++++ /dev/null
++++++++++@@ -1,381 +0,0 @@
++++++++++-from automatic_vehicular_control.exp import *
++++++++++-from automatic_vehicular_control.env import *
++++++++++-from automatic_vehicular_control.u import *
+++++++++ -
+++++++++-         # Function to generate the shape of the edges (circular arcs)
+++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++++++++- 
+++++++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
+++++++++-         if c.circumference_range:  # Check if the circumference should be randomized
+++++++++-             # Randomly set the circumference within the specified range
+++++++++-             c.circumference = np.random.randint(*c.circumference_range)
+++++++++-+        
+++++++++-+        if self.flow_log:
+++++++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
+++++++++-+            self.episode_flow.append(average_flow)
+++++++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
+++++++++-+        
+++++++++-+        # Reset flow counters for the new episode
+++++++++-+        self.flow_counter = 0
+++++++++-+        self.flow_log = []
+++++++++-+        self.last_vehicle_times = {}
+++++++++-+        
+++++++++-         return super().reset_sumo()  # Reset the simulation
+++++++++- 
+++++++++-     @property
+++++++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
+++++++++-         }
+++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
+++++++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
+++++++++-         return stats
+++++++++--
+++++++++-+    
+++++++++-+    def calculate_flow(self):
+++++++++-+        """
+++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++++++-+        """
+++++++++-+        current_time = self.ts.time
+++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++++++-+
+++++++++-+        for vehicle in vehicles_on_edge:
+++++++++-+            # Check if vehicle has passed the observation point since the last timestep
+++++++++-+            if vehicle.id not in self.last_vehicle_times:
+++++++++-+                # If the vehicle was not previously recorded, count it as a new passage
+++++++++-+                self.flow_counter += 1
+++++++++-+            else:
+++++++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
+++++++++-+                last_time = self.last_vehicle_times[vehicle.id]
+++++++++-+                if current_time - last_time > self.c.sim_step:
+++++++++-+                    self.flow_counter += 1
+++++++++-+
+++++++++-+            # Update the last time the vehicle passed the point
+++++++++-+            self.last_vehicle_times[vehicle.id] = current_time
+++++++++-+
+++++++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
+++++++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
+++++++++-+        self.flow_log.append(flow_per_hour)
+++++++++-+        return flow_per_hour
+++++++++-+    
+++++++++-     def step(self, action=None):
+++++++++-         c = self.c  # Configuration object
+++++++++-         ts = self.ts  # Time step object
+++++++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
+++++++++-                     # Change to a specific lane
+++++++++-                     ts.lane_change_to(rl, lc)
++++++++++-class BNeckEnv(Env):
++++++++++-    def def_sumo(self):
++++++++++-        c = self.c
++++++++++-        nodes = E('nodes',
++++++++++-            E('node', id='n_0', x=0, y=0), *(
++++++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
++++++++++-        ))
++++++++++-        edges = E('edges', *(
++++++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
++++++++++-                'numLanes': n_lane,
++++++++++-                'speed': c.max_speed
++++++++++-            }) for i, n_lane in enumerate(c.n_lanes)
++++++++++-        ))
++++++++++-        connections = E('connections', *(
++++++++++-            E('connection', **{
++++++++++-                'from': prev.id,
++++++++++-                'to': curr.id,
++++++++++-                'fromLane': i,
++++++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
++++++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
++++++++++-        ))
++++++++++-
++++++++++-        if c.split_flow:
++++++++++-            n_inflow_lanes = c.n_lanes[0]
++++++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
++++++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
++++++++++-                for i in range(n_inflow_lanes)
++++++++++-            ]
++++++++++-        else:
++++++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
++++++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
++++++++++-            ]
++++++++++-        routes = E('routes',
++++++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
++++++++++-            *flows
++++++++++-        )
++++++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
++++++++++-        additional = E('additional',
++++++++++-            E('vType', id='generic', **idm_params),
++++++++++-            E('vType', id='rl', **idm_params),
++++++++++-            E('vType', id='human', **idm_params),
++++++++++-        )
++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++++++-
++++++++++-    def reset_sumo(self):
++++++++++-        c = self.c
++++++++++-        if c.flow_rate_range:
++++++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
++++++++++-        ret = super().reset_sumo()
++++++++++-        if c.vinitsky:
++++++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
++++++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
++++++++++-                for i_start in range(round(edge.length) // c.piece_length)
++++++++++-                for lane in edge.lanes
++++++++++-            ]
++++++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
++++++++++-            self.last_outflows = []
++++++++++-        return ret
++++++++++-
++++++++++-    def step(self, action=[]):
++++++++++-        c = self.c
++++++++++-        ts = self.ts
++++++++++-        max_dist = 100
++++++++++-        max_speed = c.max_speed
++++++++++-        human_type = ts.types.human
++++++++++-        rl_type = ts.types.rl
++++++++++-
++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++++-        if c.vinitsky:
++++++++++-            if len(action):
++++++++++-                assert len(action) == len(self.control_lanes)
++++++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
++++++++++-                    self.control_lanes[lane, piece_start] = np.clip(
++++++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
++++++++++-                        0.1, max_speed
++++++++++-                    )
++++++++++-                for veh in prev_rls:
++++++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
++++++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
++++++++++-        else:
++++++++++-            for veh, act in zip(prev_rls, action):
++++++++++-                if c.handcraft:
++++++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
++++++++++-                    next_lane = lane.next(veh.route)
++++++++++-                    level = 1
++++++++++-                    if next_lane and next_lane.get('junction'):
++++++++++-                        merge_dist = lane.length - veh.laneposition
++++++++++-                        if merge_dist < c.handcraft:
++++++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
++++++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
++++++++++-                                level = 0
++++++++++-                    if c.act_type.startswith('accel'):
++++++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++-                    else:
++++++++++-                        ts.set_max_speed(veh, max_speed * level)
++++++++++-                    continue
++++++++++-                if not isinstance(act, (int, np.integer)):
++++++++++-                    act = (act - c.low) / (1 - c.low)
++++++++++-                if c.act_type.startswith('accel'):
++++++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++-                else:
++++++++++-                    if c.act_type == 'continuous':
++++++++++-                        level = act[0]
++++++++++-                    elif c.act_type == 'discretize':
++++++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++++++-                    elif c.act_type == 'discrete':
++++++++++-                        level = act / (c.n_actions - 1)
++++++++++-                    ts.set_max_speed(veh, max_speed * level)
++++++++++-
++++++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
++++++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
++++++++++-
++++++++++-        super().step()
++++++++++-
++++++++++-        if c.vinitsky:
++++++++++-            n_last_outflows = 20
++++++++++-            max_vehs = 4
++++++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
++++++++++-            obs = []
++++++++++-            for lane, piece_start in self.obs_lanes:
++++++++++-                piece_end = piece_start + c.piece_length
++++++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
++++++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
++++++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
++++++++++-                obs.extend([
++++++++++-                    len(lane_humans) / max_vehs,
++++++++++-                    len(lane_avs) / max_vehs,
++++++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
++++++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
++++++++++-                ])
++++++++++-            if len(self.last_outflows) == n_last_outflows:
++++++++++-                self.last_outflows = self.last_outflows[1:]
++++++++++-            self.last_outflows.append(len(ts.new_arrived))
++++++++++-            reward = np.mean(self.last_outflows)
++++++++++-            obs.append(reward / max_veh_outflows)
++++++++++-            obs = np.array(obs, dtype=np.float32)
++++++++++-            assert 0 <= obs.min() and obs.max() <= 1
++++++++++-            return obs, reward, False, None
++++++++++-        route = nexti(ts.routes)
++++++++++-        obs, ids = [], []
++++++++++-        default_close = [0, max_speed]
++++++++++-        default_far = [max_dist, 0]
++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++++++-            merge_dist = max_dist
++++++++++-            default_human = default_far
++++++++++-
++++++++++-            other_info = {}
++++++++++-            next_lane = lane.next(veh.route)
++++++++++-            if next_lane and next_lane.get('junction'):
++++++++++-                merge_dist = lane.length - veh.laneposition
++++++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
++++++++++-                # Look for veh on other lane but do not extend past that lane
++++++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
++++++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
++++++++++-                    if other_veh.type is rl_type:
++++++++++-                        default_human = default_close
++++++++++-                        break
++++++++++-
++++++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
++++++++++-            ids.append(veh.id)
++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++++-        
++++++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++++-
++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++++-
++++++++++-        raw_pet = self.calc_pet()
++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++++-        pet = np.clip(pet, -1, 1)
++++++++++-
++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++++-        
++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++++-        return returned
++++++++++-        
++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++++-    
++++++++++-    def calc_ttc(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        ttcs = []
++++++++++-        for v in cur_veh_list:
++++++++++-            leader, headway = v.leader()
++++++++++-            v_speed = v.speed
++++++++++-            leader_speed = leader.speed
++++++++++-            if leader_speed < v_speed:
++++++++++-                ttc =  headway/(v_speed-leader_speed)
++++++++++-            else:
++++++++++-                ttc = np.nan
++++++++++-            ttcs.append(ttc)
++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++++-        return fleet_ttc
++++++++++-    
++++++++++-    def calc_drac(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        dracs = []
++++++++++-        for v in cur_veh_list:
++++++++++-            leader, headway = v.leader()
++++++++++-            v_speed = v.speed
++++++++++-            leader_speed = leader.speed
++++++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++++-            dracs.append(drac)
++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++++-        return fleet_drac
++++++++++-
++++++++++-    def calc_pet(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        pets = []
++++++++++-        for v in cur_veh_list:
++++++++++-            leader, headway = v.leader()
++++++++++-            v_speed = v.speed
++++++++++-            if v_speed > 1e-16:
++++++++++-                pet = headway/(v_speed)
++++++++++-                pets.append(pet)
++++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++++-        return fleet_pet
++++++++++-
++++++++++-class BNeck(Main):
++++++++++-    def create_env(c):
++++++++++-        return BNeckEnv(c)
++++++++++-
++++++++++-    @property
++++++++++-    def observation_space(c):
++++++++++-        low = np.full(c._n_obs, c.low)
++++++++++-        return Box(low, np.ones_like(low))
++++++++++-
++++++++++-    @property
++++++++++-    def action_space(c):
++++++++++-        if c.vinitsky:
++++++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++++++-            assert c.lc_av in [False, 'binary']
++++++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++++++-            return Discrete(c.n_actions)
++++++++++-
++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++++-        if c.vinitsky:
++++++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
++++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++++-        step_obs_ = rollout.obs
++++++++++-        step_obs = step_obs_[:-1]
++++++++++-
++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++++-
++++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++++-
++++++++++-        step_id_ = rollout.pop('id')
++++++++++-        id = np.concatenate(step_id_[:-1])
++++++++++-        id_unique = np.unique(id)
++++++++++-
++++++++++-        reward = np.array(rollout.pop('reward'))
++++++++++-
++++++++++-        log(**stats)
++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++++-        log(
++++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++++-            n_veh_unique=len(id_unique),
++++++++++-            
++++++++++-            reward_mean=np.mean(reward),
++++++++++-            reward_std=np.std(reward),        
++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++++-            ssm_std=np.std(rollout.ssm),
++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++-
++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++++-            # res_action = np.mean(rollout.res_action),
++++++++++-            )
++++++++++-        return rollout
++++++++++-
++++++++++-if __name__ == '__main__':
++++++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
++++++++++-        warmup_steps=1000,
++++++++++-        horizon=2000,
++++++++++-        n_steps=100,
++++++++++-        step_save=5,
++++++++++-
++++++++++-        av_frac=0.2,
++++++++++-        sim_step=0.5,
++++++++++-        depart_speed=0,
++++++++++-        edge_lengths=[100, 100, 50],
++++++++++-        n_lanes=[4, 2, 1],
++++++++++-        max_speed=30,
++++++++++-
++++++++++-        lc_av=False,
++++++++++-        flow_rate=2300,
++++++++++-        flow_rate_range=None,
++++++++++-        split_flow=True,
++++++++++-        generic_type='rand',
++++++++++-        speed_mode=SPEED_MODE.all_checks,
++++++++++-        lc_mode=LC_MODE.off,
++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++++-
++++++++++-        veh_junction=False,
++++++++++-        act_type='accel_discrete',
++++++++++-        max_accel=2.6,
++++++++++-        max_decel=4.5,
++++++++++-        tau=1.0,
++++++++++-        min_gap=2.5,
++++++++++-        delta=4,
++++++++++-        n_actions=3,
++++++++++-        low=-1,
++++++++++-        handcraft=False,
++++++++++-        vinitsky=False,
++++++++++-
++++++++++-        render=False,
++++++++++-
++++++++++-        alg=PG,
++++++++++-        lr=1e-3,
++++++++++-
++++++++++-        gamma=0.99,
++++++++++-        adv_norm=False,
++++++++++-        batch_concat=True,
++++++++++-
++++++++++-        beta=0,
++++++++++-        scale_ttc=1,
++++++++++-        scale_drac=1,
++++++++++-        seed_np=False,
++++++++++-        seed_torch = False,
++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++++-
++++++++++-    )
++++++++++-    
++++++++++-    if c.seed_torch:
++++++++++-        # Set seed for PyTorch CPU operations
++++++++++-        torch.manual_seed(c.seed_torch)
++++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++++-        if torch.cuda.is_available():
++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++++-    if c.seed_np:
++++++++++-        np.random.seed(c.seed_np)
++++++++++-        
++++++++++-    if c.vinitsky:
++++++++++-        c.piece_length = 20
++++++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
++++++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
++++++++++-        c._n_action = sum(n_actions[:-1])
++++++++++-        c._n_obs = sum(n_actions) * 4 + 1
++++++++++-        c.batch_concat = False
++++++++++-    else:
++++++++++-        c._n_obs = 2 + 2 + 2
++++++++++-        
++++++++++-    if c.mrtl:
++++++++++-        c._n_obs += 1 # modified for mrtl related
++++++++++-        
++++++++++-    c.redef_sumo = bool(c.flow_rate_range)
++++++++++-    c.run()
++++++++++\ No newline at end of file
++++++++++diff --git a/highway_ramp.py b/highway_ramp.py
++++++++++deleted file mode 100644
++++++++++index ef0358f..0000000
++++++++++--- a/highway_ramp.py
+++++++++++++ /dev/null
++++++++++@@ -1,325 +0,0 @@
++++++++++-from automatic_vehicular_control.exp import *
++++++++++-from automatic_vehicular_control.env import *
++++++++++-from automatic_vehicular_control.u import *
++++++++++-
++++++++++-class RampEnv(Env):
++++++++++-    # https://flow-project.github.io/papers/08569485.pdf
++++++++++-    def def_sumo(self):
++++++++++-        c = self.c
++++++++++-        builder = NetBuilder()
++++++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
++++++++++-            (0, 0),
++++++++++-            (c.premerge_distance, 0),
++++++++++-            (c.premerge_distance + c.merge_distance, 0),
++++++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
++++++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
++++++++++-        ])
++++++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
++++++++++-            {}, {'numLanes': 2}, {}
++++++++++-        ], lane_maps=[
++++++++++-            {0: 1}, {0: 0, 1: 0}
++++++++++-        ], route_id='highway')
++++++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
++++++++++-            {}, {'numLanes': 2}, {}
++++++++++-        ], lane_maps=[
++++++++++-            {0: 0}, {0: 0, 1: 0}
++++++++++-        ], route_id='ramp')
++++++++++-        nodes, edges, connections, routes = builder.build()
++++++++++-        nodes[2].type = 'zipper'
++++++++++-
++++++++++-        routes = E('routes',
++++++++++-            *routes,
++++++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
++++++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
++++++++++-        )
++++++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
++++++++++-        additional = E('additional',
++++++++++-            E('vType', id='generic', **idm),
++++++++++-            E('vType', id='rl', **idm),
++++++++++-            E('vType', id='human', **idm),
++++++++++-        )
++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++++++-
++++++++++-    def step(self, action=[]):
++++++++++-        c = self.c
++++++++++-        ts = self.ts
++++++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
++++++++++-        max_speed = c.max_speed
++++++++++-        human_type = ts.types.human
++++++++++-        rl_type = ts.types.rl
++++++++++-
++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++++-        for rl, act in zip(prev_rls, action):
++++++++++-            if c.handcraft:
++++++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
++++++++++-                leader, dist = rl.leader()
++++++++++-                level = 1
++++++++++-                if edge.id == 'e_n_0.0_n_400.0':
++++++++++-                    if rl.laneposition < 100:
++++++++++-                        leaders = list(rl.leaders())
++++++++++-                        if len(leaders) > 20:
++++++++++-                            level = 0
++++++++++-                        else:
++++++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
++++++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++-                continue
++++++++++-            if not isinstance(act, (int, np.integer)):
++++++++++-                act = (act - c.low) / (1 - c.low)
++++++++++-            if c.act_type.startswith('accel'):
++++++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++-            else:
++++++++++-                if c.act_type == 'continuous':
++++++++++-                    level = act[0]
++++++++++-                elif c.act_type == 'discretize':
++++++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++++++-                elif c.act_type == 'discrete':
++++++++++-                    level = act / (c.n_actions - 1)
++++++++++-                ts.set_max_speed(rl, max_speed * level)
++++++++++-
++++++++++-        super().step()
++++++++++-
++++++++++-        route = ts.routes.highway
++++++++++-        obs, ids = [], []
++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++++++-            if hasattr(veh, 'edge'):
++++++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++++++-                merge_dist = max_dist
++++++++++-
++++++++++-                lead_speed = follow_speed = other_speed = 0
++++++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
++++++++++-
++++++++++-                leader, dist = veh.leader()
++++++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
++++++++++-
++++++++++-                follower, dist = veh.follower()
++++++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
++++++++++-
++++++++++-                if c.global_obs:
++++++++++-                    jun_edge = edge.next(route)
++++++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
++++++++++-                        jun_edge = jun_edge.next(route)
++++++++++-                    if jun_edge:
++++++++++-                        merge_dist = lane.length - veh.laneposition
++++++++++-                        next_edge = edge.next(route)
++++++++++-                        while next_edge is not jun_edge:
++++++++++-                            merge_dist += next_edge.length
++++++++++-                            next_edge = next_edge.next(route)
++++++++++-
++++++++++-                        other_lane = jun_edge.lanes[0]
++++++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
++++++++++-                            other_speed = other_veh.speed
++++++++++-                            break
++++++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
++++++++++-                else:
++++++++++-                    next_lane = lane.next(route)
++++++++++-                    if next_lane and next_lane.get('junction'):
++++++++++-                        if len(edge.lanes) == 2:
++++++++++-                            other_lane = edge.lanes[0]
++++++++++-                            pos = veh.laneposition
++++++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
++++++++++-                                other_speed = other_veh.speed
++++++++++-                                break
++++++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
++++++++++-                ids.append(veh.id)
++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
++++++++++-        if c.mrtl:
++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++++-        
++++++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++++-
++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++++-
++++++++++-        raw_pet = self.calc_pet()
++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++++-        pet = np.clip(pet, -1, 1)
++++++++++-
++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++++-        
++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++++-        return returned
++++++++++-        
++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++++-    
++++++++++-    def calc_ttc(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        ttcs = []
++++++++++-        for v in cur_veh_list:
++++++++++-            if hasattr(v, 'edge'):
++++++++++-                leader, headway = v.leader()
++++++++++-                if leader:
++++++++++-                    v_speed = v.speed
++++++++++-                    leader_speed = leader.speed
++++++++++-                    if leader_speed < v_speed:
++++++++++-                        ttc =  headway/(v_speed-leader_speed)
++++++++++-                    else:
++++++++++-                        ttc = np.nan
++++++++++-                    ttcs.append(ttc)
++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++++-        return fleet_ttc
++++++++++-    
++++++++++-    def calc_drac(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        dracs = []
++++++++++-        for v in cur_veh_list:
++++++++++-            if hasattr(v, 'edge'):
++++++++++-                leader, headway = v.leader()
++++++++++-                if leader:
++++++++++-                    v_speed = v.speed
++++++++++-                    leader_speed = leader.speed
++++++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++++-                    dracs.append(drac)
++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++++-        return fleet_drac
++++++++++-
++++++++++-    def calc_pet(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        pets = []
++++++++++-        for v in cur_veh_list:
++++++++++-            if hasattr(v, 'edge'):
++++++++++-                leader, headway = v.leader()
++++++++++-                if leader:
++++++++++-                    v_speed = v.speed
++++++++++-                    if v_speed > 1e-16:
++++++++++-                        pet = headway/(v_speed)
++++++++++-                        pets.append(pet)
++++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
++++++++++-        return fleet_pet
++++++++++-
++++++++++-class Ramp(Main):
++++++++++-    def create_env(c):
++++++++++-        return RampEnv(c)
++++++++++-
++++++++++-    @property
++++++++++-    def observation_space(c):
++++++++++-        low = np.full(c._n_obs, c.low)
++++++++++-        return Box(low, np.ones_like(low))
++++++++++-
++++++++++-    @property
++++++++++-    def action_space(c):
++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++++++-            return Discrete(c.n_actions)
++++++++++-
++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++++-        step_obs_ = rollout.obs
++++++++++-        step_obs = step_obs_[:-1]
++++++++++-
++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++++-
++++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++++-
++++++++++-        step_id_ = rollout.pop('id')
++++++++++-        id = np.concatenate(step_id_[:-1])
++++++++++-        id_unique = np.unique(id)
++++++++++-
++++++++++-        reward = np.array(rollout.pop('reward'))
++++++++++-
++++++++++-        log(**stats)
++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++++-        log(
++++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++++-            n_veh_unique=len(id_unique),
++++++++++-            
++++++++++-            reward_mean=np.mean(reward),
++++++++++-            reward_std=np.std(reward),        
++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++++-            ssm_std=np.std(rollout.ssm),
++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++-
++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++++-            # res_action = np.mean(rollout.res_action),
++++++++++-            )
++++++++++-        return rollout
++++++++++-
++++++++++-if __name__ == '__main__':
++++++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
++++++++++-        warmup_steps=100,
++++++++++-        horizon=2000,
++++++++++-        n_steps=100,
++++++++++-        step_save=5,
++++++++++-
++++++++++-        premerge_distance=400,
++++++++++-        merge_distance=100,
++++++++++-        postmerge_distance=30,
++++++++++-        av_frac=0.1,
++++++++++-        sim_step=0.5,
++++++++++-        max_speed=30,
++++++++++-        highway_depart_speed=10,
++++++++++-        ramp_depart_speed=0,
++++++++++-        highway_flow_rate=2000,
++++++++++-        ramp_flow_rate=300,
++++++++++-        global_obs=False,
++++++++++-        handcraft=False,
++++++++++-
++++++++++-        generic_type='default',
++++++++++-        speed_mode=SPEED_MODE.all_checks,
++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++++-
++++++++++-        act_type='accel_discrete',
++++++++++-        max_accel=1,
++++++++++-        max_decel=1.5,
++++++++++-        n_actions=3,
++++++++++-        low=-1,
++++++++++-
++++++++++-        render=False,
++++++++++-
++++++++++-        alg=PG,
++++++++++-        lr=1e-3,
++++++++++-
++++++++++-        gamma=0.99,
++++++++++-        adv_norm=False,
++++++++++-        batch_concat=True,
++++++++++-
++++++++++-        beta=0,
++++++++++-        scale_ttc=1,
++++++++++-        scale_drac=1,
++++++++++-        seed_np=False,
++++++++++-        seed_torch = False,
++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++++-
++++++++++-    )
++++++++++-    
++++++++++-    if c.seed_torch:
++++++++++-        # Set seed for PyTorch CPU operations
++++++++++-        torch.manual_seed(c.seed_torch)
++++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++++-        if torch.cuda.is_available():
++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++++-    if c.seed_np:
++++++++++-        np.random.seed(c.seed_np)
++++++++++-        
++++++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
++++++++++-    if c.mrtl:
++++++++++-        c._n_obs += 1 # modified for mrtl related
++++++++++-    c.run()
++++++++++\ No newline at end of file
++++++++++diff --git a/intersection.py b/intersection.py
++++++++++deleted file mode 100644
++++++++++index e38a84f..0000000
++++++++++--- a/intersection.py
+++++++++++++ /dev/null
++++++++++@@ -1,489 +0,0 @@
++++++++++-from automatic_vehicular_control.u import *
++++++++++-from automatic_vehicular_control.exp import *
++++++++++-from automatic_vehicular_control.env import *
++++++++++-
++++++++++-class Platoon(Entity):
++++++++++-    pass
++++++++++-
++++++++++-class IntersectionEnv(Env):
++++++++++-    def def_sumo(self):
++++++++++-        c = self.c
++++++++++-
++++++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
++++++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
++++++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
++++++++++-        ] if params.get('vehsPerHour')]
++++++++++-
++++++++++-        builder = NetBuilder()
++++++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
++++++++++-        if c.enter_length:
++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++++++-            xys[1:, :, 0] += c.enter_length - c.length
++++++++++-            xys[:, 1:, 1] += c.enter_length - c.length
++++++++++-            xys = xys.reshape(-1, 2)
++++++++++-        if c.short_exit:
++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++++++-            xys[-1, :, 0] += c.short_exit - c.length
++++++++++-            xys[:, -1, 1] += c.short_exit - c.length
++++++++++-            xys = xys.reshape(-1, 2)
++++++++++-        nodes = builder.add_nodes(
++++++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
++++++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
++++++++++-        # import pdb; pdb.set_trace()
++++++++++-
++++++++++-        tl = c.setdefault('tl', False)
++++++++++-        if tl:
++++++++++-            c.av_frac = 0
++++++++++-            c.pop('av_range', None)
++++++++++-            c.speed_mode = SPEED_MODE.all_checks
++++++++++-
++++++++++-        flows = []
++++++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
++++++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
++++++++++-        for direction in c.directions:
++++++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
++++++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
++++++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
++++++++++-
++++++++++-            edge_attrs = dict(priority=int(direction in priority))
++++++++++-            if c.get('set_edge_speed', True):
++++++++++-                edge_attrs['speed'] = c.max_speed
++++++++++-
++++++++++-            for i, chain in enumerate(chains[1:-1]):
++++++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
++++++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
++++++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
++++++++++-
++++++++++-        tls = []
++++++++++-        if tl:
++++++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
++++++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
++++++++++-            tl_offset = c.get('tl_offset', 'auto')
++++++++++-            yellow = c.get('yellow', 0.5)
++++++++++-            if tl_offset == 'auto':
++++++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
++++++++++-            elif tl_offset == 'same':
++++++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
++++++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
++++++++++-                node.type = 'traffic_light'
++++++++++-                phase_multiple = len(c.directions) // 2
++++++++++-                tls.append(E('tlLogic',
++++++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
++++++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
++++++++++-                id=node.id, offset=offset, type='static', programID='1'))
++++++++++-
++++++++++-        nodes, edges, connections, routes = builder.build()
++++++++++-        additional = E('additional', *types, *routes, *flows, *tls)
++++++++++-        return super().def_sumo(nodes, edges, connections, additional)
++++++++++-
++++++++++-    def build_platoon(self):
++++++++++-        ts = self.ts
++++++++++-        rl_type = ts.types.rl
++++++++++-        for route in ts.routes:
++++++++++-            vehs = []
++++++++++-            route_offset = 0
++++++++++-            for edge in route.edges:
++++++++++-                for veh in edge.vehicles:
++++++++++-                    veh.route_position = route_offset + veh.laneposition
++++++++++-                    vehs.append(veh)
++++++++++-                route_offset += edge.length
++++++++++-
++++++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
++++++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
++++++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
++++++++++-            rl_idxs, = rl_mask.nonzero()
++++++++++-            split_idxs = 1 + rl_idxs
++++++++++-
++++++++++-            prev = None
++++++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
++++++++++-                if not len(vehs_i):
++++++++++-                    continue # Last vehicle is RL, so the last split is empty
++++++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
++++++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
++++++++++-                )
++++++++++-                if prev is not None:
++++++++++-                    prev.next = platoon
++++++++++-                prev = platoon
++++++++++-                for veh in vehs_i:
++++++++++-                    veh.platoon = platoon
++++++++++-            if prev is not None:
++++++++++-                prev.next = None
++++++++++-
++++++++++-    def reset(self):
++++++++++-        c = self.c
++++++++++-        if c.e is False:
++++++++++-            if 'length_range' in c:
++++++++++-                min_, max_ = c.length_range
++++++++++-                c.setdefaults(max_length=max_)
++++++++++-                c.length = np.random.randint(min_, max_ + 1)
++++++++++-            if 'av_range' in c:
++++++++++-                min_, max_ = c.av_range
++++++++++-                c.av_frac = np.random.uniform(min_, max_)
++++++++++-        self.mp_tlast = 0
++++++++++-        while not self.reset_sumo():
++++++++++-            pass
++++++++++-        ret = super().init_env()
++++++++++-        return ret
++++++++++-
++++++++++-    def step(self, action=[]):
++++++++++-        c = self.c
++++++++++-        ts = self.ts
++++++++++-        max_dist = c.max_dist
++++++++++-        depart_speed = c.depart_speed
++++++++++-        max_speed = c.max_speed
++++++++++-
++++++++++-        rl_type = ts.types.rl
++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++++-
++++++++++-        for rl, act in zip(prev_rls, action):
++++++++++-            if c.handcraft or c.handcraft_tl:
++++++++++-                route, lane = rl.route, rl.lane
++++++++++-                junction = lane.next_junction
++++++++++-                level = 1
++++++++++-                if junction is not ts.sentinel_junction:
++++++++++-                    dist = junction.route_position[route] - rl.route_position
++++++++++-                    if c.handcraft:
++++++++++-                        for cross_lane in lane.next_cross_lanes:
++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
++++++++++-                    elif c.handcraft_tl and dist < 15:
++++++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
++++++++++-                        yellow_time = 0
++++++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
++++++++++-                        horizontal_go = 0 <= rem < t_h
++++++++++-                        vertical_go = t_h + yellow_time <= rem
++++++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
++++++++++-                        human_remain = False
++++++++++-                        for cross_lane in lane.next_cross_lanes:
++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
++++++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
++++++++++-            elif c.act_type == 'accel':
++++++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
++++++++++-            else:
++++++++++-                level = act / (c.n_actions - 1)
++++++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++-
++++++++++-        if c.tl == 'MaxPressure':
++++++++++-            self.mp_tlast += c.sim_step
++++++++++-            tmin = c.get('mp_tmin', 0)
++++++++++-            if self.mp_tlast >= tmin:
++++++++++-                for tl in ts.traffic_lights:
++++++++++-                    if ts.get_program(tl) == 'off':
++++++++++-                        break
++++++++++-                    jun = tl.junction
++++++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
++++++++++-
++++++++++-                    total_pressures = []
++++++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
++++++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
++++++++++-
++++++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
++++++++++-                self.mp_tlast = 0
++++++++++-
++++++++++-        super().step()
++++++++++-        self.build_platoon()
++++++++++-
++++++++++-        obs = {}
++++++++++-
++++++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
++++++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
++++++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
++++++++++-        for veh in rl_type.vehicles:
++++++++++-            if hasattr(veh, 'lane'):
++++++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
++++++++++-                junction = lane.next_junction
++++++++++-
++++++++++-                head, tail = veh, platoon.tail
++++++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
++++++++++-
++++++++++-                if junction is ts.sentinel_junction:
++++++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
++++++++++-                else:
++++++++++-                    for jun_lane in lane.next_junction_lanes:
++++++++++-                        # Defaults for jun_lane
++++++++++-                        jun_headtails = vehs_default()
++++++++++-
++++++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
++++++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
++++++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
++++++++++-
++++++++++-                        if jun_veh:
++++++++++-                            if jun_veh.type is rl_type:
++++++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
++++++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
++++++++++-                                platoon = jun_veh.platoon.prev
++++++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++++++-                                    if platoon is None: break
++++++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++++++-                                    platoon = platoon.prev
++++++++++-                            else:
++++++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
++++++++++-                                jun_headtails[0] = jun_veh.platoon.tail
++++++++++-                                next_cross_platoon = jun_veh.platoon.prev
++++++++++-                                if next_cross_platoon:
++++++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
++++++++++-                                    platoon = next_cross_platoon.prev
++++++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++++++-                                        if platoon is None: break
++++++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++++++-                                        platoon = platoon.prev
++++++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
++++++++++-
++++++++++-                dist_features, speed_features = [], []
++++++++++-                for route, vehs in route_vehs:
++++++++++-                    j_pos = junction.route_position[route]
++++++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
++++++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
++++++++++-
++++++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++++-
++++++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
++++++++++-        ids = sorted(obs)
++++++++++-        if c.mrtl:
++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
++++++++++-        if c.rew_type == 'outflow':
++++++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++++-        elif c.rew_type == 'time_penalty':
++++++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
++++++++++-        
++++++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++++-
++++++++++-        raw_drac = self.calc_drac()
++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++++-        raw_pet = self.calc_pet()
++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++++-        pet = np.clip(pet/6, -1, 1)
++++++++++-
++++++++++-        raw_ttc = self.calc_ttc()
++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++++-
++++++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++++-
++++++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++++-        return returned
++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++++-        
++++++++++-    def calc_drac(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        dracs = []
++++++++++-        for v in cur_veh_list:
++++++++++-            if hasattr(v, 'lane'):
++++++++++-                leader, headway = v.leader()
++++++++++-                v_speed = v.speed
++++++++++-                leader_speed = leader.speed
++++++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++++-                dracs.append(drac)
++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++++-        return fleet_drac
++++++++++-    
++++++++++-    def calc_pet(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        pets = []
++++++++++-        for v in cur_veh_list:
++++++++++-            if hasattr(v, 'lane'):
++++++++++-                leader, headway = v.leader()
++++++++++-                v_speed = v.speed
++++++++++-                if v_speed > 1e-16:
++++++++++-                    pet = headway/(v_speed)
++++++++++-                    pets.append(pet)
++++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++++-        return fleet_pet
++++++++++-
++++++++++-    def calc_ttc(self):
++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++-        ttcs = []
++++++++++-        for v in cur_veh_list:
++++++++++-            if hasattr(v, 'lane'):
++++++++++-                leader, headway = v.leader()
++++++++++-                v_speed = v.speed
++++++++++-                leader_speed = leader.speed
++++++++++-                if leader_speed < v_speed:
++++++++++-                    ttc =  headway/(v_speed-leader_speed)
++++++++++-                else:
++++++++++-                    ttc = np.nan
++++++++++-                ttcs.append(ttc)
++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++++-        return fleet_ttc
++++++++++-
++++++++++-    def append_step_info(self):
++++++++++-        super().append_step_info()
++++++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
++++++++++-
++++++++++-    @property
++++++++++-    def stats(self):
++++++++++-        c = self.c
++++++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
++++++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
++++++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
++++++++++-        stats['backlog_step'] = mean(info['backlog'])
++++++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
++++++++++-
++++++++++-        stats['beta'] = c.beta
++++++++++-
++++++++++-        if c.multi_flowrate:
++++++++++-            stats['flow_horizontal'] = c.flow_rate_h
++++++++++-            stats['flow_vertical'] = c.flow_rate_v
++++++++++-        return stats
++++++++++-
++++++++++-class Intersection(Main):
++++++++++-    def create_env(c):
++++++++++-        if c.multi_flowrate:
++++++++++-            return NormEnv(c, IntersectionEnv(c))
++++++++++-        else:
++++++++++-            c._norm = NormEnv(c, None)
++++++++++-            return IntersectionEnv(c)
++++++++++-
++++++++++-    @property
++++++++++-    def observation_space(c):
++++++++++-        low = np.full(c._n_obs, c.low)
++++++++++-        return Box(low, np.ones_like(low))
++++++++++-
++++++++++-    @property
++++++++++-    def action_space(c):
++++++++++-        if c.act_type == 'accel':
++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++++++-        else:
++++++++++-            return Discrete(c.n_actions)
++++++++++-
++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++++-        step_obs_ = rollout.obs
++++++++++-        step_obs = step_obs_[:-1]
++++++++++-
++++++++++-        if not c.multi_flowrate:
++++++++++-            rollout.raw_reward = rollout.reward
++++++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
++++++++++-
++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++++-
++++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++++-
++++++++++-        step_id_ = rollout.pop('id')
++++++++++-        id = np.concatenate(step_id_[:-1])
++++++++++-        id_unique = np.unique(id)
++++++++++-
++++++++++-        reward = np.array(rollout.pop('reward'))
++++++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
++++++++++-
++++++++++-        log(**stats)
++++++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++++-        log(
++++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++++-            n_veh_unique=len(id_unique),
++++++++++-            
++++++++++-            reward_mean=np.mean(reward),
++++++++++-            reward_std=np.std(reward),        
++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++++-            ssm_std=np.std(rollout.ssm),
++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++-
++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++++-            # res_action = np.mean(rollout.res_action),
++++++++++-            )
++++++++++-        
++++++++++-        return rollout
++++++++++-
++++++++++-if __name__ == '__main__':
++++++++++-    c = Intersection.from_args(globals(), locals())
++++++++++-    c.setdefaults(
++++++++++-        n_steps=200,
++++++++++-        step_save=5,
++++++++++-
++++++++++-        depart_speed=0,
++++++++++-        max_speed=13,
++++++++++-        max_dist=100,
++++++++++-        max_accel=1.5,
++++++++++-        max_decel=3.5,
++++++++++-        sim_step=0.5,
++++++++++-        generic_type=True,
++++++++++-        n_actions=3,
++++++++++-
++++++++++-        adv_norm=False,
++++++++++-        batch_concat=True,
++++++++++-
++++++++++-        render=False,
++++++++++-
++++++++++-        warmup_steps=100,
++++++++++-        horizon=2000,
++++++++++-        directions='4way',
++++++++++-        av_frac=0.15,
++++++++++-        handcraft=False,
++++++++++-        handcraft_tl=None,
++++++++++-        flow_rate=700,
++++++++++-        length=100,
++++++++++-        n_rows=1,
++++++++++-        n_cols=1,
++++++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
++++++++++-
++++++++++-        act_type='accel_discrete',
++++++++++-        low=-1,
++++++++++-
++++++++++-        alg=PG,
++++++++++-        n_gds=1,
++++++++++-        lr=1e-3,
++++++++++-        gamma=0.99,
++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++++-
++++++++++-        enter_length=False,
++++++++++-        short_exit=False,
++++++++++-
++++++++++-        rew_type='outflow',
++++++++++-        norm_reward=True,
++++++++++-        center_reward=True,
++++++++++-        multi_flowrate=False,
++++++++++-        opt='RMSprop',
++++++++++-
++++++++++-        obs_tail=True,
++++++++++-        obs_next_cross_platoons=1,
++++++++++-
++++++++++-        beta=0,
++++++++++-        scale_pet=1,
++++++++++-        scale_drac=1,
++++++++++-        seed_np=False,
++++++++++-        seed_torch = False,
++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++++-    )
++++++++++-
++++++++++-    if c.seed_torch:
++++++++++-        # Set seed for PyTorch CPU operations
++++++++++-        torch.manual_seed(c.seed_torch)
++++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++++-        if torch.cuda.is_available():
++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++++-    if c.seed_np:
++++++++++-        np.random.seed(c.seed_np)
++++++++++-
++++++++++-    if c.directions == '4way':
++++++++++-        c.directions = ['up', 'right', 'down', 'left']
++++++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
++++++++++-    if c.mrtl:
++++++++++-        c._n_obs += 1
++++++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
++++++++++-    c.redef_sumo = 'length_range' in c
++++++++++-    c.run()
++++++++++\ No newline at end of file
++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++index d4c3dac..ef625f7 100644
++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++@@ -1,600 +1,5572 @@
++++++++++-diff --git a/README.md b/README.md
++++++++++-index b591747..127f484 100644
++++++++++---- a/README.md
++++++++++-+++ b/README.md
++++++++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
++++++++++- ### 1.2 Set the environmental variables
++++++++++- ```
++++++++++- # Code directory
++++++++++--export F=automatic_vehicular_control/automatic_vehicular_control
++++++++++-+export F=automatic_vehicular_control
++++++++++- 
++++++++++- # Results directory extracted from the zip file
++++++++++- export R=results
++++++++++-@@ -48,10 +48,8 @@ export R=results
++++++++++- ## 2. Directory Structure
++++++++++- 
++++++++++- The code directory structure is
++++++++++--```
++++++++++-+``` 
++++++++++- automatic_vehicular_control/
++++++++++--│
++++++++++--├── automatic_vehicular_control/
++++++++++- │   ├── __pycache__/                # Compiled Python files
++++++++++- │   ├── evaluations/                # Evaluation results and metrics
++++++++++- │   ├── models/                     # Model checkpoints
++++++++++ diff --git a/env.py b/env.py
++++++++++-index 4ab3d95..c83a674 100644
+++++++++++index c83a674..92ff463 100644
++++++++++ --- a/env.py
++++++++++ +++ b/env.py
++++++++++-@@ -724,9 +724,11 @@ class TrafficState:
++++++++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
++++++++++- 
++++++++++-         segments = {}
++++++++++-+        
++++++++++-         def add_from_to(from_, to):
++++++++++-             from_.tos.add(to)
++++++++++-             to.froms.add(from_)
++++++++++-+            
++++++++++-         for con in map(values_str_to_val, net.children('connection')):
++++++++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
++++++++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
++++++++++-@@ -888,89 +890,109 @@ class TrafficState:
++++++++++- 
++++++++++-     def step(self):
++++++++++-         """
++++++++++--        Take a simulation step and update state
++++++++++-+        Take a simulation step and update state.
++++++++++-         """
++++++++++--        c = self.c
++++++++++--        tc = self.tc
++++++++++--        subscribes = self.subscribes
++++++++++-+        c = self.c  # Configuration object for the simulation
++++++++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
++++++++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
++++++++++- 
++++++++++-         # Actual SUMO step
++++++++++--        tc.simulationStep()
++++++++++--        sim_res = subscribes.sim.get()
++++++++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
++++++++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
++++++++++- 
++++++++++-+        # Clear references to current vehicle edges and lanes for the next update
++++++++++-         for veh in self.vehicles:
++++++++++--            veh.unvar('edge', 'lane')
++++++++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
++++++++++-+
++++++++++-+        # Clear current vehicle data from edges and lanes
++++++++++-         for ent in itertools.chain(self.edges, self.lanes):
++++++++++--            ent.vehicles.clear()
++++++++++--            ent.positions.clear()
++++++++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
++++++++++-+            ent.positions.clear()  # Clear vehicle positions
++++++++++- 
++++++++++-+        # Update traffic light states
++++++++++-         for tl_id, tl in self.traffic_lights.items():
++++++++++--            tl.update(subscribes.tl.get(tl_id))
++++++++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
++++++++++- 
++++++++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
++++++++++-         for veh_id in sim_res.loaded_vehicles_ids:
++++++++++--            flow_id, _ = veh_id.rsplit('.')
++++++++++--            flow = self.flows[flow_id]
++++++++++--            flow.backlog.add(veh_id)
++++++++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
++++++++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
++++++++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
++++++++++- 
++++++++++-+        # Initialize a set for newly departed vehicles
++++++++++-         self.new_departed = set()
++++++++++-+
++++++++++-+        # Handle vehicles that have departed (entered the network)
++++++++++-         for veh_id in sim_res.departed_vehicles_ids:
++++++++++--            subscribes.veh.subscribe(veh_id)
++++++++++--            type_id = tc.vehicle.getTypeID(veh_id)
++++++++++--            # import pdb; pdb.set_trace()
++++++++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
++++++++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
++++++++++-+            # If vehicle type is 'generic', compute specific type
++++++++++-             if type_id == 'generic':
++++++++++-                 type_id = self.compute_type(veh_id)
++++++++++--            type_ = self.types[type_id]
++++++++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
++++++++++--            length = tc.vehicle.getLength(veh_id)
++++++++++--            road_id = tc.vehicle.getRoadID(veh_id)
++++++++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
++++++++++--            type_.vehicles.add(veh)
++++++++++-+            type_ = self.types[type_id]  # Get vehicle type object
++++++++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
++++++++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
++++++++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
++++++++++-+
++++++++++-+            # Create a new vehicle object and add it to the list of vehicles
++++++++++-+            self.vehicles[veh_id] = veh = Vehicle(
++++++++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
++++++++++-+            )
++++++++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
++++++++++- 
++++++++++-+            # Set color if rendering is enabled
++++++++++-             if c.render:
++++++++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
++++++++++--                self.set_color(veh, color_fn(veh))
++++++++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
++++++++++- 
++++++++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
++++++++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
++++++++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
++++++++++-+
++++++++++-+            # Add to new_departed set
++++++++++-             self.new_departed.add(veh)
++++++++++-+
++++++++++-+            # Remove vehicle from backlog if necessary
++++++++++-             if '.' in veh_id:
++++++++++-                 flow_id, _ = veh_id.rsplit('.')
++++++++++-                 if flow_id in self.flows:
++++++++++-                     flow = self.flows[flow_id]
++++++++++-                     flow.backlog.remove(veh_id)
++++++++++- 
++++++++++-+        # Handle newly arrived and collided vehicles
++++++++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
++++++++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
++++++++++-+        
++++++++++-+        # Remove newly arrived vehicles from tracking if they collided
++++++++++-         for veh in self.new_arrived:
++++++++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
++++++++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
++++++++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
++++++++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
++++++++++- 
++++++++++-+        # Update vehicle positions on edges and lanes
++++++++++-         for veh_id, veh in self.vehicles.items():
++++++++++--            veh.prev_speed = veh.get('speed', None)
++++++++++--            veh.update(subscribes.veh.get(veh_id))
++++++++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
++++++++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
++++++++++-             if veh_id not in sim_res.colliding_vehicles_ids:
++++++++++--                edge = self.edges[veh.road_id]
++++++++++--                edge.vehicles.append(veh)
++++++++++--                veh.edge = edge
++++++++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
++++++++++--            # edge = self.edges[veh.road_id]
++++++++++--            # edge.vehicles.append(veh)
++++++++++--            # veh.edge = edge
++++++++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
++++++++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
++++++++++-+                veh.edge = edge  # Set vehicle's edge attribute
++++++++++- 
++++++++++-+        # Update vehicle sorting and lane positions
++++++++++-         for edge in self.edges:
++++++++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
++++++++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
++++++++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
++++++++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
++++++++++-             for edge_i, veh in enumerate(edge.vehicles):
++++++++++--                veh.edge_i = edge_i
++++++++++--                veh.lane = lane = edge.lanes[veh.lane_index]
++++++++++--                veh.lane_i = len(lane.vehicles)
++++++++++--                lane.vehicles.append(veh)
++++++++++--                lane.positions.append(veh.laneposition)
++++++++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
++++++++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
++++++++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
++++++++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
++++++++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
++++++++++- 
++++++++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
++++++++++-         self.all_arrived.append(self.new_arrived)
++++++++++-         self.all_departed.append(self.new_departed)
++++++++++-         self.all_collided.append(self.new_collided)
++++++++++--
++++++++++-+            
++++++++++-     def reset(self, tc):
++++++++++-         self.tc = tc
++++++++++-         self.subscribes.clear()
++++++++++-@@ -1043,6 +1065,7 @@ class Env:
++++++++++-     """
++++++++++-     Offers a similar reinforcement learning environment interface as gym.Env
++++++++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
++++++++++-+    c: Ring class
++++++++++-     """
++++++++++-     def __init__(self, c):
++++++++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
++++++++++-@@ -1056,6 +1079,7 @@ class Env:
++++++++++-             if c.get('save_agent'):
++++++++++-                 self._agent_info = []
++++++++++-         self._step = 0
++++++++++-+        self.mean_speed = 0
++++++++++- 
++++++++++-     def def_sumo(self, *args, **kwargs):
++++++++++-         """ Override this with code defining the SUMO network """
++++++++++-@@ -1094,49 +1118,91 @@ class Env:
++++++++++-         """
++++++++++-         return True
++++++++++- 
++++++++++-+   # Method to reset or initialize the SUMO traffic simulation environment
++++++++++-     def reset_sumo(self):
++++++++++-+        # Shortcuts for configuration and SUMO definition objects
++++++++++-         c = self.c
++++++++++-         sumo_def = self.sumo_def
++++++++++--
++++++++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
++++++++++-+        
++++++++++-+        # Determine if new SUMO definitions need to be generated
++++++++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
++++++++++-+        
++++++++++-         if generate_def:
++++++++++--            kwargs = self.def_sumo()
++++++++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
++++++++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
++++++++++-+            # Generate new definitions if necessary
++++++++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
++++++++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
++++++++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++++++++++-+        
++++++++++-+        # Start SUMO with the current traffic controller (tc)
++++++++++-         self.tc = sumo_def.start_sumo(self.tc)
++++++++++-+        
++++++++++-         if generate_def:
++++++++++-+            # If new definitions were generated, store relevant SUMO file paths
++++++++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
++++++++++-+            
++++++++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
++++++++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
++++++++++--            self.ts = TrafficState(c, self.tc, **defs)
++++++++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
++++++++++-         else:
++++++++++-+            # If not generating new definitions, simply reset the existing traffic state
++++++++++-             self.ts.reset(self.tc)
+++++++++++@@ -852,12 +852,15 @@ class TrafficState:
+++++++++++         subscribes.sim = SubscribeDef(tc.simulation, [
+++++++++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
+++++++++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
++++++++++ +        
++++++++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
++++++++++-         self.ts.setup()
+++++++++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
+++++++++++             TL.red_yellow_green_state])
++++++++++ +        
++++++++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
++++++++++-         success = self.init_vehicles()
+++++++++++         subscribes.veh = SubscribeDef(tc.vehicle, [
+++++++++++             V.road_id, V.lane_index, V.laneposition,
+++++++++++             V.speed, V.position, V.angle,
+++++++++++             V.fuelconsumption, V.noxemission])
++++++++++ +        
++++++++++-+        # Return whether the SUMO reset and vehicle initialization were successful
++++++++++-         return success
+++++++++++         for tl_id in self.traffic_lights.keys():
+++++++++++             subscribes.tl.subscribe(tl_id)
++++++++++  
++++++++++-+    # Method to initialize the environment after SUMO reset
++++++++++-     def init_env(self):
++++++++++-+        # Reference to the traffic state
++++++++++-         ts = self.ts
++++++++++-+    
++++++++++-+        # Create an empty data structure to store rollout information
++++++++++-         self.rollout_info = NamedArrays()
++++++++++-+        
++++++++++-+        # Turn off all traffic lights in the network
++++++++++-         for tl in ts.traffic_lights:
++++++++++--            ts.set_program(tl, 'off')
++++++++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
++++++++++-+        
++++++++++-+        # Reset the step counter to 0
++++++++++-         self._step = 0
++++++++++-+        
++++++++++-+        # Take the first step in the simulation
++++++++++-         ret = self.step()
++++++++++-+        
++++++++++-+        # Run the simulation for a number of warmup steps
++++++++++-         for _ in range(self.c.warmup_steps):
++++++++++--            ret = self.step()
++++++++++-+            ret = self.step()  # Advance the simulation one step
++++++++++-+            
++++++++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
++++++++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
++++++++++-                 return None
++++++++++-+        
++++++++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
++++++++++-         for tl in ts.traffic_lights:
++++++++++--            ts.set_program(tl, '1')
++++++++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
++++++++++-+        
++++++++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
++++++++++-         if isinstance(ret, tuple):
++++++++++--            return ret[0]
++++++++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
++++++++++--
++++++++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
++++++++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
++++++++++-+        
++++++++++-+    # Reset the entire environment, retrying until successful
++++++++++-     def reset(self):
++++++++++--        while True:
++++++++++-+        self.mean_speed = 0
++++++++++-+        while True:  # Infinite loop until the environment is successfully reset
++++++++++-+            # Attempt to reset the SUMO simulation
++++++++++-             if not self.reset_sumo():
++++++++++--                continue
++++++++++-+                continue  # If reset_sumo fails, retry the loop
++++++++++-+            
++++++++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++++++++-             if (obs := self.init_env()) is not None:
++++++++++--                return obs
++++++++++-+                return obs  # Successfully initialized, return the observation
+++++++++++@@ -1148,6 +1151,7 @@ class Env:
+++++++++++             self.ts.reset(self.tc)
+++++++++++         
+++++++++++         # Set up the traffic state (e.g., initialize the simulation settings)
++++++++++ +
++++++++++- 
++++++++++-     def append_step_info(self):
++++++++++-         """
++++++++++-@@ -1231,6 +1297,8 @@ class Env:
++++++++++- class NormEnv(gym.Env):
++++++++++-     """
++++++++++-     Reward normalization with running average https://github.com/joschu/modular_rl
++++++++++-+    self.c: Ring parameters 
++++++++++-+    self.env: RingEnv class
++++++++++-     """
++++++++++-     def __init__(self, c, env):
++++++++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
+++++++++++         self.ts.setup()
+++++++++++         
+++++++++++         # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
++++++++++ diff --git a/exp.py b/exp.py
++++++++++-index ead4652..7f7cee5 100644
+++++++++++index 7f7cee5..e6a53c6 100644
++++++++++ --- a/exp.py
++++++++++ +++ b/exp.py
++++++++++-@@ -169,9 +169,9 @@ class Main(Config):
++++++++++- 
++++++++++-     def on_train_start(c):
++++++++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
++++++++++--        c.setdefaults(alg='Algorithm')
++++++++++--        c._env = c.create_env()
++++++++++--
++++++++++-+        c.setdefaults(alg='Algorithm') 
+++++++++++@@ -408,7 +408,6 @@ class Main(Config):
+++++++++++         # Main training loop
+++++++++++         c.on_train_start()
+++++++++++         while c._i < c.n_steps:
+++++++++++-            c.on_step_start() # save stat 
+++++++++++             with torch.no_grad():
+++++++++++                 # Collect rollouts without computing gradients
+++++++++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++++++++@@ -497,3 +496,29 @@ class Main(Config):
+++++++++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
+++++++++++             c.train()
+++++++++++         c.log('job done!')
++++++++++++
++++++++++++    def run_2(c):
++++++++++++        # Determine whether to train or evaluate based on configuration
++++++++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
++++++++++ +        c._env = c.create_env() # Create NormEnv
++++++++++-+ 
++++++++++-         # Instantiate the algorithm (e.g., PPO, DQN)
++++++++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
++++++++++-         c.set_model()
++++++++++-@@ -222,8 +222,8 @@ class Main(Config):
++++++++++- 
++++++++++-     def on_step_start(c, stats={}):
++++++++++-         # Update the learning rate and log stats at the start of a training step
++++++++++--        lr = c._lr
++++++++++--        for g in c._opt.param_groups:
++++++++++-+        lr = c._lr # Update Learning Rate
++++++++++-+        for g in c._opt.param_groups: # Log Statistics
++++++++++-             g['lr'] = float(lr)
++++++++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
++++++++++- 
++++++++++-@@ -285,10 +285,14 @@ class Main(Config):
++++++++++-             ret = dict(obs=ret)
++++++++++-         rollout = NamedArrays()
++++++++++-         rollout.append(**ret)
++++++++++--
++++++++++-+        rollout_flow_each_step = []
++++++++++-         done = False
++++++++++-         a_space = c.action_space
++++++++++-         step = 0
++++++++++++        ret = c._env.reset()
++++++++++++        step = 0
++++++++++ +        density = 20/(250*1e-3)
++++++++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
++++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++++++++++-+
++++++++++-         while step < c.horizon + c.skip_stat_steps and not done:
++++++++++-             # Generate an action from the model's policy
++++++++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
++++++++++-@@ -309,6 +313,12 @@ class Main(Config):
++++++++++-             rollout.append(**ret)
++++++++++-             step += 1
++++++++++-         # Collect stats from the environment
++++++++++++        done = False
++++++++++++        while step < c.horizon + c.skip_stat_steps and not done:
++++++++++++            # Take a step in the environment
++++++++++++            ret = c._env.step()
++++++++++++            if isinstance(ret, tuple):
++++++++++++                obs, reward, done, info = ret
++++++++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
++++++++++++            done = ret.setdefault('done', False)
++++++++++++            step += 1
++++++++++++        # Collect stats from the environment
++++++++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++++++++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++++++++++ +        density = 20/(250 * 1e-3)
++++++++++ +        vehicle_flow = c._env.mean_speed * density 
++++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++++++++++-+
++++++++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
++++++++++-         return rollout, stats
++++++++++- 
++++++++++-@@ -398,10 +408,10 @@ class Main(Config):
++++++++++-         # Main training loop
++++++++++-         c.on_train_start()
++++++++++-         while c._i < c.n_steps:
++++++++++--            c.on_step_start()
++++++++++-+            c.on_step_start() # save stat 
++++++++++-             with torch.no_grad():
++++++++++-                 # Collect rollouts without computing gradients
++++++++++--                rollouts = c.rollouts()
++++++++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++++++-             gd_stats = {}
++++++++++-             if len(rollouts.obs):
++++++++++-                 t_start = time()
++++++++++-@@ -410,7 +420,7 @@ class Main(Config):
++++++++++-                 gd_stats.update(gd_time=time() - t_start)
++++++++++-             c.on_step_end(gd_stats)
++++++++++-             c._i += 1
++++++++++--        c.on_step_start()  # last step
++++++++++-+        c.on_step_start()  # save stat
++++++++++-         gd_stats = {}
++++++++++-         with torch.no_grad():
++++++++++-             rollouts = c.rollouts()
++++++++++-@@ -450,6 +460,8 @@ class Main(Config):
++++++++++-         if hasattr(c._env, 'close'):
++++++++++-             c._env.close()
++++++++++- 
++++++++++-+  
++++++++++-+
++++++++++-     def run(c):
++++++++++-         # Determine whether to train or evaluate based on configuration
++++++++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++++++-diff --git a/ring.py b/ring.py
++++++++++-index 94d632d..ee1372b 100644
++++++++++---- a/ring.py
++++++++++-+++ b/ring.py
++++++++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
++++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++++++-         )
+++++++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
+++++++++++deleted file mode 100644
+++++++++++index 6b9ba52..0000000
+++++++++++--- a/highway_bottleneck.py
++++++++++++++ /dev/null
+++++++++++@@ -1,381 +0,0 @@
+++++++++++-from automatic_vehicular_control.exp import *
+++++++++++-from automatic_vehicular_control.env import *
+++++++++++-from automatic_vehicular_control.u import *
++++++++++ -
++++++++++-         # Function to generate the shape of the edges (circular arcs)
++++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++++- 
++++++++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
++++++++++-         if c.circumference_range:  # Check if the circumference should be randomized
++++++++++-             # Randomly set the circumference within the specified range
++++++++++-             c.circumference = np.random.randint(*c.circumference_range)
++++++++++-+        
++++++++++-+        if self.flow_log:
++++++++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
++++++++++-+            self.episode_flow.append(average_flow)
++++++++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
++++++++++-+        
++++++++++-+        # Reset flow counters for the new episode
++++++++++-+        self.flow_counter = 0
++++++++++-+        self.flow_log = []
++++++++++-+        self.last_vehicle_times = {}
++++++++++-+        
++++++++++-         return super().reset_sumo()  # Reset the simulation
++++++++++- 
++++++++++-     @property
++++++++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
++++++++++-         }
++++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
++++++++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
++++++++++-         return stats
++++++++++--
++++++++++-+    
++++++++++-+    def calculate_flow(self):
++++++++++-+        """
++++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++++++-+        """
++++++++++-+        current_time = self.ts.time
++++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++++++-+
++++++++++-+        for vehicle in vehicles_on_edge:
++++++++++-+            # Check if vehicle has passed the observation point since the last timestep
++++++++++-+            if vehicle.id not in self.last_vehicle_times:
++++++++++-+                # If the vehicle was not previously recorded, count it as a new passage
++++++++++-+                self.flow_counter += 1
++++++++++-+            else:
++++++++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
++++++++++-+                last_time = self.last_vehicle_times[vehicle.id]
++++++++++-+                if current_time - last_time > self.c.sim_step:
++++++++++-+                    self.flow_counter += 1
++++++++++-+
++++++++++-+            # Update the last time the vehicle passed the point
++++++++++-+            self.last_vehicle_times[vehicle.id] = current_time
++++++++++-+
++++++++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
++++++++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
++++++++++-+        self.flow_log.append(flow_per_hour)
++++++++++-+        return flow_per_hour
++++++++++-+    
++++++++++-     def step(self, action=None):
++++++++++-         c = self.c  # Configuration object
++++++++++-         ts = self.ts  # Time step object
++++++++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
++++++++++-                     # Change to a specific lane
++++++++++-                     ts.lane_change_to(rl, lc)
+++++++++++-class BNeckEnv(Env):
+++++++++++-    def def_sumo(self):
+++++++++++-        c = self.c
+++++++++++-        nodes = E('nodes',
+++++++++++-            E('node', id='n_0', x=0, y=0), *(
+++++++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
+++++++++++-        ))
+++++++++++-        edges = E('edges', *(
+++++++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
+++++++++++-                'numLanes': n_lane,
+++++++++++-                'speed': c.max_speed
+++++++++++-            }) for i, n_lane in enumerate(c.n_lanes)
+++++++++++-        ))
+++++++++++-        connections = E('connections', *(
+++++++++++-            E('connection', **{
+++++++++++-                'from': prev.id,
+++++++++++-                'to': curr.id,
+++++++++++-                'fromLane': i,
+++++++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
+++++++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
+++++++++++-        ))
+++++++++++-
+++++++++++-        if c.split_flow:
+++++++++++-            n_inflow_lanes = c.n_lanes[0]
+++++++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
+++++++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
+++++++++++-                for i in range(n_inflow_lanes)
+++++++++++-            ]
+++++++++++-        else:
+++++++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
+++++++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
+++++++++++-            ]
+++++++++++-        routes = E('routes',
+++++++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
+++++++++++-            *flows
+++++++++++-        )
+++++++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
+++++++++++-        additional = E('additional',
+++++++++++-            E('vType', id='generic', **idm_params),
+++++++++++-            E('vType', id='rl', **idm_params),
+++++++++++-            E('vType', id='human', **idm_params),
+++++++++++-        )
+++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++++++-
+++++++++++-    def reset_sumo(self):
+++++++++++-        c = self.c
+++++++++++-        if c.flow_rate_range:
+++++++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
+++++++++++-        ret = super().reset_sumo()
+++++++++++-        if c.vinitsky:
+++++++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
+++++++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
+++++++++++-                for i_start in range(round(edge.length) // c.piece_length)
+++++++++++-                for lane in edge.lanes
+++++++++++-            ]
+++++++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
+++++++++++-            self.last_outflows = []
+++++++++++-        return ret
+++++++++++-
+++++++++++-    def step(self, action=[]):
+++++++++++-        c = self.c
+++++++++++-        ts = self.ts
+++++++++++-        max_dist = 100
+++++++++++-        max_speed = c.max_speed
+++++++++++-        human_type = ts.types.human
+++++++++++-        rl_type = ts.types.rl
+++++++++++-
+++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++++-        if c.vinitsky:
+++++++++++-            if len(action):
+++++++++++-                assert len(action) == len(self.control_lanes)
+++++++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
+++++++++++-                    self.control_lanes[lane, piece_start] = np.clip(
+++++++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
+++++++++++-                        0.1, max_speed
+++++++++++-                    )
+++++++++++-                for veh in prev_rls:
+++++++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
+++++++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
+++++++++++-        else:
+++++++++++-            for veh, act in zip(prev_rls, action):
+++++++++++-                if c.handcraft:
+++++++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
+++++++++++-                    next_lane = lane.next(veh.route)
+++++++++++-                    level = 1
+++++++++++-                    if next_lane and next_lane.get('junction'):
+++++++++++-                        merge_dist = lane.length - veh.laneposition
+++++++++++-                        if merge_dist < c.handcraft:
+++++++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
+++++++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
+++++++++++-                                level = 0
+++++++++++-                    if c.act_type.startswith('accel'):
+++++++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++-                    else:
+++++++++++-                        ts.set_max_speed(veh, max_speed * level)
+++++++++++-                    continue
+++++++++++-                if not isinstance(act, (int, np.integer)):
+++++++++++-                    act = (act - c.low) / (1 - c.low)
+++++++++++-                if c.act_type.startswith('accel'):
+++++++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++-                else:
+++++++++++-                    if c.act_type == 'continuous':
+++++++++++-                        level = act[0]
+++++++++++-                    elif c.act_type == 'discretize':
+++++++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++++++-                    elif c.act_type == 'discrete':
+++++++++++-                        level = act / (c.n_actions - 1)
+++++++++++-                    ts.set_max_speed(veh, max_speed * level)
+++++++++++-
+++++++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
+++++++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
+++++++++++-
+++++++++++-        super().step()
+++++++++++-
+++++++++++-        if c.vinitsky:
+++++++++++-            n_last_outflows = 20
+++++++++++-            max_vehs = 4
+++++++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
+++++++++++-            obs = []
+++++++++++-            for lane, piece_start in self.obs_lanes:
+++++++++++-                piece_end = piece_start + c.piece_length
+++++++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
+++++++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
+++++++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
+++++++++++-                obs.extend([
+++++++++++-                    len(lane_humans) / max_vehs,
+++++++++++-                    len(lane_avs) / max_vehs,
+++++++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
+++++++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
+++++++++++-                ])
+++++++++++-            if len(self.last_outflows) == n_last_outflows:
+++++++++++-                self.last_outflows = self.last_outflows[1:]
+++++++++++-            self.last_outflows.append(len(ts.new_arrived))
+++++++++++-            reward = np.mean(self.last_outflows)
+++++++++++-            obs.append(reward / max_veh_outflows)
+++++++++++-            obs = np.array(obs, dtype=np.float32)
+++++++++++-            assert 0 <= obs.min() and obs.max() <= 1
+++++++++++-            return obs, reward, False, None
+++++++++++-        route = nexti(ts.routes)
+++++++++++-        obs, ids = [], []
+++++++++++-        default_close = [0, max_speed]
+++++++++++-        default_far = [max_dist, 0]
+++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++++++-            merge_dist = max_dist
+++++++++++-            default_human = default_far
+++++++++++-
+++++++++++-            other_info = {}
+++++++++++-            next_lane = lane.next(veh.route)
+++++++++++-            if next_lane and next_lane.get('junction'):
+++++++++++-                merge_dist = lane.length - veh.laneposition
+++++++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
+++++++++++-                # Look for veh on other lane but do not extend past that lane
+++++++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
+++++++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
+++++++++++-                    if other_veh.type is rl_type:
+++++++++++-                        default_human = default_close
+++++++++++-                        break
+++++++++++-
+++++++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
+++++++++++-            ids.append(veh.id)
+++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
+++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++++-        
+++++++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++++-
+++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++++-
+++++++++++-        raw_pet = self.calc_pet()
+++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++++-        pet = np.clip(pet, -1, 1)
+++++++++++-
+++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++++-        
+++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++++-        return returned
+++++++++++-        
+++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++++-    
+++++++++++-    def calc_ttc(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        ttcs = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            leader, headway = v.leader()
+++++++++++-            v_speed = v.speed
+++++++++++-            leader_speed = leader.speed
+++++++++++-            if leader_speed < v_speed:
+++++++++++-                ttc =  headway/(v_speed-leader_speed)
+++++++++++-            else:
+++++++++++-                ttc = np.nan
+++++++++++-            ttcs.append(ttc)
+++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++++-        return fleet_ttc
+++++++++++-    
+++++++++++-    def calc_drac(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        dracs = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            leader, headway = v.leader()
+++++++++++-            v_speed = v.speed
+++++++++++-            leader_speed = leader.speed
+++++++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++++-            dracs.append(drac)
+++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++++-        return fleet_drac
+++++++++++-
+++++++++++-    def calc_pet(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        pets = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            leader, headway = v.leader()
+++++++++++-            v_speed = v.speed
+++++++++++-            if v_speed > 1e-16:
+++++++++++-                pet = headway/(v_speed)
+++++++++++-                pets.append(pet)
+++++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++++-        return fleet_pet
+++++++++++-
+++++++++++-class BNeck(Main):
+++++++++++-    def create_env(c):
+++++++++++-        return BNeckEnv(c)
+++++++++++-
+++++++++++-    @property
+++++++++++-    def observation_space(c):
+++++++++++-        low = np.full(c._n_obs, c.low)
+++++++++++-        return Box(low, np.ones_like(low))
+++++++++++-
+++++++++++-    @property
+++++++++++-    def action_space(c):
+++++++++++-        if c.vinitsky:
+++++++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
+++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++++++-            assert c.lc_av in [False, 'binary']
+++++++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
+++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++++++-            return Discrete(c.n_actions)
+++++++++++-
+++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++++-        if c.vinitsky:
+++++++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
+++++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++++-        step_obs_ = rollout.obs
+++++++++++-        step_obs = step_obs_[:-1]
+++++++++++-
+++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++++-
+++++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++++-
+++++++++++-        step_id_ = rollout.pop('id')
+++++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++++-        id_unique = np.unique(id)
+++++++++++-
+++++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++++-
+++++++++++-        log(**stats)
+++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++++-        log(
+++++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++++-            n_veh_unique=len(id_unique),
+++++++++++-            
+++++++++++-            reward_mean=np.mean(reward),
+++++++++++-            reward_std=np.std(reward),        
+++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++-
+++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++++-            )
+++++++++++-        return rollout
+++++++++++-
+++++++++++-if __name__ == '__main__':
+++++++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
+++++++++++-        warmup_steps=1000,
+++++++++++-        horizon=2000,
+++++++++++-        n_steps=100,
+++++++++++-        step_save=5,
+++++++++++-
+++++++++++-        av_frac=0.2,
+++++++++++-        sim_step=0.5,
+++++++++++-        depart_speed=0,
+++++++++++-        edge_lengths=[100, 100, 50],
+++++++++++-        n_lanes=[4, 2, 1],
+++++++++++-        max_speed=30,
+++++++++++-
+++++++++++-        lc_av=False,
+++++++++++-        flow_rate=2300,
+++++++++++-        flow_rate_range=None,
+++++++++++-        split_flow=True,
+++++++++++-        generic_type='rand',
+++++++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++++++-        lc_mode=LC_MODE.off,
+++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++++-
+++++++++++-        veh_junction=False,
+++++++++++-        act_type='accel_discrete',
+++++++++++-        max_accel=2.6,
+++++++++++-        max_decel=4.5,
+++++++++++-        tau=1.0,
+++++++++++-        min_gap=2.5,
+++++++++++-        delta=4,
+++++++++++-        n_actions=3,
+++++++++++-        low=-1,
+++++++++++-        handcraft=False,
+++++++++++-        vinitsky=False,
+++++++++++-
+++++++++++-        render=False,
+++++++++++-
+++++++++++-        alg=PG,
+++++++++++-        lr=1e-3,
+++++++++++-
+++++++++++-        gamma=0.99,
+++++++++++-        adv_norm=False,
+++++++++++-        batch_concat=True,
+++++++++++-
+++++++++++-        beta=0,
+++++++++++-        scale_ttc=1,
+++++++++++-        scale_drac=1,
+++++++++++-        seed_np=False,
+++++++++++-        seed_torch = False,
+++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++++-
+++++++++++-    )
+++++++++++-    
+++++++++++-    if c.seed_torch:
+++++++++++-        # Set seed for PyTorch CPU operations
+++++++++++-        torch.manual_seed(c.seed_torch)
+++++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++++-        if torch.cuda.is_available():
+++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++++-    if c.seed_np:
+++++++++++-        np.random.seed(c.seed_np)
+++++++++++-        
+++++++++++-    if c.vinitsky:
+++++++++++-        c.piece_length = 20
+++++++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
+++++++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
+++++++++++-        c._n_action = sum(n_actions[:-1])
+++++++++++-        c._n_obs = sum(n_actions) * 4 + 1
+++++++++++-        c.batch_concat = False
+++++++++++-    else:
+++++++++++-        c._n_obs = 2 + 2 + 2
+++++++++++-        
+++++++++++-    if c.mrtl:
+++++++++++-        c._n_obs += 1 # modified for mrtl related
+++++++++++-        
+++++++++++-    c.redef_sumo = bool(c.flow_rate_range)
+++++++++++-    c.run()
+++++++++++\ No newline at end of file
+++++++++++diff --git a/highway_ramp.py b/highway_ramp.py
+++++++++++deleted file mode 100644
+++++++++++index ef0358f..0000000
+++++++++++--- a/highway_ramp.py
++++++++++++++ /dev/null
+++++++++++@@ -1,325 +0,0 @@
+++++++++++-from automatic_vehicular_control.exp import *
+++++++++++-from automatic_vehicular_control.env import *
+++++++++++-from automatic_vehicular_control.u import *
+++++++++++-
+++++++++++-class RampEnv(Env):
+++++++++++-    # https://flow-project.github.io/papers/08569485.pdf
+++++++++++-    def def_sumo(self):
+++++++++++-        c = self.c
+++++++++++-        builder = NetBuilder()
+++++++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
+++++++++++-            (0, 0),
+++++++++++-            (c.premerge_distance, 0),
+++++++++++-            (c.premerge_distance + c.merge_distance, 0),
+++++++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
+++++++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
+++++++++++-        ])
+++++++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
+++++++++++-            {}, {'numLanes': 2}, {}
+++++++++++-        ], lane_maps=[
+++++++++++-            {0: 1}, {0: 0, 1: 0}
+++++++++++-        ], route_id='highway')
+++++++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
+++++++++++-            {}, {'numLanes': 2}, {}
+++++++++++-        ], lane_maps=[
+++++++++++-            {0: 0}, {0: 0, 1: 0}
+++++++++++-        ], route_id='ramp')
+++++++++++-        nodes, edges, connections, routes = builder.build()
+++++++++++-        nodes[2].type = 'zipper'
+++++++++++-
+++++++++++-        routes = E('routes',
+++++++++++-            *routes,
+++++++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
+++++++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
+++++++++++-        )
+++++++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
+++++++++++-        additional = E('additional',
+++++++++++-            E('vType', id='generic', **idm),
+++++++++++-            E('vType', id='rl', **idm),
+++++++++++-            E('vType', id='human', **idm),
+++++++++++-        )
+++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++++++-
+++++++++++-    def step(self, action=[]):
+++++++++++-        c = self.c
+++++++++++-        ts = self.ts
+++++++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
+++++++++++-        max_speed = c.max_speed
+++++++++++-        human_type = ts.types.human
+++++++++++-        rl_type = ts.types.rl
+++++++++++-
+++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++++-        for rl, act in zip(prev_rls, action):
+++++++++++-            if c.handcraft:
+++++++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
+++++++++++-                leader, dist = rl.leader()
+++++++++++-                level = 1
+++++++++++-                if edge.id == 'e_n_0.0_n_400.0':
+++++++++++-                    if rl.laneposition < 100:
+++++++++++-                        leaders = list(rl.leaders())
+++++++++++-                        if len(leaders) > 20:
+++++++++++-                            level = 0
+++++++++++-                        else:
+++++++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+++++++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++-                continue
+++++++++++-            if not isinstance(act, (int, np.integer)):
+++++++++++-                act = (act - c.low) / (1 - c.low)
+++++++++++-            if c.act_type.startswith('accel'):
+++++++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++-            else:
+++++++++++-                if c.act_type == 'continuous':
+++++++++++-                    level = act[0]
+++++++++++-                elif c.act_type == 'discretize':
+++++++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++++++-                elif c.act_type == 'discrete':
+++++++++++-                    level = act / (c.n_actions - 1)
+++++++++++-                ts.set_max_speed(rl, max_speed * level)
+++++++++++-
+++++++++++-        super().step()
+++++++++++-
+++++++++++-        route = ts.routes.highway
+++++++++++-        obs, ids = [], []
+++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++++++-            if hasattr(veh, 'edge'):
+++++++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++++++-                merge_dist = max_dist
+++++++++++-
+++++++++++-                lead_speed = follow_speed = other_speed = 0
+++++++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
+++++++++++-
+++++++++++-                leader, dist = veh.leader()
+++++++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
+++++++++++-
+++++++++++-                follower, dist = veh.follower()
+++++++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
+++++++++++-
+++++++++++-                if c.global_obs:
+++++++++++-                    jun_edge = edge.next(route)
+++++++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
+++++++++++-                        jun_edge = jun_edge.next(route)
+++++++++++-                    if jun_edge:
+++++++++++-                        merge_dist = lane.length - veh.laneposition
+++++++++++-                        next_edge = edge.next(route)
+++++++++++-                        while next_edge is not jun_edge:
+++++++++++-                            merge_dist += next_edge.length
+++++++++++-                            next_edge = next_edge.next(route)
+++++++++++-
+++++++++++-                        other_lane = jun_edge.lanes[0]
+++++++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
+++++++++++-                            other_speed = other_veh.speed
+++++++++++-                            break
+++++++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
+++++++++++-                else:
+++++++++++-                    next_lane = lane.next(route)
+++++++++++-                    if next_lane and next_lane.get('junction'):
+++++++++++-                        if len(edge.lanes) == 2:
+++++++++++-                            other_lane = edge.lanes[0]
+++++++++++-                            pos = veh.laneposition
+++++++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
+++++++++++-                                other_speed = other_veh.speed
+++++++++++-                                break
+++++++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
+++++++++++-                ids.append(veh.id)
+++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
+++++++++++-        if c.mrtl:
+++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++++-        
+++++++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++++-
+++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++++-
+++++++++++-        raw_pet = self.calc_pet()
+++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++++-        pet = np.clip(pet, -1, 1)
+++++++++++-
+++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++++-        
+++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++++-        return returned
+++++++++++-        
+++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++++-    
+++++++++++-    def calc_ttc(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        ttcs = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            if hasattr(v, 'edge'):
+++++++++++-                leader, headway = v.leader()
+++++++++++-                if leader:
+++++++++++-                    v_speed = v.speed
+++++++++++-                    leader_speed = leader.speed
+++++++++++-                    if leader_speed < v_speed:
+++++++++++-                        ttc =  headway/(v_speed-leader_speed)
+++++++++++-                    else:
+++++++++++-                        ttc = np.nan
+++++++++++-                    ttcs.append(ttc)
+++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++++-        return fleet_ttc
+++++++++++-    
+++++++++++-    def calc_drac(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        dracs = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            if hasattr(v, 'edge'):
+++++++++++-                leader, headway = v.leader()
+++++++++++-                if leader:
+++++++++++-                    v_speed = v.speed
+++++++++++-                    leader_speed = leader.speed
+++++++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++++-                    dracs.append(drac)
+++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++++-        return fleet_drac
+++++++++++-
+++++++++++-    def calc_pet(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        pets = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            if hasattr(v, 'edge'):
+++++++++++-                leader, headway = v.leader()
+++++++++++-                if leader:
+++++++++++-                    v_speed = v.speed
+++++++++++-                    if v_speed > 1e-16:
+++++++++++-                        pet = headway/(v_speed)
+++++++++++-                        pets.append(pet)
+++++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
+++++++++++-        return fleet_pet
+++++++++++-
+++++++++++-class Ramp(Main):
+++++++++++-    def create_env(c):
+++++++++++-        return RampEnv(c)
+++++++++++-
+++++++++++-    @property
+++++++++++-    def observation_space(c):
+++++++++++-        low = np.full(c._n_obs, c.low)
+++++++++++-        return Box(low, np.ones_like(low))
+++++++++++-
+++++++++++-    @property
+++++++++++-    def action_space(c):
+++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++++++-            return Discrete(c.n_actions)
+++++++++++-
+++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++++-        step_obs_ = rollout.obs
+++++++++++-        step_obs = step_obs_[:-1]
+++++++++++-
+++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++++-
+++++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++++-
+++++++++++-        step_id_ = rollout.pop('id')
+++++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++++-        id_unique = np.unique(id)
+++++++++++-
+++++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++++-
+++++++++++-        log(**stats)
+++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++++-        log(
+++++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++++-            n_veh_unique=len(id_unique),
+++++++++++-            
+++++++++++-            reward_mean=np.mean(reward),
+++++++++++-            reward_std=np.std(reward),        
+++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++-
+++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++++-            )
+++++++++++-        return rollout
+++++++++++-
+++++++++++-if __name__ == '__main__':
+++++++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
+++++++++++-        warmup_steps=100,
+++++++++++-        horizon=2000,
+++++++++++-        n_steps=100,
+++++++++++-        step_save=5,
+++++++++++-
+++++++++++-        premerge_distance=400,
+++++++++++-        merge_distance=100,
+++++++++++-        postmerge_distance=30,
+++++++++++-        av_frac=0.1,
+++++++++++-        sim_step=0.5,
+++++++++++-        max_speed=30,
+++++++++++-        highway_depart_speed=10,
+++++++++++-        ramp_depart_speed=0,
+++++++++++-        highway_flow_rate=2000,
+++++++++++-        ramp_flow_rate=300,
+++++++++++-        global_obs=False,
+++++++++++-        handcraft=False,
+++++++++++-
+++++++++++-        generic_type='default',
+++++++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++++-
+++++++++++-        act_type='accel_discrete',
+++++++++++-        max_accel=1,
+++++++++++-        max_decel=1.5,
+++++++++++-        n_actions=3,
+++++++++++-        low=-1,
+++++++++++-
+++++++++++-        render=False,
+++++++++++-
+++++++++++-        alg=PG,
+++++++++++-        lr=1e-3,
+++++++++++-
+++++++++++-        gamma=0.99,
+++++++++++-        adv_norm=False,
+++++++++++-        batch_concat=True,
+++++++++++-
+++++++++++-        beta=0,
+++++++++++-        scale_ttc=1,
+++++++++++-        scale_drac=1,
+++++++++++-        seed_np=False,
+++++++++++-        seed_torch = False,
+++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++++-
+++++++++++-    )
+++++++++++-    
+++++++++++-    if c.seed_torch:
+++++++++++-        # Set seed for PyTorch CPU operations
+++++++++++-        torch.manual_seed(c.seed_torch)
+++++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++++-        if torch.cuda.is_available():
+++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++++-    if c.seed_np:
+++++++++++-        np.random.seed(c.seed_np)
+++++++++++-        
+++++++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
+++++++++++-    if c.mrtl:
+++++++++++-        c._n_obs += 1 # modified for mrtl related
+++++++++++-    c.run()
+++++++++++\ No newline at end of file
+++++++++++diff --git a/intersection.py b/intersection.py
+++++++++++deleted file mode 100644
+++++++++++index e38a84f..0000000
+++++++++++--- a/intersection.py
++++++++++++++ /dev/null
+++++++++++@@ -1,489 +0,0 @@
+++++++++++-from automatic_vehicular_control.u import *
+++++++++++-from automatic_vehicular_control.exp import *
+++++++++++-from automatic_vehicular_control.env import *
+++++++++++-
+++++++++++-class Platoon(Entity):
+++++++++++-    pass
+++++++++++-
+++++++++++-class IntersectionEnv(Env):
+++++++++++-    def def_sumo(self):
+++++++++++-        c = self.c
+++++++++++-
+++++++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
+++++++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
+++++++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
+++++++++++-        ] if params.get('vehsPerHour')]
+++++++++++-
+++++++++++-        builder = NetBuilder()
+++++++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
+++++++++++-        if c.enter_length:
+++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++++++-            xys[1:, :, 0] += c.enter_length - c.length
+++++++++++-            xys[:, 1:, 1] += c.enter_length - c.length
+++++++++++-            xys = xys.reshape(-1, 2)
+++++++++++-        if c.short_exit:
+++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++++++-            xys[-1, :, 0] += c.short_exit - c.length
+++++++++++-            xys[:, -1, 1] += c.short_exit - c.length
+++++++++++-            xys = xys.reshape(-1, 2)
+++++++++++-        nodes = builder.add_nodes(
+++++++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
+++++++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
+++++++++++-        # import pdb; pdb.set_trace()
+++++++++++-
+++++++++++-        tl = c.setdefault('tl', False)
+++++++++++-        if tl:
+++++++++++-            c.av_frac = 0
+++++++++++-            c.pop('av_range', None)
+++++++++++-            c.speed_mode = SPEED_MODE.all_checks
+++++++++++-
+++++++++++-        flows = []
+++++++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
+++++++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
+++++++++++-        for direction in c.directions:
+++++++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
+++++++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
+++++++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
+++++++++++-
+++++++++++-            edge_attrs = dict(priority=int(direction in priority))
+++++++++++-            if c.get('set_edge_speed', True):
+++++++++++-                edge_attrs['speed'] = c.max_speed
+++++++++++-
+++++++++++-            for i, chain in enumerate(chains[1:-1]):
+++++++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
+++++++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
+++++++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
+++++++++++-
+++++++++++-        tls = []
+++++++++++-        if tl:
+++++++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
+++++++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
+++++++++++-            tl_offset = c.get('tl_offset', 'auto')
+++++++++++-            yellow = c.get('yellow', 0.5)
+++++++++++-            if tl_offset == 'auto':
+++++++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
+++++++++++-            elif tl_offset == 'same':
+++++++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
+++++++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
+++++++++++-                node.type = 'traffic_light'
+++++++++++-                phase_multiple = len(c.directions) // 2
+++++++++++-                tls.append(E('tlLogic',
+++++++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
+++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
+++++++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
+++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
+++++++++++-                id=node.id, offset=offset, type='static', programID='1'))
+++++++++++-
+++++++++++-        nodes, edges, connections, routes = builder.build()
+++++++++++-        additional = E('additional', *types, *routes, *flows, *tls)
+++++++++++-        return super().def_sumo(nodes, edges, connections, additional)
+++++++++++-
+++++++++++-    def build_platoon(self):
+++++++++++-        ts = self.ts
+++++++++++-        rl_type = ts.types.rl
+++++++++++-        for route in ts.routes:
+++++++++++-            vehs = []
+++++++++++-            route_offset = 0
+++++++++++-            for edge in route.edges:
+++++++++++-                for veh in edge.vehicles:
+++++++++++-                    veh.route_position = route_offset + veh.laneposition
+++++++++++-                    vehs.append(veh)
+++++++++++-                route_offset += edge.length
+++++++++++-
+++++++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
+++++++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
+++++++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
+++++++++++-            rl_idxs, = rl_mask.nonzero()
+++++++++++-            split_idxs = 1 + rl_idxs
+++++++++++-
+++++++++++-            prev = None
+++++++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
+++++++++++-                if not len(vehs_i):
+++++++++++-                    continue # Last vehicle is RL, so the last split is empty
+++++++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
+++++++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
+++++++++++-                )
+++++++++++-                if prev is not None:
+++++++++++-                    prev.next = platoon
+++++++++++-                prev = platoon
+++++++++++-                for veh in vehs_i:
+++++++++++-                    veh.platoon = platoon
+++++++++++-            if prev is not None:
+++++++++++-                prev.next = None
+++++++++++-
+++++++++++-    def reset(self):
+++++++++++-        c = self.c
+++++++++++-        if c.e is False:
+++++++++++-            if 'length_range' in c:
+++++++++++-                min_, max_ = c.length_range
+++++++++++-                c.setdefaults(max_length=max_)
+++++++++++-                c.length = np.random.randint(min_, max_ + 1)
+++++++++++-            if 'av_range' in c:
+++++++++++-                min_, max_ = c.av_range
+++++++++++-                c.av_frac = np.random.uniform(min_, max_)
+++++++++++-        self.mp_tlast = 0
+++++++++++-        while not self.reset_sumo():
+++++++++++-            pass
+++++++++++-        ret = super().init_env()
+++++++++++-        return ret
+++++++++++-
+++++++++++-    def step(self, action=[]):
+++++++++++-        c = self.c
+++++++++++-        ts = self.ts
+++++++++++-        max_dist = c.max_dist
+++++++++++-        depart_speed = c.depart_speed
+++++++++++-        max_speed = c.max_speed
+++++++++++-
+++++++++++-        rl_type = ts.types.rl
+++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++++-
+++++++++++-        for rl, act in zip(prev_rls, action):
+++++++++++-            if c.handcraft or c.handcraft_tl:
+++++++++++-                route, lane = rl.route, rl.lane
+++++++++++-                junction = lane.next_junction
+++++++++++-                level = 1
+++++++++++-                if junction is not ts.sentinel_junction:
+++++++++++-                    dist = junction.route_position[route] - rl.route_position
+++++++++++-                    if c.handcraft:
+++++++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
+++++++++++-                    elif c.handcraft_tl and dist < 15:
+++++++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
+++++++++++-                        yellow_time = 0
+++++++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
+++++++++++-                        horizontal_go = 0 <= rem < t_h
+++++++++++-                        vertical_go = t_h + yellow_time <= rem
+++++++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
+++++++++++-                        human_remain = False
+++++++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
+++++++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
+++++++++++-            elif c.act_type == 'accel':
+++++++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
+++++++++++-            else:
+++++++++++-                level = act / (c.n_actions - 1)
+++++++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++-
+++++++++++-        if c.tl == 'MaxPressure':
+++++++++++-            self.mp_tlast += c.sim_step
+++++++++++-            tmin = c.get('mp_tmin', 0)
+++++++++++-            if self.mp_tlast >= tmin:
+++++++++++-                for tl in ts.traffic_lights:
+++++++++++-                    if ts.get_program(tl) == 'off':
+++++++++++-                        break
+++++++++++-                    jun = tl.junction
+++++++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
+++++++++++-
+++++++++++-                    total_pressures = []
+++++++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
+++++++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
+++++++++++-
+++++++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
+++++++++++-                self.mp_tlast = 0
+++++++++++-
+++++++++++-        super().step()
+++++++++++-        self.build_platoon()
+++++++++++-
+++++++++++-        obs = {}
+++++++++++-
+++++++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
+++++++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
+++++++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
+++++++++++-        for veh in rl_type.vehicles:
+++++++++++-            if hasattr(veh, 'lane'):
+++++++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
+++++++++++-                junction = lane.next_junction
+++++++++++-
+++++++++++-                head, tail = veh, platoon.tail
+++++++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
+++++++++++-
+++++++++++-                if junction is ts.sentinel_junction:
+++++++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
+++++++++++-                else:
+++++++++++-                    for jun_lane in lane.next_junction_lanes:
+++++++++++-                        # Defaults for jun_lane
+++++++++++-                        jun_headtails = vehs_default()
+++++++++++-
+++++++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
+++++++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
+++++++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
+++++++++++-
+++++++++++-                        if jun_veh:
+++++++++++-                            if jun_veh.type is rl_type:
+++++++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
+++++++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
+++++++++++-                                platoon = jun_veh.platoon.prev
+++++++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++++++-                                    if platoon is None: break
+++++++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++++++-                                    platoon = platoon.prev
+++++++++++-                            else:
+++++++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
+++++++++++-                                jun_headtails[0] = jun_veh.platoon.tail
+++++++++++-                                next_cross_platoon = jun_veh.platoon.prev
+++++++++++-                                if next_cross_platoon:
+++++++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
+++++++++++-                                    platoon = next_cross_platoon.prev
+++++++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++++++-                                        if platoon is None: break
+++++++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++++++-                                        platoon = platoon.prev
+++++++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
+++++++++++-
+++++++++++-                dist_features, speed_features = [], []
+++++++++++-                for route, vehs in route_vehs:
+++++++++++-                    j_pos = junction.route_position[route]
+++++++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
+++++++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
+++++++++++-
+++++++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++++-
+++++++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
+++++++++++-        ids = sorted(obs)
+++++++++++-        if c.mrtl:
+++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
+++++++++++-        if c.rew_type == 'outflow':
+++++++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++++-        elif c.rew_type == 'time_penalty':
+++++++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
+++++++++++-        
+++++++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++++-
+++++++++++-        raw_drac = self.calc_drac()
+++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++++-        raw_pet = self.calc_pet()
+++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++++-        pet = np.clip(pet/6, -1, 1)
+++++++++++-
+++++++++++-        raw_ttc = self.calc_ttc()
+++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++++-
+++++++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
+++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++++-
+++++++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++++-        return returned
+++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++++-        
+++++++++++-    def calc_drac(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        dracs = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            if hasattr(v, 'lane'):
+++++++++++-                leader, headway = v.leader()
+++++++++++-                v_speed = v.speed
+++++++++++-                leader_speed = leader.speed
+++++++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++++-                dracs.append(drac)
+++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++++-        return fleet_drac
+++++++++++-    
+++++++++++-    def calc_pet(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        pets = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            if hasattr(v, 'lane'):
+++++++++++-                leader, headway = v.leader()
+++++++++++-                v_speed = v.speed
+++++++++++-                if v_speed > 1e-16:
+++++++++++-                    pet = headway/(v_speed)
+++++++++++-                    pets.append(pet)
+++++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++++-        return fleet_pet
+++++++++++-
+++++++++++-    def calc_ttc(self):
+++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++-        ttcs = []
+++++++++++-        for v in cur_veh_list:
+++++++++++-            if hasattr(v, 'lane'):
+++++++++++-                leader, headway = v.leader()
+++++++++++-                v_speed = v.speed
+++++++++++-                leader_speed = leader.speed
+++++++++++-                if leader_speed < v_speed:
+++++++++++-                    ttc =  headway/(v_speed-leader_speed)
+++++++++++-                else:
+++++++++++-                    ttc = np.nan
+++++++++++-                ttcs.append(ttc)
+++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++++-        return fleet_ttc
+++++++++++-
+++++++++++-    def append_step_info(self):
+++++++++++-        super().append_step_info()
+++++++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
+++++++++++-
+++++++++++-    @property
+++++++++++-    def stats(self):
+++++++++++-        c = self.c
+++++++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
+++++++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
+++++++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
+++++++++++-        stats['backlog_step'] = mean(info['backlog'])
+++++++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
+++++++++++-
+++++++++++-        stats['beta'] = c.beta
+++++++++++-
+++++++++++-        if c.multi_flowrate:
+++++++++++-            stats['flow_horizontal'] = c.flow_rate_h
+++++++++++-            stats['flow_vertical'] = c.flow_rate_v
+++++++++++-        return stats
+++++++++++-
+++++++++++-class Intersection(Main):
+++++++++++-    def create_env(c):
+++++++++++-        if c.multi_flowrate:
+++++++++++-            return NormEnv(c, IntersectionEnv(c))
+++++++++++-        else:
+++++++++++-            c._norm = NormEnv(c, None)
+++++++++++-            return IntersectionEnv(c)
+++++++++++-
+++++++++++-    @property
+++++++++++-    def observation_space(c):
+++++++++++-        low = np.full(c._n_obs, c.low)
+++++++++++-        return Box(low, np.ones_like(low))
+++++++++++-
+++++++++++-    @property
+++++++++++-    def action_space(c):
+++++++++++-        if c.act_type == 'accel':
+++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++++++-        else:
+++++++++++-            return Discrete(c.n_actions)
+++++++++++-
+++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++++-        step_obs_ = rollout.obs
+++++++++++-        step_obs = step_obs_[:-1]
+++++++++++-
+++++++++++-        if not c.multi_flowrate:
+++++++++++-            rollout.raw_reward = rollout.reward
+++++++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
+++++++++++-
+++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++++-
+++++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++++-
+++++++++++-        step_id_ = rollout.pop('id')
+++++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++++-        id_unique = np.unique(id)
+++++++++++-
+++++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
+++++++++++-
+++++++++++-        log(**stats)
+++++++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
+++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++++-        log(
+++++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++++-            n_veh_unique=len(id_unique),
+++++++++++-            
+++++++++++-            reward_mean=np.mean(reward),
+++++++++++-            reward_std=np.std(reward),        
+++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++-
+++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++++-            )
+++++++++++-        
+++++++++++-        return rollout
+++++++++++-
+++++++++++-if __name__ == '__main__':
+++++++++++-    c = Intersection.from_args(globals(), locals())
+++++++++++-    c.setdefaults(
+++++++++++-        n_steps=200,
+++++++++++-        step_save=5,
+++++++++++-
+++++++++++-        depart_speed=0,
+++++++++++-        max_speed=13,
+++++++++++-        max_dist=100,
+++++++++++-        max_accel=1.5,
+++++++++++-        max_decel=3.5,
+++++++++++-        sim_step=0.5,
+++++++++++-        generic_type=True,
+++++++++++-        n_actions=3,
+++++++++++-
+++++++++++-        adv_norm=False,
+++++++++++-        batch_concat=True,
+++++++++++-
+++++++++++-        render=False,
+++++++++++-
+++++++++++-        warmup_steps=100,
+++++++++++-        horizon=2000,
+++++++++++-        directions='4way',
+++++++++++-        av_frac=0.15,
+++++++++++-        handcraft=False,
+++++++++++-        handcraft_tl=None,
+++++++++++-        flow_rate=700,
+++++++++++-        length=100,
+++++++++++-        n_rows=1,
+++++++++++-        n_cols=1,
+++++++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
+++++++++++-
+++++++++++-        act_type='accel_discrete',
+++++++++++-        low=-1,
+++++++++++-
+++++++++++-        alg=PG,
+++++++++++-        n_gds=1,
+++++++++++-        lr=1e-3,
+++++++++++-        gamma=0.99,
+++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++++-
+++++++++++-        enter_length=False,
+++++++++++-        short_exit=False,
+++++++++++-
+++++++++++-        rew_type='outflow',
+++++++++++-        norm_reward=True,
+++++++++++-        center_reward=True,
+++++++++++-        multi_flowrate=False,
+++++++++++-        opt='RMSprop',
+++++++++++-
+++++++++++-        obs_tail=True,
+++++++++++-        obs_next_cross_platoons=1,
+++++++++++-
+++++++++++-        beta=0,
+++++++++++-        scale_pet=1,
+++++++++++-        scale_drac=1,
+++++++++++-        seed_np=False,
+++++++++++-        seed_torch = False,
+++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++++-    )
+++++++++++-
+++++++++++-    if c.seed_torch:
+++++++++++-        # Set seed for PyTorch CPU operations
+++++++++++-        torch.manual_seed(c.seed_torch)
+++++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++++-        if torch.cuda.is_available():
+++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++++-    if c.seed_np:
+++++++++++-        np.random.seed(c.seed_np)
+++++++++++-
+++++++++++-    if c.directions == '4way':
+++++++++++-        c.directions = ['up', 'right', 'down', 'left']
+++++++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
+++++++++++-    if c.mrtl:
+++++++++++-        c._n_obs += 1
+++++++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
+++++++++++-    c.redef_sumo = 'length_range' in c
+++++++++++-    c.run()
+++++++++++\ No newline at end of file
+++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++++index d4c3dac..9e3eb3a 100644
+++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++++@@ -1,600 +1,3467 @@
+++++++++++-diff --git a/README.md b/README.md
+++++++++++-index b591747..127f484 100644
+++++++++++---- a/README.md
+++++++++++-+++ b/README.md
+++++++++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
+++++++++++- ### 1.2 Set the environmental variables
+++++++++++- ```
+++++++++++- # Code directory
+++++++++++--export F=automatic_vehicular_control/automatic_vehicular_control
+++++++++++-+export F=automatic_vehicular_control
+++++++++++- 
+++++++++++- # Results directory extracted from the zip file
+++++++++++- export R=results
+++++++++++-@@ -48,10 +48,8 @@ export R=results
+++++++++++- ## 2. Directory Structure
+++++++++++- 
+++++++++++- The code directory structure is
+++++++++++--```
+++++++++++-+``` 
+++++++++++- automatic_vehicular_control/
+++++++++++--│
+++++++++++--├── automatic_vehicular_control/
+++++++++++- │   ├── __pycache__/                # Compiled Python files
+++++++++++- │   ├── evaluations/                # Evaluation results and metrics
+++++++++++- │   ├── models/                     # Model checkpoints
+++++++++++ diff --git a/env.py b/env.py
+++++++++++-index 4ab3d95..c83a674 100644
++++++++++++index c83a674..92ff463 100644
+++++++++++ --- a/env.py
+++++++++++ +++ b/env.py
+++++++++++-@@ -724,9 +724,11 @@ class TrafficState:
+++++++++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
+++++++++++- 
+++++++++++-         segments = {}
++++++++++++@@ -852,12 +852,15 @@ class TrafficState:
++++++++++++         subscribes.sim = SubscribeDef(tc.simulation, [
++++++++++++             V.departed_vehicles_ids, V.arrived_vehicles_ids,
++++++++++++             V.colliding_vehicles_ids, V.loaded_vehicles_ids]).subscribe()
+++++++++++ +        
+++++++++++-         def add_from_to(from_, to):
+++++++++++-             from_.tos.add(to)
+++++++++++-             to.froms.add(from_)
+++++++++++-+            
+++++++++++-         for con in map(values_str_to_val, net.children('connection')):
+++++++++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
+++++++++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
+++++++++++-@@ -888,89 +890,109 @@ class TrafficState:
+++++++++++- 
+++++++++++-     def step(self):
+++++++++++-         """
+++++++++++--        Take a simulation step and update state
+++++++++++-+        Take a simulation step and update state.
+++++++++++-         """
+++++++++++--        c = self.c
+++++++++++--        tc = self.tc
+++++++++++--        subscribes = self.subscribes
+++++++++++-+        c = self.c  # Configuration object for the simulation
+++++++++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
+++++++++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
+++++++++++- 
+++++++++++-         # Actual SUMO step
+++++++++++--        tc.simulationStep()
+++++++++++--        sim_res = subscribes.sim.get()
+++++++++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
+++++++++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
+++++++++++- 
+++++++++++-+        # Clear references to current vehicle edges and lanes for the next update
+++++++++++-         for veh in self.vehicles:
+++++++++++--            veh.unvar('edge', 'lane')
+++++++++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
+++++++++++-+
+++++++++++-+        # Clear current vehicle data from edges and lanes
+++++++++++-         for ent in itertools.chain(self.edges, self.lanes):
+++++++++++--            ent.vehicles.clear()
+++++++++++--            ent.positions.clear()
+++++++++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
+++++++++++-+            ent.positions.clear()  # Clear vehicle positions
+++++++++++- 
+++++++++++-+        # Update traffic light states
+++++++++++-         for tl_id, tl in self.traffic_lights.items():
+++++++++++--            tl.update(subscribes.tl.get(tl_id))
+++++++++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
+++++++++++- 
+++++++++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
+++++++++++-         for veh_id in sim_res.loaded_vehicles_ids:
+++++++++++--            flow_id, _ = veh_id.rsplit('.')
+++++++++++--            flow = self.flows[flow_id]
+++++++++++--            flow.backlog.add(veh_id)
+++++++++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
+++++++++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
+++++++++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
+++++++++++- 
+++++++++++-+        # Initialize a set for newly departed vehicles
+++++++++++-         self.new_departed = set()
+++++++++++-+
+++++++++++-+        # Handle vehicles that have departed (entered the network)
+++++++++++-         for veh_id in sim_res.departed_vehicles_ids:
+++++++++++--            subscribes.veh.subscribe(veh_id)
+++++++++++--            type_id = tc.vehicle.getTypeID(veh_id)
+++++++++++--            # import pdb; pdb.set_trace()
+++++++++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
+++++++++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
+++++++++++-+            # If vehicle type is 'generic', compute specific type
+++++++++++-             if type_id == 'generic':
+++++++++++-                 type_id = self.compute_type(veh_id)
+++++++++++--            type_ = self.types[type_id]
+++++++++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
+++++++++++--            length = tc.vehicle.getLength(veh_id)
+++++++++++--            road_id = tc.vehicle.getRoadID(veh_id)
+++++++++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
+++++++++++--            type_.vehicles.add(veh)
+++++++++++-+            type_ = self.types[type_id]  # Get vehicle type object
+++++++++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
+++++++++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
+++++++++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
+++++++++++-+
+++++++++++-+            # Create a new vehicle object and add it to the list of vehicles
+++++++++++-+            self.vehicles[veh_id] = veh = Vehicle(
+++++++++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
+++++++++++-+            )
+++++++++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
+++++++++++- 
+++++++++++-+            # Set color if rendering is enabled
+++++++++++-             if c.render:
+++++++++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
+++++++++++--                self.set_color(veh, color_fn(veh))
+++++++++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
+++++++++++- 
+++++++++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
+++++++++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
+++++++++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
+++++++++++-+
+++++++++++-+            # Add to new_departed set
+++++++++++-             self.new_departed.add(veh)
+++++++++++-+
+++++++++++-+            # Remove vehicle from backlog if necessary
+++++++++++-             if '.' in veh_id:
+++++++++++-                 flow_id, _ = veh_id.rsplit('.')
+++++++++++-                 if flow_id in self.flows:
+++++++++++-                     flow = self.flows[flow_id]
+++++++++++-                     flow.backlog.remove(veh_id)
+++++++++++- 
+++++++++++-+        # Handle newly arrived and collided vehicles
+++++++++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
+++++++++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
++++++++++++         subscribes.tl = SubscribeDef(tc.trafficlight, [
++++++++++++             TL.red_yellow_green_state])
+++++++++++ +        
+++++++++++-+        # Remove newly arrived vehicles from tracking if they collided
+++++++++++-         for veh in self.new_arrived:
+++++++++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
+++++++++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
+++++++++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
+++++++++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
+++++++++++- 
+++++++++++-+        # Update vehicle positions on edges and lanes
+++++++++++-         for veh_id, veh in self.vehicles.items():
+++++++++++--            veh.prev_speed = veh.get('speed', None)
+++++++++++--            veh.update(subscribes.veh.get(veh_id))
+++++++++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
+++++++++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
+++++++++++-             if veh_id not in sim_res.colliding_vehicles_ids:
+++++++++++--                edge = self.edges[veh.road_id]
+++++++++++--                edge.vehicles.append(veh)
+++++++++++--                veh.edge = edge
+++++++++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
+++++++++++--            # edge = self.edges[veh.road_id]
+++++++++++--            # edge.vehicles.append(veh)
+++++++++++--            # veh.edge = edge
+++++++++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
+++++++++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
+++++++++++-+                veh.edge = edge  # Set vehicle's edge attribute
+++++++++++- 
+++++++++++-+        # Update vehicle sorting and lane positions
+++++++++++-         for edge in self.edges:
+++++++++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
+++++++++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
+++++++++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
+++++++++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
+++++++++++-             for edge_i, veh in enumerate(edge.vehicles):
+++++++++++--                veh.edge_i = edge_i
+++++++++++--                veh.lane = lane = edge.lanes[veh.lane_index]
+++++++++++--                veh.lane_i = len(lane.vehicles)
+++++++++++--                lane.vehicles.append(veh)
+++++++++++--                lane.positions.append(veh.laneposition)
+++++++++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
+++++++++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
+++++++++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
+++++++++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
+++++++++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
+++++++++++- 
+++++++++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
+++++++++++-         self.all_arrived.append(self.new_arrived)
+++++++++++-         self.all_departed.append(self.new_departed)
+++++++++++-         self.all_collided.append(self.new_collided)
+++++++++++--
+++++++++++-+            
+++++++++++-     def reset(self, tc):
+++++++++++-         self.tc = tc
+++++++++++-         self.subscribes.clear()
+++++++++++-@@ -1043,6 +1065,7 @@ class Env:
+++++++++++-     """
+++++++++++-     Offers a similar reinforcement learning environment interface as gym.Env
+++++++++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
+++++++++++-+    c: Ring class
+++++++++++-     """
+++++++++++-     def __init__(self, c):
+++++++++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
+++++++++++-@@ -1056,6 +1079,7 @@ class Env:
+++++++++++-             if c.get('save_agent'):
+++++++++++-                 self._agent_info = []
+++++++++++-         self._step = 0
+++++++++++-+        self.mean_speed = 0
+++++++++++- 
+++++++++++-     def def_sumo(self, *args, **kwargs):
+++++++++++-         """ Override this with code defining the SUMO network """
+++++++++++-@@ -1094,49 +1118,91 @@ class Env:
+++++++++++-         """
+++++++++++-         return True
+++++++++++- 
+++++++++++-+   # Method to reset or initialize the SUMO traffic simulation environment
+++++++++++-     def reset_sumo(self):
+++++++++++-+        # Shortcuts for configuration and SUMO definition objects
+++++++++++-         c = self.c
+++++++++++-         sumo_def = self.sumo_def
+++++++++++--
+++++++++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
+++++++++++-+        
+++++++++++-+        # Determine if new SUMO definitions need to be generated
+++++++++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
+++++++++++-+        
+++++++++++-         if generate_def:
+++++++++++--            kwargs = self.def_sumo()
+++++++++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
+++++++++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
+++++++++++-+            # Generate new definitions if necessary
+++++++++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
+++++++++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
+++++++++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
+++++++++++-+        
+++++++++++-+        # Start SUMO with the current traffic controller (tc)
+++++++++++-         self.tc = sumo_def.start_sumo(self.tc)
+++++++++++-+        
+++++++++++-         if generate_def:
+++++++++++-+            # If new definitions were generated, store relevant SUMO file paths
+++++++++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
+++++++++++-+            
+++++++++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
+++++++++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
+++++++++++--            self.ts = TrafficState(c, self.tc, **defs)
+++++++++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
+++++++++++-         else:
+++++++++++-+            # If not generating new definitions, simply reset the existing traffic state
+++++++++++-             self.ts.reset(self.tc)
+++++++++++-+        
+++++++++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
+++++++++++-         self.ts.setup()
++++++++++++         subscribes.veh = SubscribeDef(tc.vehicle, [
++++++++++++             V.road_id, V.lane_index, V.laneposition,
++++++++++++             V.speed, V.position, V.angle,
++++++++++++             V.fuelconsumption, V.noxemission])
+++++++++++ +        
+++++++++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+++++++++++-         success = self.init_vehicles()
+++++++++++-+        
+++++++++++-+        # Return whether the SUMO reset and vehicle initialization were successful
+++++++++++-         return success
++++++++++++         for tl_id in self.traffic_lights.keys():
++++++++++++             subscribes.tl.subscribe(tl_id)
+++++++++++  
+++++++++++-+    # Method to initialize the environment after SUMO reset
+++++++++++-     def init_env(self):
+++++++++++-+        # Reference to the traffic state
+++++++++++-         ts = self.ts
+++++++++++-+    
+++++++++++-+        # Create an empty data structure to store rollout information
+++++++++++-         self.rollout_info = NamedArrays()
+++++++++++-+        
+++++++++++-+        # Turn off all traffic lights in the network
+++++++++++-         for tl in ts.traffic_lights:
+++++++++++--            ts.set_program(tl, 'off')
+++++++++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
+++++++++++-+        
+++++++++++-+        # Reset the step counter to 0
+++++++++++-         self._step = 0
+++++++++++-+        
+++++++++++-+        # Take the first step in the simulation
+++++++++++-         ret = self.step()
+++++++++++-+        
+++++++++++-+        # Run the simulation for a number of warmup steps
+++++++++++-         for _ in range(self.c.warmup_steps):
+++++++++++--            ret = self.step()
+++++++++++-+            ret = self.step()  # Advance the simulation one step
+++++++++++-+            
+++++++++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
+++++++++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
+++++++++++-                 return None
+++++++++++-+        
+++++++++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
+++++++++++-         for tl in ts.traffic_lights:
+++++++++++--            ts.set_program(tl, '1')
+++++++++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
+++++++++++-+        
+++++++++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
+++++++++++-         if isinstance(ret, tuple):
+++++++++++--            return ret[0]
+++++++++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
+++++++++++--
+++++++++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
+++++++++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
+++++++++++-+        
+++++++++++-+    # Reset the entire environment, retrying until successful
+++++++++++-     def reset(self):
+++++++++++--        while True:
+++++++++++-+        self.mean_speed = 0
+++++++++++-+        while True:  # Infinite loop until the environment is successfully reset
+++++++++++-+            # Attempt to reset the SUMO simulation
+++++++++++-             if not self.reset_sumo():
+++++++++++--                continue
+++++++++++-+                continue  # If reset_sumo fails, retry the loop
+++++++++++-+            
+++++++++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
+++++++++++-             if (obs := self.init_env()) is not None:
+++++++++++--                return obs
+++++++++++-+                return obs  # Successfully initialized, return the observation
++++++++++++@@ -1148,6 +1151,7 @@ class Env:
++++++++++++             self.ts.reset(self.tc)
++++++++++++         
++++++++++++         # Set up the traffic state (e.g., initialize the simulation settings)
+++++++++++ +
+++++++++++- 
+++++++++++-     def append_step_info(self):
+++++++++++-         """
+++++++++++-@@ -1231,6 +1297,8 @@ class Env:
+++++++++++- class NormEnv(gym.Env):
+++++++++++-     """
+++++++++++-     Reward normalization with running average https://github.com/joschu/modular_rl
+++++++++++-+    self.c: Ring parameters 
+++++++++++-+    self.env: RingEnv class
+++++++++++-     """
+++++++++++-     def __init__(self, c, env):
+++++++++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
++++++++++++         self.ts.setup()
++++++++++++         
++++++++++++         # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
+++++++++++ diff --git a/exp.py b/exp.py
+++++++++++-index ead4652..7f7cee5 100644
++++++++++++index 7f7cee5..e6a53c6 100644
+++++++++++ --- a/exp.py
+++++++++++ +++ b/exp.py
+++++++++++-@@ -169,9 +169,9 @@ class Main(Config):
+++++++++++- 
+++++++++++-     def on_train_start(c):
+++++++++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
+++++++++++--        c.setdefaults(alg='Algorithm')
+++++++++++--        c._env = c.create_env()
+++++++++++--
+++++++++++-+        c.setdefaults(alg='Algorithm') 
++++++++++++@@ -408,7 +408,6 @@ class Main(Config):
++++++++++++         # Main training loop
++++++++++++         c.on_train_start()
++++++++++++         while c._i < c.n_steps:
++++++++++++-            c.on_step_start() # save stat 
++++++++++++             with torch.no_grad():
++++++++++++                 # Collect rollouts without computing gradients
++++++++++++                 rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++++++++@@ -497,3 +496,29 @@ class Main(Config):
++++++++++++             assert c.n_workers * c.n_rollouts_per_worker == c.n_rollouts_per_step
++++++++++++             c.train()
++++++++++++         c.log('job done!')
+++++++++++++
+++++++++++++    def run_2(c):
+++++++++++++        # Determine whether to train or evaluate based on configuration
+++++++++++++        c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++++++++++        c.setdefaults(n_workers=1, n_rollouts_per_worker=c.n_rollouts_per_step, use_ray=False)
+++++++++++ +        c._env = c.create_env() # Create NormEnv
+++++++++++-+ 
+++++++++++-         # Instantiate the algorithm (e.g., PPO, DQN)
+++++++++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
+++++++++++-         c.set_model()
+++++++++++-@@ -222,8 +222,8 @@ class Main(Config):
+++++++++++- 
+++++++++++-     def on_step_start(c, stats={}):
+++++++++++-         # Update the learning rate and log stats at the start of a training step
+++++++++++--        lr = c._lr
+++++++++++--        for g in c._opt.param_groups:
+++++++++++-+        lr = c._lr # Update Learning Rate
+++++++++++-+        for g in c._opt.param_groups: # Log Statistics
+++++++++++-             g['lr'] = float(lr)
+++++++++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
+++++++++++- 
+++++++++++-@@ -285,10 +285,14 @@ class Main(Config):
+++++++++++-             ret = dict(obs=ret)
+++++++++++-         rollout = NamedArrays()
+++++++++++-         rollout.append(**ret)
+++++++++++--
+++++++++++-+        rollout_flow_each_step = []
+++++++++++-         done = False
+++++++++++-         a_space = c.action_space
+++++++++++-         step = 0
+++++++++++++        ret = c._env.reset()
+++++++++++++        step = 0
+++++++++++ +        density = 20/(250*1e-3)
+++++++++++ +        vehicle_flow = c._env.mean_speed * 3.6 * density 
+++++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
+++++++++++-+
+++++++++++-         while step < c.horizon + c.skip_stat_steps and not done:
+++++++++++-             # Generate an action from the model's policy
+++++++++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
+++++++++++-@@ -309,6 +313,12 @@ class Main(Config):
+++++++++++-             rollout.append(**ret)
+++++++++++-             step += 1
+++++++++++-         # Collect stats from the environment
+++++++++++++        done = False
+++++++++++++        while step < c.horizon + c.skip_stat_steps and not done:
+++++++++++++            # Take a step in the environment
+++++++++++++            ret = c._env.step()
+++++++++++++            if isinstance(ret, tuple):
+++++++++++++                obs, reward, done, info = ret
+++++++++++++                ret = dict(obs=obs, reward=reward, done=done, info=info)
+++++++++++++            done = ret.setdefault('done', False)
+++++++++++++            step += 1
+++++++++++++        # Collect stats from the environment
+++++++++++ +        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
+++++++++++ +        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
+++++++++++ +        density = 20/(250 * 1e-3)
+++++++++++ +        vehicle_flow = c._env.mean_speed * density 
+++++++++++ +        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
+++++++++++-+
+++++++++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
+++++++++++-         return rollout, stats
+++++++++++- 
+++++++++++-@@ -398,10 +408,10 @@ class Main(Config):
+++++++++++-         # Main training loop
+++++++++++-         c.on_train_start()
+++++++++++-         while c._i < c.n_steps:
+++++++++++--            c.on_step_start()
+++++++++++-+            c.on_step_start() # save stat 
+++++++++++-             with torch.no_grad():
+++++++++++-                 # Collect rollouts without computing gradients
+++++++++++--                rollouts = c.rollouts()
+++++++++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++++++++-             gd_stats = {}
+++++++++++-             if len(rollouts.obs):
+++++++++++-                 t_start = time()
+++++++++++-@@ -410,7 +420,7 @@ class Main(Config):
+++++++++++-                 gd_stats.update(gd_time=time() - t_start)
+++++++++++-             c.on_step_end(gd_stats)
+++++++++++-             c._i += 1
+++++++++++--        c.on_step_start()  # last step
+++++++++++-+        c.on_step_start()  # save stat
+++++++++++-         gd_stats = {}
+++++++++++-         with torch.no_grad():
+++++++++++-             rollouts = c.rollouts()
+++++++++++-@@ -450,6 +460,8 @@ class Main(Config):
+++++++++++-         if hasattr(c._env, 'close'):
+++++++++++-             c._env.close()
+++++++++++- 
+++++++++++-+  
+++++++++++-+
+++++++++++-     def run(c):
+++++++++++-         # Determine whether to train or evaluate based on configuration
+++++++++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++++++++-diff --git a/ring.py b/ring.py
+++++++++++-index 94d632d..ee1372b 100644
+++++++++++---- a/ring.py
+++++++++++-+++ b/ring.py
+++++++++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
+++++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++++++++-         )
++++++++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
++++++++++++deleted file mode 100644
++++++++++++index 6b9ba52..0000000
++++++++++++--- a/highway_bottleneck.py
+++++++++++++++ /dev/null
++++++++++++@@ -1,381 +0,0 @@
++++++++++++-from automatic_vehicular_control.exp import *
++++++++++++-from automatic_vehicular_control.env import *
++++++++++++-from automatic_vehicular_control.u import *
+++++++++++ -
+++++++++++-         # Function to generate the shape of the edges (circular arcs)
+++++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++++++++++- 
+++++++++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
+++++++++++-         if c.circumference_range:  # Check if the circumference should be randomized
+++++++++++-             # Randomly set the circumference within the specified range
+++++++++++-             c.circumference = np.random.randint(*c.circumference_range)
+++++++++++-+        
+++++++++++-+        if self.flow_log:
+++++++++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
+++++++++++-+            self.episode_flow.append(average_flow)
+++++++++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
+++++++++++-+        
+++++++++++-+        # Reset flow counters for the new episode
+++++++++++-+        self.flow_counter = 0
+++++++++++-+        self.flow_log = []
+++++++++++-+        self.last_vehicle_times = {}
+++++++++++-+        
+++++++++++-         return super().reset_sumo()  # Reset the simulation
+++++++++++- 
+++++++++++-     @property
+++++++++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
+++++++++++-         }
+++++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++++++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
+++++++++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
+++++++++++-         return stats
+++++++++++--
+++++++++++-+    
+++++++++++-+    def calculate_flow(self):
+++++++++++-+        """
+++++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++++++++-+        """
+++++++++++-+        current_time = self.ts.time
+++++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++++++++-+
+++++++++++-+        for vehicle in vehicles_on_edge:
+++++++++++-+            # Check if vehicle has passed the observation point since the last timestep
+++++++++++-+            if vehicle.id not in self.last_vehicle_times:
+++++++++++-+                # If the vehicle was not previously recorded, count it as a new passage
+++++++++++-+                self.flow_counter += 1
+++++++++++-+            else:
+++++++++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
+++++++++++-+                last_time = self.last_vehicle_times[vehicle.id]
+++++++++++-+                if current_time - last_time > self.c.sim_step:
+++++++++++-+                    self.flow_counter += 1
+++++++++++-+
+++++++++++-+            # Update the last time the vehicle passed the point
+++++++++++-+            self.last_vehicle_times[vehicle.id] = current_time
+++++++++++-+
+++++++++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
+++++++++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
+++++++++++-+        self.flow_log.append(flow_per_hour)
+++++++++++-+        return flow_per_hour
+++++++++++-+    
+++++++++++-     def step(self, action=None):
+++++++++++-         c = self.c  # Configuration object
+++++++++++-         ts = self.ts  # Time step object
+++++++++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
+++++++++++-                     # Change to a specific lane
+++++++++++-                     ts.lane_change_to(rl, lc)
++++++++++++-class BNeckEnv(Env):
++++++++++++-    def def_sumo(self):
++++++++++++-        c = self.c
++++++++++++-        nodes = E('nodes',
++++++++++++-            E('node', id='n_0', x=0, y=0), *(
++++++++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
++++++++++++-        ))
++++++++++++-        edges = E('edges', *(
++++++++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
++++++++++++-                'numLanes': n_lane,
++++++++++++-                'speed': c.max_speed
++++++++++++-            }) for i, n_lane in enumerate(c.n_lanes)
++++++++++++-        ))
++++++++++++-        connections = E('connections', *(
++++++++++++-            E('connection', **{
++++++++++++-                'from': prev.id,
++++++++++++-                'to': curr.id,
++++++++++++-                'fromLane': i,
++++++++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
++++++++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
++++++++++++-        ))
++++++++++++-
++++++++++++-        if c.split_flow:
++++++++++++-            n_inflow_lanes = c.n_lanes[0]
++++++++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
++++++++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
++++++++++++-                for i in range(n_inflow_lanes)
++++++++++++-            ]
++++++++++++-        else:
++++++++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
++++++++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
++++++++++++-            ]
++++++++++++-        routes = E('routes',
++++++++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
++++++++++++-            *flows
++++++++++++-        )
++++++++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
++++++++++++-        additional = E('additional',
++++++++++++-            E('vType', id='generic', **idm_params),
++++++++++++-            E('vType', id='rl', **idm_params),
++++++++++++-            E('vType', id='human', **idm_params),
++++++++++++-        )
++++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++++++++-
++++++++++++-    def reset_sumo(self):
++++++++++++-        c = self.c
++++++++++++-        if c.flow_rate_range:
++++++++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
++++++++++++-        ret = super().reset_sumo()
++++++++++++-        if c.vinitsky:
++++++++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
++++++++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
++++++++++++-                for i_start in range(round(edge.length) // c.piece_length)
++++++++++++-                for lane in edge.lanes
++++++++++++-            ]
++++++++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
++++++++++++-            self.last_outflows = []
++++++++++++-        return ret
++++++++++++-
++++++++++++-    def step(self, action=[]):
++++++++++++-        c = self.c
++++++++++++-        ts = self.ts
++++++++++++-        max_dist = 100
++++++++++++-        max_speed = c.max_speed
++++++++++++-        human_type = ts.types.human
++++++++++++-        rl_type = ts.types.rl
++++++++++++-
++++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++++++-        if c.vinitsky:
++++++++++++-            if len(action):
++++++++++++-                assert len(action) == len(self.control_lanes)
++++++++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
++++++++++++-                    self.control_lanes[lane, piece_start] = np.clip(
++++++++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
++++++++++++-                        0.1, max_speed
++++++++++++-                    )
++++++++++++-                for veh in prev_rls:
++++++++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
++++++++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
++++++++++++-        else:
++++++++++++-            for veh, act in zip(prev_rls, action):
++++++++++++-                if c.handcraft:
++++++++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
++++++++++++-                    next_lane = lane.next(veh.route)
++++++++++++-                    level = 1
++++++++++++-                    if next_lane and next_lane.get('junction'):
++++++++++++-                        merge_dist = lane.length - veh.laneposition
++++++++++++-                        if merge_dist < c.handcraft:
++++++++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
++++++++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
++++++++++++-                                level = 0
++++++++++++-                    if c.act_type.startswith('accel'):
++++++++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++++-                    else:
++++++++++++-                        ts.set_max_speed(veh, max_speed * level)
++++++++++++-                    continue
++++++++++++-                if not isinstance(act, (int, np.integer)):
++++++++++++-                    act = (act - c.low) / (1 - c.low)
++++++++++++-                if c.act_type.startswith('accel'):
++++++++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++++-                else:
++++++++++++-                    if c.act_type == 'continuous':
++++++++++++-                        level = act[0]
++++++++++++-                    elif c.act_type == 'discretize':
++++++++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++++++++-                    elif c.act_type == 'discrete':
++++++++++++-                        level = act / (c.n_actions - 1)
++++++++++++-                    ts.set_max_speed(veh, max_speed * level)
++++++++++++-
++++++++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
++++++++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
++++++++++++-
++++++++++++-        super().step()
++++++++++++-
++++++++++++-        if c.vinitsky:
++++++++++++-            n_last_outflows = 20
++++++++++++-            max_vehs = 4
++++++++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
++++++++++++-            obs = []
++++++++++++-            for lane, piece_start in self.obs_lanes:
++++++++++++-                piece_end = piece_start + c.piece_length
++++++++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
++++++++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
++++++++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
++++++++++++-                obs.extend([
++++++++++++-                    len(lane_humans) / max_vehs,
++++++++++++-                    len(lane_avs) / max_vehs,
++++++++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
++++++++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
++++++++++++-                ])
++++++++++++-            if len(self.last_outflows) == n_last_outflows:
++++++++++++-                self.last_outflows = self.last_outflows[1:]
++++++++++++-            self.last_outflows.append(len(ts.new_arrived))
++++++++++++-            reward = np.mean(self.last_outflows)
++++++++++++-            obs.append(reward / max_veh_outflows)
++++++++++++-            obs = np.array(obs, dtype=np.float32)
++++++++++++-            assert 0 <= obs.min() and obs.max() <= 1
++++++++++++-            return obs, reward, False, None
++++++++++++-        route = nexti(ts.routes)
++++++++++++-        obs, ids = [], []
++++++++++++-        default_close = [0, max_speed]
++++++++++++-        default_far = [max_dist, 0]
++++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++++++++-            merge_dist = max_dist
++++++++++++-            default_human = default_far
++++++++++++-
++++++++++++-            other_info = {}
++++++++++++-            next_lane = lane.next(veh.route)
++++++++++++-            if next_lane and next_lane.get('junction'):
++++++++++++-                merge_dist = lane.length - veh.laneposition
++++++++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
++++++++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
++++++++++++-                # Look for veh on other lane but do not extend past that lane
++++++++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
++++++++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
++++++++++++-                    if other_veh.type is rl_type:
++++++++++++-                        default_human = default_close
++++++++++++-                        break
++++++++++++-
++++++++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
++++++++++++-            ids.append(veh.id)
++++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
++++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++++++-        
++++++++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++++++-
++++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++++++-
++++++++++++-        raw_pet = self.calc_pet()
++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++++++-        pet = np.clip(pet, -1, 1)
++++++++++++-
++++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++++++-        
++++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++++++-        return returned
++++++++++++-        
++++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++++++-    
++++++++++++-    def calc_ttc(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        ttcs = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            leader, headway = v.leader()
++++++++++++-            v_speed = v.speed
++++++++++++-            leader_speed = leader.speed
++++++++++++-            if leader_speed < v_speed:
++++++++++++-                ttc =  headway/(v_speed-leader_speed)
++++++++++++-            else:
++++++++++++-                ttc = np.nan
++++++++++++-            ttcs.append(ttc)
++++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++++++-        return fleet_ttc
++++++++++++-    
++++++++++++-    def calc_drac(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        dracs = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            leader, headway = v.leader()
++++++++++++-            v_speed = v.speed
++++++++++++-            leader_speed = leader.speed
++++++++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++++++-            dracs.append(drac)
++++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++++++-        return fleet_drac
++++++++++++-
++++++++++++-    def calc_pet(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        pets = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            leader, headway = v.leader()
++++++++++++-            v_speed = v.speed
++++++++++++-            if v_speed > 1e-16:
++++++++++++-                pet = headway/(v_speed)
++++++++++++-                pets.append(pet)
++++++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++++++-        return fleet_pet
++++++++++++-
++++++++++++-class BNeck(Main):
++++++++++++-    def create_env(c):
++++++++++++-        return BNeckEnv(c)
++++++++++++-
++++++++++++-    @property
++++++++++++-    def observation_space(c):
++++++++++++-        low = np.full(c._n_obs, c.low)
++++++++++++-        return Box(low, np.ones_like(low))
++++++++++++-
++++++++++++-    @property
++++++++++++-    def action_space(c):
++++++++++++-        if c.vinitsky:
++++++++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
++++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++++++++-            assert c.lc_av in [False, 'binary']
++++++++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
++++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++++++++-            return Discrete(c.n_actions)
++++++++++++-
++++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++++++-        if c.vinitsky:
++++++++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
++++++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++++++-        step_obs_ = rollout.obs
++++++++++++-        step_obs = step_obs_[:-1]
++++++++++++-
++++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++++++-
++++++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++++++-
++++++++++++-        step_id_ = rollout.pop('id')
++++++++++++-        id = np.concatenate(step_id_[:-1])
++++++++++++-        id_unique = np.unique(id)
++++++++++++-
++++++++++++-        reward = np.array(rollout.pop('reward'))
++++++++++++-
++++++++++++-        log(**stats)
++++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++++++-        log(
++++++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++++++-            n_veh_unique=len(id_unique),
++++++++++++-            
++++++++++++-            reward_mean=np.mean(reward),
++++++++++++-            reward_std=np.std(reward),        
++++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++++++-            ssm_std=np.std(rollout.ssm),
++++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++++-
++++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++++++-            # res_action = np.mean(rollout.res_action),
++++++++++++-            )
++++++++++++-        return rollout
++++++++++++-
++++++++++++-if __name__ == '__main__':
++++++++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
++++++++++++-        warmup_steps=1000,
++++++++++++-        horizon=2000,
++++++++++++-        n_steps=100,
++++++++++++-        step_save=5,
++++++++++++-
++++++++++++-        av_frac=0.2,
++++++++++++-        sim_step=0.5,
++++++++++++-        depart_speed=0,
++++++++++++-        edge_lengths=[100, 100, 50],
++++++++++++-        n_lanes=[4, 2, 1],
++++++++++++-        max_speed=30,
++++++++++++-
++++++++++++-        lc_av=False,
++++++++++++-        flow_rate=2300,
++++++++++++-        flow_rate_range=None,
++++++++++++-        split_flow=True,
++++++++++++-        generic_type='rand',
++++++++++++-        speed_mode=SPEED_MODE.all_checks,
++++++++++++-        lc_mode=LC_MODE.off,
++++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++++++-
++++++++++++-        veh_junction=False,
++++++++++++-        act_type='accel_discrete',
++++++++++++-        max_accel=2.6,
++++++++++++-        max_decel=4.5,
++++++++++++-        tau=1.0,
++++++++++++-        min_gap=2.5,
++++++++++++-        delta=4,
++++++++++++-        n_actions=3,
++++++++++++-        low=-1,
++++++++++++-        handcraft=False,
++++++++++++-        vinitsky=False,
++++++++++++-
++++++++++++-        render=False,
++++++++++++-
++++++++++++-        alg=PG,
++++++++++++-        lr=1e-3,
++++++++++++-
++++++++++++-        gamma=0.99,
++++++++++++-        adv_norm=False,
++++++++++++-        batch_concat=True,
++++++++++++-
++++++++++++-        beta=0,
++++++++++++-        scale_ttc=1,
++++++++++++-        scale_drac=1,
++++++++++++-        seed_np=False,
++++++++++++-        seed_torch = False,
++++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++++++-
++++++++++++-    )
++++++++++++-    
++++++++++++-    if c.seed_torch:
++++++++++++-        # Set seed for PyTorch CPU operations
++++++++++++-        torch.manual_seed(c.seed_torch)
++++++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++++++-        if torch.cuda.is_available():
++++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++++++-    if c.seed_np:
++++++++++++-        np.random.seed(c.seed_np)
++++++++++++-        
++++++++++++-    if c.vinitsky:
++++++++++++-        c.piece_length = 20
++++++++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
++++++++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
++++++++++++-        c._n_action = sum(n_actions[:-1])
++++++++++++-        c._n_obs = sum(n_actions) * 4 + 1
++++++++++++-        c.batch_concat = False
++++++++++++-    else:
++++++++++++-        c._n_obs = 2 + 2 + 2
++++++++++++-        
++++++++++++-    if c.mrtl:
++++++++++++-        c._n_obs += 1 # modified for mrtl related
++++++++++++-        
++++++++++++-    c.redef_sumo = bool(c.flow_rate_range)
++++++++++++-    c.run()
++++++++++++\ No newline at end of file
++++++++++++diff --git a/highway_ramp.py b/highway_ramp.py
++++++++++++deleted file mode 100644
++++++++++++index ef0358f..0000000
++++++++++++--- a/highway_ramp.py
+++++++++++++++ /dev/null
++++++++++++@@ -1,325 +0,0 @@
++++++++++++-from automatic_vehicular_control.exp import *
++++++++++++-from automatic_vehicular_control.env import *
++++++++++++-from automatic_vehicular_control.u import *
++++++++++++-
++++++++++++-class RampEnv(Env):
++++++++++++-    # https://flow-project.github.io/papers/08569485.pdf
++++++++++++-    def def_sumo(self):
++++++++++++-        c = self.c
++++++++++++-        builder = NetBuilder()
++++++++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
++++++++++++-            (0, 0),
++++++++++++-            (c.premerge_distance, 0),
++++++++++++-            (c.premerge_distance + c.merge_distance, 0),
++++++++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
++++++++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
++++++++++++-        ])
++++++++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
++++++++++++-            {}, {'numLanes': 2}, {}
++++++++++++-        ], lane_maps=[
++++++++++++-            {0: 1}, {0: 0, 1: 0}
++++++++++++-        ], route_id='highway')
++++++++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
++++++++++++-            {}, {'numLanes': 2}, {}
++++++++++++-        ], lane_maps=[
++++++++++++-            {0: 0}, {0: 0, 1: 0}
++++++++++++-        ], route_id='ramp')
++++++++++++-        nodes, edges, connections, routes = builder.build()
++++++++++++-        nodes[2].type = 'zipper'
++++++++++++-
++++++++++++-        routes = E('routes',
++++++++++++-            *routes,
++++++++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
++++++++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
++++++++++++-        )
++++++++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
++++++++++++-        additional = E('additional',
++++++++++++-            E('vType', id='generic', **idm),
++++++++++++-            E('vType', id='rl', **idm),
++++++++++++-            E('vType', id='human', **idm),
++++++++++++-        )
++++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
++++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
++++++++++++-
++++++++++++-    def step(self, action=[]):
++++++++++++-        c = self.c
++++++++++++-        ts = self.ts
++++++++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
++++++++++++-        max_speed = c.max_speed
++++++++++++-        human_type = ts.types.human
++++++++++++-        rl_type = ts.types.rl
++++++++++++-
++++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++++++-        for rl, act in zip(prev_rls, action):
++++++++++++-            if c.handcraft:
++++++++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
++++++++++++-                leader, dist = rl.leader()
++++++++++++-                level = 1
++++++++++++-                if edge.id == 'e_n_0.0_n_400.0':
++++++++++++-                    if rl.laneposition < 100:
++++++++++++-                        leaders = list(rl.leaders())
++++++++++++-                        if len(leaders) > 20:
++++++++++++-                            level = 0
++++++++++++-                        else:
++++++++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
++++++++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++++-                continue
++++++++++++-            if not isinstance(act, (int, np.integer)):
++++++++++++-                act = (act - c.low) / (1 - c.low)
++++++++++++-            if c.act_type.startswith('accel'):
++++++++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
++++++++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++++-            else:
++++++++++++-                if c.act_type == 'continuous':
++++++++++++-                    level = act[0]
++++++++++++-                elif c.act_type == 'discretize':
++++++++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
++++++++++++-                elif c.act_type == 'discrete':
++++++++++++-                    level = act / (c.n_actions - 1)
++++++++++++-                ts.set_max_speed(rl, max_speed * level)
++++++++++++-
++++++++++++-        super().step()
++++++++++++-
++++++++++++-        route = ts.routes.highway
++++++++++++-        obs, ids = [], []
++++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
++++++++++++-            if hasattr(veh, 'edge'):
++++++++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
++++++++++++-                merge_dist = max_dist
++++++++++++-
++++++++++++-                lead_speed = follow_speed = other_speed = 0
++++++++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
++++++++++++-
++++++++++++-                leader, dist = veh.leader()
++++++++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
++++++++++++-
++++++++++++-                follower, dist = veh.follower()
++++++++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
++++++++++++-
++++++++++++-                if c.global_obs:
++++++++++++-                    jun_edge = edge.next(route)
++++++++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
++++++++++++-                        jun_edge = jun_edge.next(route)
++++++++++++-                    if jun_edge:
++++++++++++-                        merge_dist = lane.length - veh.laneposition
++++++++++++-                        next_edge = edge.next(route)
++++++++++++-                        while next_edge is not jun_edge:
++++++++++++-                            merge_dist += next_edge.length
++++++++++++-                            next_edge = next_edge.next(route)
++++++++++++-
++++++++++++-                        other_lane = jun_edge.lanes[0]
++++++++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
++++++++++++-                            other_speed = other_veh.speed
++++++++++++-                            break
++++++++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
++++++++++++-                else:
++++++++++++-                    next_lane = lane.next(route)
++++++++++++-                    if next_lane and next_lane.get('junction'):
++++++++++++-                        if len(edge.lanes) == 2:
++++++++++++-                            other_lane = edge.lanes[0]
++++++++++++-                            pos = veh.laneposition
++++++++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
++++++++++++-                                other_speed = other_veh.speed
++++++++++++-                                break
++++++++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
++++++++++++-                ids.append(veh.id)
++++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
++++++++++++-        if c.mrtl:
++++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++++++-        
++++++++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++++++-
++++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++++++-
++++++++++++-        raw_pet = self.calc_pet()
++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++++++-        pet = np.clip(pet, -1, 1)
++++++++++++-
++++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
++++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++++++-        
++++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++++++-        return returned
++++++++++++-        
++++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++++++-    
++++++++++++-    def calc_ttc(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        ttcs = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            if hasattr(v, 'edge'):
++++++++++++-                leader, headway = v.leader()
++++++++++++-                if leader:
++++++++++++-                    v_speed = v.speed
++++++++++++-                    leader_speed = leader.speed
++++++++++++-                    if leader_speed < v_speed:
++++++++++++-                        ttc =  headway/(v_speed-leader_speed)
++++++++++++-                    else:
++++++++++++-                        ttc = np.nan
++++++++++++-                    ttcs.append(ttc)
++++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++++++-        return fleet_ttc
++++++++++++-    
++++++++++++-    def calc_drac(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        dracs = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            if hasattr(v, 'edge'):
++++++++++++-                leader, headway = v.leader()
++++++++++++-                if leader:
++++++++++++-                    v_speed = v.speed
++++++++++++-                    leader_speed = leader.speed
++++++++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++++++-                    dracs.append(drac)
++++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++++++-        return fleet_drac
++++++++++++-
++++++++++++-    def calc_pet(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        pets = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            if hasattr(v, 'edge'):
++++++++++++-                leader, headway = v.leader()
++++++++++++-                if leader:
++++++++++++-                    v_speed = v.speed
++++++++++++-                    if v_speed > 1e-16:
++++++++++++-                        pet = headway/(v_speed)
++++++++++++-                        pets.append(pet)
++++++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
++++++++++++-        return fleet_pet
++++++++++++-
++++++++++++-class Ramp(Main):
++++++++++++-    def create_env(c):
++++++++++++-        return RampEnv(c)
++++++++++++-
++++++++++++-    @property
++++++++++++-    def observation_space(c):
++++++++++++-        low = np.full(c._n_obs, c.low)
++++++++++++-        return Box(low, np.ones_like(low))
++++++++++++-
++++++++++++-    @property
++++++++++++-    def action_space(c):
++++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
++++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
++++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
++++++++++++-            return Discrete(c.n_actions)
++++++++++++-
++++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++++++-        step_obs_ = rollout.obs
++++++++++++-        step_obs = step_obs_[:-1]
++++++++++++-
++++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++++++-
++++++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++++++-
++++++++++++-        step_id_ = rollout.pop('id')
++++++++++++-        id = np.concatenate(step_id_[:-1])
++++++++++++-        id_unique = np.unique(id)
++++++++++++-
++++++++++++-        reward = np.array(rollout.pop('reward'))
++++++++++++-
++++++++++++-        log(**stats)
++++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++++++-        log(
++++++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++++++-            n_veh_unique=len(id_unique),
++++++++++++-            
++++++++++++-            reward_mean=np.mean(reward),
++++++++++++-            reward_std=np.std(reward),        
++++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++++++-            ssm_std=np.std(rollout.ssm),
++++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++++-
++++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++++++-            # res_action = np.mean(rollout.res_action),
++++++++++++-            )
++++++++++++-        return rollout
++++++++++++-
++++++++++++-if __name__ == '__main__':
++++++++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
++++++++++++-        warmup_steps=100,
++++++++++++-        horizon=2000,
++++++++++++-        n_steps=100,
++++++++++++-        step_save=5,
++++++++++++-
++++++++++++-        premerge_distance=400,
++++++++++++-        merge_distance=100,
++++++++++++-        postmerge_distance=30,
++++++++++++-        av_frac=0.1,
++++++++++++-        sim_step=0.5,
++++++++++++-        max_speed=30,
++++++++++++-        highway_depart_speed=10,
++++++++++++-        ramp_depart_speed=0,
++++++++++++-        highway_flow_rate=2000,
++++++++++++-        ramp_flow_rate=300,
++++++++++++-        global_obs=False,
++++++++++++-        handcraft=False,
++++++++++++-
++++++++++++-        generic_type='default',
++++++++++++-        speed_mode=SPEED_MODE.all_checks,
++++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++++++-
++++++++++++-        act_type='accel_discrete',
++++++++++++-        max_accel=1,
++++++++++++-        max_decel=1.5,
++++++++++++-        n_actions=3,
++++++++++++-        low=-1,
++++++++++++-
++++++++++++-        render=False,
++++++++++++-
++++++++++++-        alg=PG,
++++++++++++-        lr=1e-3,
++++++++++++-
++++++++++++-        gamma=0.99,
++++++++++++-        adv_norm=False,
++++++++++++-        batch_concat=True,
++++++++++++-
++++++++++++-        beta=0,
++++++++++++-        scale_ttc=1,
++++++++++++-        scale_drac=1,
++++++++++++-        seed_np=False,
++++++++++++-        seed_torch = False,
++++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++++++-
++++++++++++-    )
++++++++++++-    
++++++++++++-    if c.seed_torch:
++++++++++++-        # Set seed for PyTorch CPU operations
++++++++++++-        torch.manual_seed(c.seed_torch)
++++++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++++++-        if torch.cuda.is_available():
++++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++++++-    if c.seed_np:
++++++++++++-        np.random.seed(c.seed_np)
++++++++++++-        
++++++++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
++++++++++++-    if c.mrtl:
++++++++++++-        c._n_obs += 1 # modified for mrtl related
++++++++++++-    c.run()
++++++++++++\ No newline at end of file
++++++++++++diff --git a/intersection.py b/intersection.py
++++++++++++deleted file mode 100644
++++++++++++index e38a84f..0000000
++++++++++++--- a/intersection.py
+++++++++++++++ /dev/null
++++++++++++@@ -1,489 +0,0 @@
++++++++++++-from automatic_vehicular_control.u import *
++++++++++++-from automatic_vehicular_control.exp import *
++++++++++++-from automatic_vehicular_control.env import *
++++++++++++-
++++++++++++-class Platoon(Entity):
++++++++++++-    pass
++++++++++++-
++++++++++++-class IntersectionEnv(Env):
++++++++++++-    def def_sumo(self):
++++++++++++-        c = self.c
++++++++++++-
++++++++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
++++++++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
++++++++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
++++++++++++-        ] if params.get('vehsPerHour')]
++++++++++++-
++++++++++++-        builder = NetBuilder()
++++++++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
++++++++++++-        if c.enter_length:
++++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++++++++-            xys[1:, :, 0] += c.enter_length - c.length
++++++++++++-            xys[:, 1:, 1] += c.enter_length - c.length
++++++++++++-            xys = xys.reshape(-1, 2)
++++++++++++-        if c.short_exit:
++++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
++++++++++++-            xys[-1, :, 0] += c.short_exit - c.length
++++++++++++-            xys[:, -1, 1] += c.short_exit - c.length
++++++++++++-            xys = xys.reshape(-1, 2)
++++++++++++-        nodes = builder.add_nodes(
++++++++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
++++++++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
++++++++++++-        # import pdb; pdb.set_trace()
++++++++++++-
++++++++++++-        tl = c.setdefault('tl', False)
++++++++++++-        if tl:
++++++++++++-            c.av_frac = 0
++++++++++++-            c.pop('av_range', None)
++++++++++++-            c.speed_mode = SPEED_MODE.all_checks
++++++++++++-
++++++++++++-        flows = []
++++++++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
++++++++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
++++++++++++-        for direction in c.directions:
++++++++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
++++++++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
++++++++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
++++++++++++-
++++++++++++-            edge_attrs = dict(priority=int(direction in priority))
++++++++++++-            if c.get('set_edge_speed', True):
++++++++++++-                edge_attrs['speed'] = c.max_speed
++++++++++++-
++++++++++++-            for i, chain in enumerate(chains[1:-1]):
++++++++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
++++++++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
++++++++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
++++++++++++-
++++++++++++-        tls = []
++++++++++++-        if tl:
++++++++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
++++++++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
++++++++++++-            tl_offset = c.get('tl_offset', 'auto')
++++++++++++-            yellow = c.get('yellow', 0.5)
++++++++++++-            if tl_offset == 'auto':
++++++++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
++++++++++++-            elif tl_offset == 'same':
++++++++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
++++++++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
++++++++++++-                node.type = 'traffic_light'
++++++++++++-                phase_multiple = len(c.directions) // 2
++++++++++++-                tls.append(E('tlLogic',
++++++++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
++++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
++++++++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
++++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
++++++++++++-                id=node.id, offset=offset, type='static', programID='1'))
++++++++++++-
++++++++++++-        nodes, edges, connections, routes = builder.build()
++++++++++++-        additional = E('additional', *types, *routes, *flows, *tls)
++++++++++++-        return super().def_sumo(nodes, edges, connections, additional)
++++++++++++-
++++++++++++-    def build_platoon(self):
++++++++++++-        ts = self.ts
++++++++++++-        rl_type = ts.types.rl
++++++++++++-        for route in ts.routes:
++++++++++++-            vehs = []
++++++++++++-            route_offset = 0
++++++++++++-            for edge in route.edges:
++++++++++++-                for veh in edge.vehicles:
++++++++++++-                    veh.route_position = route_offset + veh.laneposition
++++++++++++-                    vehs.append(veh)
++++++++++++-                route_offset += edge.length
++++++++++++-
++++++++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
++++++++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
++++++++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
++++++++++++-            rl_idxs, = rl_mask.nonzero()
++++++++++++-            split_idxs = 1 + rl_idxs
++++++++++++-
++++++++++++-            prev = None
++++++++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
++++++++++++-                if not len(vehs_i):
++++++++++++-                    continue # Last vehicle is RL, so the last split is empty
++++++++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
++++++++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
++++++++++++-                )
++++++++++++-                if prev is not None:
++++++++++++-                    prev.next = platoon
++++++++++++-                prev = platoon
++++++++++++-                for veh in vehs_i:
++++++++++++-                    veh.platoon = platoon
++++++++++++-            if prev is not None:
++++++++++++-                prev.next = None
++++++++++++-
++++++++++++-    def reset(self):
++++++++++++-        c = self.c
++++++++++++-        if c.e is False:
++++++++++++-            if 'length_range' in c:
++++++++++++-                min_, max_ = c.length_range
++++++++++++-                c.setdefaults(max_length=max_)
++++++++++++-                c.length = np.random.randint(min_, max_ + 1)
++++++++++++-            if 'av_range' in c:
++++++++++++-                min_, max_ = c.av_range
++++++++++++-                c.av_frac = np.random.uniform(min_, max_)
++++++++++++-        self.mp_tlast = 0
++++++++++++-        while not self.reset_sumo():
++++++++++++-            pass
++++++++++++-        ret = super().init_env()
++++++++++++-        return ret
++++++++++++-
++++++++++++-    def step(self, action=[]):
++++++++++++-        c = self.c
++++++++++++-        ts = self.ts
++++++++++++-        max_dist = c.max_dist
++++++++++++-        depart_speed = c.depart_speed
++++++++++++-        max_speed = c.max_speed
++++++++++++-
++++++++++++-        rl_type = ts.types.rl
++++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
++++++++++++-
++++++++++++-        for rl, act in zip(prev_rls, action):
++++++++++++-            if c.handcraft or c.handcraft_tl:
++++++++++++-                route, lane = rl.route, rl.lane
++++++++++++-                junction = lane.next_junction
++++++++++++-                level = 1
++++++++++++-                if junction is not ts.sentinel_junction:
++++++++++++-                    dist = junction.route_position[route] - rl.route_position
++++++++++++-                    if c.handcraft:
++++++++++++-                        for cross_lane in lane.next_cross_lanes:
++++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
++++++++++++-                    elif c.handcraft_tl and dist < 15:
++++++++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
++++++++++++-                        yellow_time = 0
++++++++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
++++++++++++-                        horizontal_go = 0 <= rem < t_h
++++++++++++-                        vertical_go = t_h + yellow_time <= rem
++++++++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
++++++++++++-                        human_remain = False
++++++++++++-                        for cross_lane in lane.next_cross_lanes:
++++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
++++++++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
++++++++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
++++++++++++-            elif c.act_type == 'accel':
++++++++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
++++++++++++-            else:
++++++++++++-                level = act / (c.n_actions - 1)
++++++++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++++-
++++++++++++-        if c.tl == 'MaxPressure':
++++++++++++-            self.mp_tlast += c.sim_step
++++++++++++-            tmin = c.get('mp_tmin', 0)
++++++++++++-            if self.mp_tlast >= tmin:
++++++++++++-                for tl in ts.traffic_lights:
++++++++++++-                    if ts.get_program(tl) == 'off':
++++++++++++-                        break
++++++++++++-                    jun = tl.junction
++++++++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
++++++++++++-
++++++++++++-                    total_pressures = []
++++++++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
++++++++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
++++++++++++-
++++++++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
++++++++++++-                self.mp_tlast = 0
++++++++++++-
++++++++++++-        super().step()
++++++++++++-        self.build_platoon()
++++++++++++-
++++++++++++-        obs = {}
++++++++++++-
++++++++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
++++++++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
++++++++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
++++++++++++-        for veh in rl_type.vehicles:
++++++++++++-            if hasattr(veh, 'lane'):
++++++++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
++++++++++++-                junction = lane.next_junction
++++++++++++-
++++++++++++-                head, tail = veh, platoon.tail
++++++++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
++++++++++++-
++++++++++++-                if junction is ts.sentinel_junction:
++++++++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
++++++++++++-                else:
++++++++++++-                    for jun_lane in lane.next_junction_lanes:
++++++++++++-                        # Defaults for jun_lane
++++++++++++-                        jun_headtails = vehs_default()
++++++++++++-
++++++++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
++++++++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
++++++++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
++++++++++++-
++++++++++++-                        if jun_veh:
++++++++++++-                            if jun_veh.type is rl_type:
++++++++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
++++++++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
++++++++++++-                                platoon = jun_veh.platoon.prev
++++++++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++++++++-                                    if platoon is None: break
++++++++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++++++++-                                    platoon = platoon.prev
++++++++++++-                            else:
++++++++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
++++++++++++-                                jun_headtails[0] = jun_veh.platoon.tail
++++++++++++-                                next_cross_platoon = jun_veh.platoon.prev
++++++++++++-                                if next_cross_platoon:
++++++++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
++++++++++++-                                    platoon = next_cross_platoon.prev
++++++++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
++++++++++++-                                        if platoon is None: break
++++++++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
++++++++++++-                                        platoon = platoon.prev
++++++++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
++++++++++++-
++++++++++++-                dist_features, speed_features = [], []
++++++++++++-                for route, vehs in route_vehs:
++++++++++++-                    j_pos = junction.route_position[route]
++++++++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
++++++++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
++++++++++++-
++++++++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
++++++++++++-
++++++++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
++++++++++++-        ids = sorted(obs)
++++++++++++-        if c.mrtl:
++++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
++++++++++++-        if c.rew_type == 'outflow':
++++++++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
++++++++++++-        elif c.rew_type == 'time_penalty':
++++++++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
++++++++++++-        
++++++++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
++++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
++++++++++++-
++++++++++++-        raw_drac = self.calc_drac()
++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
++++++++++++-        drac = np.clip(drac/10, -1, 1)
++++++++++++-        raw_pet = self.calc_pet()
++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
++++++++++++-        pet = np.clip(pet/6, -1, 1)
++++++++++++-
++++++++++++-        raw_ttc = self.calc_ttc()
++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
++++++++++++-        ttc = np.clip(ttc/7, -1, 1)
++++++++++++-
++++++++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
++++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
++++++++++++-
++++++++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
++++++++++++-        return returned
++++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
++++++++++++-        
++++++++++++-    def calc_drac(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        dracs = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            if hasattr(v, 'lane'):
++++++++++++-                leader, headway = v.leader()
++++++++++++-                v_speed = v.speed
++++++++++++-                leader_speed = leader.speed
++++++++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
++++++++++++-                dracs.append(drac)
++++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
++++++++++++-        return fleet_drac
++++++++++++-    
++++++++++++-    def calc_pet(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        pets = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            if hasattr(v, 'lane'):
++++++++++++-                leader, headway = v.leader()
++++++++++++-                v_speed = v.speed
++++++++++++-                if v_speed > 1e-16:
++++++++++++-                    pet = headway/(v_speed)
++++++++++++-                    pets.append(pet)
++++++++++++-        fleet_pet = np.nanmean(np.array(pets))
++++++++++++-        return fleet_pet
++++++++++++-
++++++++++++-    def calc_ttc(self):
++++++++++++-        cur_veh_list = self.ts.vehicles
++++++++++++-        ttcs = []
++++++++++++-        for v in cur_veh_list:
++++++++++++-            if hasattr(v, 'lane'):
++++++++++++-                leader, headway = v.leader()
++++++++++++-                v_speed = v.speed
++++++++++++-                leader_speed = leader.speed
++++++++++++-                if leader_speed < v_speed:
++++++++++++-                    ttc =  headway/(v_speed-leader_speed)
++++++++++++-                else:
++++++++++++-                    ttc = np.nan
++++++++++++-                ttcs.append(ttc)
++++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
++++++++++++-        return fleet_ttc
++++++++++++-
++++++++++++-    def append_step_info(self):
++++++++++++-        super().append_step_info()
++++++++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
++++++++++++-
++++++++++++-    @property
++++++++++++-    def stats(self):
++++++++++++-        c = self.c
++++++++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
++++++++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
++++++++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
++++++++++++-        stats['backlog_step'] = mean(info['backlog'])
++++++++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
++++++++++++-
++++++++++++-        stats['beta'] = c.beta
++++++++++++-
++++++++++++-        if c.multi_flowrate:
++++++++++++-            stats['flow_horizontal'] = c.flow_rate_h
++++++++++++-            stats['flow_vertical'] = c.flow_rate_v
++++++++++++-        return stats
++++++++++++-
++++++++++++-class Intersection(Main):
++++++++++++-    def create_env(c):
++++++++++++-        if c.multi_flowrate:
++++++++++++-            return NormEnv(c, IntersectionEnv(c))
++++++++++++-        else:
++++++++++++-            c._norm = NormEnv(c, None)
++++++++++++-            return IntersectionEnv(c)
++++++++++++-
++++++++++++-    @property
++++++++++++-    def observation_space(c):
++++++++++++-        low = np.full(c._n_obs, c.low)
++++++++++++-        return Box(low, np.ones_like(low))
++++++++++++-
++++++++++++-    @property
++++++++++++-    def action_space(c):
++++++++++++-        if c.act_type == 'accel':
++++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
++++++++++++-        else:
++++++++++++-            return Discrete(c.n_actions)
++++++++++++-
++++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
++++++++++++-        log = c.get_log_ii(ii, n_ii)
++++++++++++-        step_obs_ = rollout.obs
++++++++++++-        step_obs = step_obs_[:-1]
++++++++++++-
++++++++++++-        if not c.multi_flowrate:
++++++++++++-            rollout.raw_reward = rollout.reward
++++++++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
++++++++++++-
++++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
++++++++++++-
++++++++++++-        n_veh = np.array([len(o) for o in step_obs])
++++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
++++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
++++++++++++-
++++++++++++-        step_id_ = rollout.pop('id')
++++++++++++-        id = np.concatenate(step_id_[:-1])
++++++++++++-        id_unique = np.unique(id)
++++++++++++-
++++++++++++-        reward = np.array(rollout.pop('reward'))
++++++++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
++++++++++++-
++++++++++++-        log(**stats)
++++++++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
++++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
++++++++++++-        log(
++++++++++++-            n_veh_step_mean=n_veh.mean(), 
++++++++++++-            n_veh_step_sum=n_veh.sum(), 
++++++++++++-            n_veh_unique=len(id_unique),
++++++++++++-            
++++++++++++-            reward_mean=np.mean(reward),
++++++++++++-            reward_std=np.std(reward),        
++++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
++++++++++++-            ssm_mean=np.mean(rollout.ssm),
++++++++++++-            ssm_std=np.std(rollout.ssm),
++++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
++++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
++++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
++++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
++++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
++++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
++++++++++++-
++++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
++++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
++++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
++++++++++++-            # nom_action = np.mean(rollout.nom_action),
++++++++++++-            # res_action = np.mean(rollout.res_action),
++++++++++++-            )
++++++++++++-        
++++++++++++-        return rollout
++++++++++++-
++++++++++++-if __name__ == '__main__':
++++++++++++-    c = Intersection.from_args(globals(), locals())
++++++++++++-    c.setdefaults(
++++++++++++-        n_steps=200,
++++++++++++-        step_save=5,
++++++++++++-
++++++++++++-        depart_speed=0,
++++++++++++-        max_speed=13,
++++++++++++-        max_dist=100,
++++++++++++-        max_accel=1.5,
++++++++++++-        max_decel=3.5,
++++++++++++-        sim_step=0.5,
++++++++++++-        generic_type=True,
++++++++++++-        n_actions=3,
++++++++++++-
++++++++++++-        adv_norm=False,
++++++++++++-        batch_concat=True,
++++++++++++-
++++++++++++-        render=False,
++++++++++++-
++++++++++++-        warmup_steps=100,
++++++++++++-        horizon=2000,
++++++++++++-        directions='4way',
++++++++++++-        av_frac=0.15,
++++++++++++-        handcraft=False,
++++++++++++-        handcraft_tl=None,
++++++++++++-        flow_rate=700,
++++++++++++-        length=100,
++++++++++++-        n_rows=1,
++++++++++++-        n_cols=1,
++++++++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
++++++++++++-
++++++++++++-        act_type='accel_discrete',
++++++++++++-        low=-1,
++++++++++++-
++++++++++++-        alg=PG,
++++++++++++-        n_gds=1,
++++++++++++-        lr=1e-3,
++++++++++++-        gamma=0.99,
++++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
++++++++++++-
++++++++++++-        enter_length=False,
++++++++++++-        short_exit=False,
++++++++++++-
++++++++++++-        rew_type='outflow',
++++++++++++-        norm_reward=True,
++++++++++++-        center_reward=True,
++++++++++++-        multi_flowrate=False,
++++++++++++-        opt='RMSprop',
++++++++++++-
++++++++++++-        obs_tail=True,
++++++++++++-        obs_next_cross_platoons=1,
++++++++++++-
++++++++++++-        beta=0,
++++++++++++-        scale_pet=1,
++++++++++++-        scale_drac=1,
++++++++++++-        seed_np=False,
++++++++++++-        seed_torch = False,
++++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
++++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
++++++++++++-    )
++++++++++++-
++++++++++++-    if c.seed_torch:
++++++++++++-        # Set seed for PyTorch CPU operations
++++++++++++-        torch.manual_seed(c.seed_torch)
++++++++++++-        # Set seed for PyTorch CUDA operations (if available)
++++++++++++-        if torch.cuda.is_available():
++++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
++++++++++++-    if c.seed_np:
++++++++++++-        np.random.seed(c.seed_np)
++++++++++++-
++++++++++++-    if c.directions == '4way':
++++++++++++-        c.directions = ['up', 'right', 'down', 'left']
++++++++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
++++++++++++-    if c.mrtl:
++++++++++++-        c._n_obs += 1
++++++++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
++++++++++++-    c.redef_sumo = 'length_range' in c
++++++++++++-    c.run()
++++++++++++\ No newline at end of file
++++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/diff.txt b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++++index d4c3dac..d542fe6 100644
++++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++++@@ -1,600 +1,1348 @@
++++++++++++-diff --git a/README.md b/README.md
++++++++++++-index b591747..127f484 100644
++++++++++++---- a/README.md
++++++++++++-+++ b/README.md
++++++++++++-@@ -39,7 +39,7 @@ conda env create -f environment.yml
++++++++++++- ### 1.2 Set the environmental variables
++++++++++++- ```
++++++++++++- # Code directory
++++++++++++--export F=automatic_vehicular_control/automatic_vehicular_control
++++++++++++-+export F=automatic_vehicular_control
++++++++++++- 
++++++++++++- # Results directory extracted from the zip file
++++++++++++- export R=results
++++++++++++-@@ -48,10 +48,8 @@ export R=results
++++++++++++- ## 2. Directory Structure
++++++++++++- 
++++++++++++- The code directory structure is
++++++++++++--```
++++++++++++-+``` 
++++++++++++- automatic_vehicular_control/
++++++++++++--│
++++++++++++--├── automatic_vehicular_control/
++++++++++++- │   ├── __pycache__/                # Compiled Python files
++++++++++++- │   ├── evaluations/                # Evaluation results and metrics
++++++++++++- │   ├── models/                     # Model checkpoints
++++++++++++-diff --git a/env.py b/env.py
++++++++++++-index 4ab3d95..c83a674 100644
++++++++++++---- a/env.py
++++++++++++-+++ b/env.py
++++++++++++-@@ -724,9 +724,11 @@ class TrafficState:
++++++++++++-         self.external_lanes = Container((k, v) for k, v in lanes.items() if not k.startswith(':'))
++++++++++++- 
++++++++++++-         segments = {}
++++++++++++-+        
++++++++++++-         def add_from_to(from_, to):
++++++++++++-             from_.tos.add(to)
++++++++++++-             to.froms.add(from_)
++++++++++++-+            
++++++++++++-         for con in map(values_str_to_val, net.children('connection')):
++++++++++++-             from_lane = edges[con['from']].lanes[int(con.fromLane)]
++++++++++++-             to_lane = edges[con.to].lanes[int(con.toLane)]
++++++++++++-@@ -888,89 +890,109 @@ class TrafficState:
++++++++++++- 
++++++++++++-     def step(self):
++++++++++++-         """
++++++++++++--        Take a simulation step and update state
++++++++++++-+        Take a simulation step and update state.
++++++++++++-         """
+++++++++++++diff --git a/highway_bottleneck.py b/highway_bottleneck.py
+++++++++++++deleted file mode 100644
+++++++++++++index 6b9ba52..0000000
+++++++++++++--- a/highway_bottleneck.py
++++++++++++++++ /dev/null
+++++++++++++@@ -1,381 +0,0 @@
+++++++++++++-from automatic_vehicular_control.exp import *
+++++++++++++-from automatic_vehicular_control.env import *
+++++++++++++-from automatic_vehicular_control.u import *
+++++++++++++-
+++++++++++++-class BNeckEnv(Env):
+++++++++++++-    def def_sumo(self):
++++++++++++ -        c = self.c
++++++++++++--        tc = self.tc
++++++++++++--        subscribes = self.subscribes
++++++++++++-+        c = self.c  # Configuration object for the simulation
++++++++++++-+        tc = self.tc  # TraCI instance for interacting with SUMO simulation
++++++++++++-+        subscribes = self.subscribes  # Subscription definitions to get simulation data
++++++++++++- 
++++++++++++-         # Actual SUMO step
++++++++++++--        tc.simulationStep()
++++++++++++--        sim_res = subscribes.sim.get()
++++++++++++-+        tc.simulationStep()  # Advances the SUMO simulation by one step
++++++++++++-+        sim_res = subscribes.sim.get()  # Retrieve updated subscription results for this step
++++++++++++- 
++++++++++++-+        # Clear references to current vehicle edges and lanes for the next update
++++++++++++-         for veh in self.vehicles:
++++++++++++--            veh.unvar('edge', 'lane')
++++++++++++-+            veh.unvar('edge', 'lane')  # Remove 'edge' and 'lane' properties from vehicles (to update them later)
++++++++++++-+
++++++++++++-+        # Clear current vehicle data from edges and lanes
++++++++++++-         for ent in itertools.chain(self.edges, self.lanes):
++++++++++++--            ent.vehicles.clear()
++++++++++++--            ent.positions.clear()
++++++++++++-+            ent.vehicles.clear()  # Clear vehicles list on each edge/lane
++++++++++++-+            ent.positions.clear()  # Clear vehicle positions
++++++++++++- 
++++++++++++-+        # Update traffic light states
++++++++++++-         for tl_id, tl in self.traffic_lights.items():
++++++++++++--            tl.update(subscribes.tl.get(tl_id))
++++++++++++-+            tl.update(subscribes.tl.get(tl_id))  # Get traffic light states and update each traffic light object
++++++++++++- 
++++++++++++-+        # Handle loaded vehicles (those waiting to be inserted into the simulation)
++++++++++++-         for veh_id in sim_res.loaded_vehicles_ids:
++++++++++++--            flow_id, _ = veh_id.rsplit('.')
++++++++++++--            flow = self.flows[flow_id]
++++++++++++--            flow.backlog.add(veh_id)
++++++++++++-+            flow_id, _ = veh_id.rsplit('.')  # Extract the flow identifier from the vehicle ID
++++++++++++-+            flow = self.flows[flow_id]  # Get the corresponding flow object
++++++++++++-+            flow.backlog.add(veh_id)  # Add vehicle ID to backlog
++++++++++++- 
++++++++++++-+        # Initialize a set for newly departed vehicles
++++++++++++-         self.new_departed = set()
++++++++++++-+
++++++++++++-+        # Handle vehicles that have departed (entered the network)
++++++++++++-         for veh_id in sim_res.departed_vehicles_ids:
++++++++++++--            subscribes.veh.subscribe(veh_id)
++++++++++++--            type_id = tc.vehicle.getTypeID(veh_id)
++++++++++++--            # import pdb; pdb.set_trace()
++++++++++++-+            subscribes.veh.subscribe(veh_id)  # Subscribe to updates for the vehicle's state
++++++++++++-+            type_id = tc.vehicle.getTypeID(veh_id)  # Get vehicle type
++++++++++++-+            # If vehicle type is 'generic', compute specific type
++++++++++++-             if type_id == 'generic':
++++++++++++-                 type_id = self.compute_type(veh_id)
++++++++++++--            type_ = self.types[type_id]
++++++++++++--            route = self.routes[tc.vehicle.getRouteID(veh_id)]
++++++++++++--            length = tc.vehicle.getLength(veh_id)
++++++++++++--            road_id = tc.vehicle.getRoadID(veh_id)
++++++++++++--            self.vehicles[veh_id] = veh = Vehicle(id=veh_id, type=type_, route=route, length=length, road_id=road_id)
++++++++++++--            type_.vehicles.add(veh)
++++++++++++-+            type_ = self.types[type_id]  # Get vehicle type object
++++++++++++-+            route = self.routes[tc.vehicle.getRouteID(veh_id)]  # Get route object for the vehicle
++++++++++++-+            length = tc.vehicle.getLength(veh_id)  # Get vehicle length
++++++++++++-+            road_id = tc.vehicle.getRoadID(veh_id)  # Get current road ID for the vehicle
++++++++++++-+
++++++++++++-+            # Create a new vehicle object and add it to the list of vehicles
++++++++++++-+            self.vehicles[veh_id] = veh = Vehicle(
++++++++++++-+                id=veh_id, type=type_, route=route, length=length, road_id=road_id
++++++++++++-+            )
++++++++++++-+            type_.vehicles.add(veh)  # Add vehicle to its type's list of vehicles
++++++++++++- 
++++++++++++-+            # Set color if rendering is enabled
++++++++++++-             if c.render:
++++++++++++-                 color_fn = c.get('color_fn', lambda veh: RED if 'rl' in type_.id else WHITE)
++++++++++++--                self.set_color(veh, color_fn(veh))
++++++++++++-+                self.set_color(veh, color_fn(veh))  # Set vehicle color based on whether it is RL-controlled or not
++++++++++++- 
++++++++++++-+            # Set vehicle speed mode and lane change mode using SUMO settings
++++++++++++-             tc.vehicle.setSpeedMode(veh_id, c.get('speed_mode', SPEED_MODE.all_checks))
++++++++++++-             tc.vehicle.setLaneChangeMode(veh_id, c.get('lc_mode', LC_MODE.no_lat_collide))
++++++++++++-+
++++++++++++-+            # Add to new_departed set
++++++++++++-             self.new_departed.add(veh)
++++++++++++-+
++++++++++++-+            # Remove vehicle from backlog if necessary
++++++++++++-             if '.' in veh_id:
++++++++++++-                 flow_id, _ = veh_id.rsplit('.')
++++++++++++-                 if flow_id in self.flows:
++++++++++++-                     flow = self.flows[flow_id]
++++++++++++-                     flow.backlog.remove(veh_id)
++++++++++++- 
++++++++++++-+        # Handle newly arrived and collided vehicles
++++++++++++-         self.new_arrived = {self.vehicles[veh_id] for veh_id in sim_res.arrived_vehicles_ids}
++++++++++++-         self.new_collided = {self.vehicles[veh_id] for veh_id in sim_res.colliding_vehicles_ids}
++++++++++++-+        
++++++++++++-+        # Remove newly arrived vehicles from tracking if they collided
++++++++++++-         for veh in self.new_arrived:
++++++++++++--            veh.type.vehicles.remove(self.vehicles.pop(veh.id))
++++++++++++--        self.new_arrived -= self.new_collided # Don't count collided vehicles as "arrived"
++++++++++++-+            veh.type.vehicles.remove(self.vehicles.pop(veh.id))  # Remove vehicle from its type's list of vehicles
++++++++++++-+        self.new_arrived -= self.new_collided  # Do not count collided vehicles as "arrived"
++++++++++++- 
++++++++++++-+        # Update vehicle positions on edges and lanes
++++++++++++-         for veh_id, veh in self.vehicles.items():
++++++++++++--            veh.prev_speed = veh.get('speed', None)
++++++++++++--            veh.update(subscribes.veh.get(veh_id))
++++++++++++-+            veh.prev_speed = veh.get('speed', None)  # Store previous speed for later comparisons
++++++++++++-+            veh.update(subscribes.veh.get(veh_id))  # Update vehicle attributes from SUMO data
++++++++++++-             if veh_id not in sim_res.colliding_vehicles_ids:
++++++++++++--                edge = self.edges[veh.road_id]
++++++++++++--                edge.vehicles.append(veh)
++++++++++++--                veh.edge = edge
++++++++++++--            # veh.road_id=tc.vehicle.getRoadID(veh_id)          # i added this line only
++++++++++++--            # edge = self.edges[veh.road_id]
++++++++++++--            # edge.vehicles.append(veh)
++++++++++++--            # veh.edge = edge
++++++++++++-+                edge = self.edges[veh.road_id]  # Get the edge where the vehicle is located
++++++++++++-+                edge.vehicles.append(veh)  # Add vehicle to the edge's list of vehicles
++++++++++++-+                veh.edge = edge  # Set vehicle's edge attribute
++++++++++++- 
++++++++++++-+        # Update vehicle sorting and lane positions
++++++++++++-         for edge in self.edges:
++++++++++++--            edge.vehicles.sort(key=lambda veh: veh.laneposition)
++++++++++++--            edge.positions = [veh.laneposition for veh in edge.vehicles]
++++++++++++-+            edge.vehicles.sort(key=lambda veh: veh.laneposition)  # Sort vehicles based on position on the lane
++++++++++++-+            edge.positions = [veh.laneposition for veh in edge.vehicles]  # Store vehicle positions on this edge
++++++++++++-             for edge_i, veh in enumerate(edge.vehicles):
++++++++++++--                veh.edge_i = edge_i
++++++++++++--                veh.lane = lane = edge.lanes[veh.lane_index]
++++++++++++--                veh.lane_i = len(lane.vehicles)
++++++++++++--                lane.vehicles.append(veh)
++++++++++++--                lane.positions.append(veh.laneposition)
++++++++++++-+                veh.edge_i = edge_i  # Set the vehicle's index within the edge's vehicle list
++++++++++++-+                veh.lane = lane = edge.lanes[veh.lane_index]  # Set the lane object where the vehicle is located
++++++++++++-+                veh.lane_i = len(lane.vehicles)  # Set the vehicle's index in the lane's list of vehicles
++++++++++++-+                lane.vehicles.append(veh)  # Add vehicle to the lane's list of vehicles
++++++++++++-+                lane.positions.append(veh.laneposition)  # Add vehicle position to the lane
++++++++++++- 
++++++++++++-+        # Record sets of vehicles that have arrived, departed, or collided during this step
++++++++++++-         self.all_arrived.append(self.new_arrived)
++++++++++++-         self.all_departed.append(self.new_departed)
++++++++++++-         self.all_collided.append(self.new_collided)
++++++++++++--
++++++++++++-+            
++++++++++++-     def reset(self, tc):
++++++++++++-         self.tc = tc
++++++++++++-         self.subscribes.clear()
++++++++++++-@@ -1043,6 +1065,7 @@ class Env:
++++++++++++-     """
++++++++++++-     Offers a similar reinforcement learning environment interface as gym.Env
++++++++++++-     Wraps around a TrafficState (ts) and the SUMO traci (tc)
++++++++++++-+    c: Ring class
++++++++++++-     """
++++++++++++-     def __init__(self, c):
++++++++++++-         self.c = c.setdefaults(redef_sumo=False, warmup_steps=0, skip_stat_steps=0, skip_vehicle_info_stat_steps=True)
++++++++++++-@@ -1056,6 +1079,7 @@ class Env:
++++++++++++-             if c.get('save_agent'):
++++++++++++-                 self._agent_info = []
++++++++++++-         self._step = 0
++++++++++++-+        self.mean_speed = 0
++++++++++++- 
++++++++++++-     def def_sumo(self, *args, **kwargs):
++++++++++++-         """ Override this with code defining the SUMO network """
++++++++++++-@@ -1094,49 +1118,91 @@ class Env:
++++++++++++-         """
++++++++++++-         return True
++++++++++++- 
++++++++++++-+   # Method to reset or initialize the SUMO traffic simulation environment
++++++++++++-     def reset_sumo(self):
++++++++++++-+        # Shortcuts for configuration and SUMO definition objects
++++++++++++-         c = self.c
++++++++++++-         sumo_def = self.sumo_def
++++++++++++--
++++++++++++--        generate_def = c.redef_sumo or not sumo_def.sumo_cmd
++++++++++++-+        
++++++++++++-+        # Determine if new SUMO definitions need to be generated
++++++++++++-+        generate_def = c.redef_sumo or not sumo_def.sumo_cmd  # Either forced redefinition or missing SUMO command
++++++++++++-+        
++++++++++++-         if generate_def:
++++++++++++--            kwargs = self.def_sumo()
++++++++++++--            kwargs['net'] = sumo_def.generate_net(**kwargs)
++++++++++++--            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)
++++++++++++-+            # Generate new definitions if necessary
++++++++++++-+            kwargs = self.def_sumo()  # Obtain default arguments for SUMO setup
++++++++++++-+            kwargs['net'] = sumo_def.generate_net(**kwargs)  # Generate the network using SUMO
++++++++++++-+            sumo_def.sumo_cmd = sumo_def.generate_sumo(**kwargs)  # Generate the SUMO command using the arguments
++++++++++++-+        
++++++++++++-+        # Start SUMO with the current traffic controller (tc)
++++++++++++-         self.tc = sumo_def.start_sumo(self.tc)
++++++++++++-+        
++++++++++++-         if generate_def:
++++++++++++-+            # If new definitions were generated, store relevant SUMO file paths
++++++++++++-             self.sumo_paths = {k: p for k, p in kwargs.items() if k in SumoDef.file_args}
++++++++++++-+            
++++++++++++-+            # Load SUMO definitions from the generated file paths and initialize the traffic state
++++++++++++-             defs = {k: E.from_path(p) for k, p in self.sumo_paths.items()}
++++++++++++--            self.ts = TrafficState(c, self.tc, **defs)
++++++++++++-+            self.ts = TrafficState(c, self.tc, **defs)  # Create a new TrafficState object with the definitions
++++++++++++-         else:
++++++++++++-+            # If not generating new definitions, simply reset the existing traffic state
++++++++++++-             self.ts.reset(self.tc)
++++++++++++-+        
++++++++++++-+        # Set up the traffic state (e.g., initialize the simulation settings)
++++++++++++-         self.ts.setup()
++++++++++++-+        
++++++++++++-+        # Initialize the vehicles in the simulation (e.g., placing vehicles on the network)
++++++++++++-         success = self.init_vehicles()
++++++++++++-+        
++++++++++++-+        # Return whether the SUMO reset and vehicle initialization were successful
++++++++++++-         return success
++++++++++++- 
++++++++++++-+    # Method to initialize the environment after SUMO reset
++++++++++++-     def init_env(self):
++++++++++++-+        # Reference to the traffic state
++++++++++++-         ts = self.ts
++++++++++++-+    
++++++++++++-+        # Create an empty data structure to store rollout information
++++++++++++-         self.rollout_info = NamedArrays()
++++++++++++-+        
++++++++++++-+        # Turn off all traffic lights in the network
++++++++++++-         for tl in ts.traffic_lights:
++++++++++++--            ts.set_program(tl, 'off')
++++++++++++-+            ts.set_program(tl, 'off')  # Set the traffic light program to 'off'
++++++++++++-+        
++++++++++++-+        # Reset the step counter to 0
++++++++++++-         self._step = 0
++++++++++++-+        
++++++++++++-+        # Take the first step in the simulation
++++++++++++-         ret = self.step()
++++++++++++-+        
++++++++++++-+        # Run the simulation for a number of warmup steps
++++++++++++-         for _ in range(self.c.warmup_steps):
++++++++++++--            ret = self.step()
++++++++++++-+            ret = self.step()  # Advance the simulation one step
++++++++++++-+            
++++++++++++-+            # If the simulation ends during the warmup phase, return None to indicate failure
++++++++++++-             if ret[2] if isinstance(ret, tuple) else ret.get('done'):
++++++++++++-                 return None
++++++++++++-+        
++++++++++++-+        # After warmup, turn traffic lights back on (set to a defined program '1')
++++++++++++-         for tl in ts.traffic_lights:
++++++++++++--            ts.set_program(tl, '1')
++++++++++++-+            ts.set_program(tl, '1')  # Set traffic light program to '1' (likely normal operation)
++++++++++++-+        
++++++++++++-+        # Return the observation from the step, either as the first element of a tuple or a filtered dictionary
++++++++++++-         if isinstance(ret, tuple):
++++++++++++--            return ret[0]
++++++++++++--        return {k: v for k, v in ret.items() if k in ['obs', 'id']}
++++++++++++--
++++++++++++-+            return ret[0]  # If the result is a tuple, return the first element (likely the observation)
++++++++++++-+        return {k: v for k, v in ret.items() if k in ['obs', 'id']}  # Otherwise, return a dictionary with 'obs' and 'id'
++++++++++++-+        
++++++++++++-+    # Reset the entire environment, retrying until successful
++++++++++++-     def reset(self):
++++++++++++--        while True:
++++++++++++-+        self.mean_speed = 0
++++++++++++-+        while True:  # Infinite loop until the environment is successfully reset
++++++++++++-+            # Attempt to reset the SUMO simulation
++++++++++++-             if not self.reset_sumo():
+++++++++++++-        nodes = E('nodes',
+++++++++++++-            E('node', id='n_0', x=0, y=0), *(
+++++++++++++-            E('node', id=f'n_{1 + i}', x=x, y=0, type='zipper', radius=20) for i, x in enumerate(np.cumsum(c.edge_lengths))
+++++++++++++-        ))
+++++++++++++-        edges = E('edges', *(
+++++++++++++-            E('edge', **{'id': f'e_{i}', 'from': f'n_{i}', 'to': f'n_{i + 1}', 'spreadType': 'center',
+++++++++++++-                'numLanes': n_lane,
+++++++++++++-                'speed': c.max_speed
+++++++++++++-            }) for i, n_lane in enumerate(c.n_lanes)
+++++++++++++-        ))
+++++++++++++-        connections = E('connections', *(
+++++++++++++-            E('connection', **{
+++++++++++++-                'from': prev.id,
+++++++++++++-                'to': curr.id,
+++++++++++++-                'fromLane': i,
+++++++++++++-                'toLane': int(i / prev.numLanes * curr.numLanes)
+++++++++++++-            }) for prev, curr in zip(edges, edges[1:]) for i in range(prev.numLanes)
+++++++++++++-        ))
+++++++++++++-
+++++++++++++-        if c.split_flow:
+++++++++++++-            n_inflow_lanes = c.n_lanes[0]
+++++++++++++-            flows = [E('flow', **FLOW(f'f_{i}', type='generic', route='route',
+++++++++++++-                departSpeed=c.depart_speed, departLane=i, vehsPerHour=c.flow_rate // n_inflow_lanes))
+++++++++++++-                for i in range(n_inflow_lanes)
+++++++++++++-            ]
+++++++++++++-        else:
+++++++++++++-            flows = [E('flow', **FLOW(f'f', type='generic', route='route',
+++++++++++++-                departSpeed=c.depart_speed, departLane='random', vehsPerHour=c.flow_rate))
+++++++++++++-            ]
+++++++++++++-        routes = E('routes',
+++++++++++++-            E('route', id='route', edges=' '.join(str(x.id) for x in edges)),
+++++++++++++-            *flows
+++++++++++++-        )
+++++++++++++-        idm_params = {**IDM, **LC2013, 'accel': c.max_accel, 'decel': c.max_decel, 'tau': c.tau, 'minGap': c.min_gap, 'maxSpeed': c.max_speed, 'delta': c.delta}
+++++++++++++-        additional = E('additional',
+++++++++++++-            E('vType', id='generic', **idm_params),
+++++++++++++-            E('vType', id='rl', **idm_params),
+++++++++++++-            E('vType', id='human', **idm_params),
+++++++++++++-        )
+++++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++++++++-
+++++++++++++-    def reset_sumo(self):
+++++++++++++-        c = self.c
+++++++++++++-        if c.flow_rate_range:
+++++++++++++-            c.flow_rate = np.random.randint(*c.flow_rate_range)
+++++++++++++-        ret = super().reset_sumo()
+++++++++++++-        if c.vinitsky:
+++++++++++++-            self.obs_lanes = [(lane, i_start * c.piece_length)
+++++++++++++-                for edge in self.ts.routes.route.edges if not edge.id.startswith(':')
+++++++++++++-                for i_start in range(round(edge.length) // c.piece_length)
+++++++++++++-                for lane in edge.lanes
+++++++++++++-            ]
+++++++++++++-            self.control_lanes = {(lane, piece_start): c.max_speed for lane, piece_start in self.obs_lanes[:-1]}
+++++++++++++-            self.last_outflows = []
+++++++++++++-        return ret
+++++++++++++-
+++++++++++++-    def step(self, action=[]):
+++++++++++++-        c = self.c
+++++++++++++-        ts = self.ts
+++++++++++++-        max_dist = 100
+++++++++++++-        max_speed = c.max_speed
+++++++++++++-        human_type = ts.types.human
+++++++++++++-        rl_type = ts.types.rl
+++++++++++++-
+++++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++++++-        if c.vinitsky:
+++++++++++++-            if len(action):
+++++++++++++-                assert len(action) == len(self.control_lanes)
+++++++++++++-                for (lane, piece_start), act in zip(self.control_lanes, action):
+++++++++++++-                    self.control_lanes[lane, piece_start] = np.clip(
+++++++++++++-                        self.control_lanes[lane, piece_start] + act * (c.max_accel if act > 0 else c.max_decel),
+++++++++++++-                        0.1, max_speed
+++++++++++++-                    )
+++++++++++++-                for veh in prev_rls:
+++++++++++++-                    lane, piece_start = veh.lane, veh.laneposition // c.piece_length * c.piece_length
+++++++++++++-                    ts.set_max_speed(veh, self.control_lanes.get((lane, piece_start), max_speed))
+++++++++++++-        else:
+++++++++++++-            for veh, act in zip(prev_rls, action):
+++++++++++++-                if c.handcraft:
+++++++++++++-                    route, edge, lane = veh.route, veh.edge, veh.lane
+++++++++++++-                    next_lane = lane.next(veh.route)
+++++++++++++-                    level = 1
+++++++++++++-                    if next_lane and next_lane.get('junction'):
+++++++++++++-                        merge_dist = lane.length - veh.laneposition
+++++++++++++-                        if merge_dist < c.handcraft:
+++++++++++++-                            other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++++++++-                            other_veh, offset = other_lane.prev_vehicle(veh.laneposition)
+++++++++++++-                            if other_veh and offset + merge_dist < 30 and other_veh.type is human_type:
+++++++++++++-                                level = 0
+++++++++++++-                    if c.act_type.startswith('accel'):
+++++++++++++-                        ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++++-                    else:
+++++++++++++-                        ts.set_max_speed(veh, max_speed * level)
+++++++++++++-                    continue
+++++++++++++-                if not isinstance(act, (int, np.integer)):
+++++++++++++-                    act = (act - c.low) / (1 - c.low)
+++++++++++++-                if c.act_type.startswith('accel'):
+++++++++++++-                    level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++++++++-                    ts.accel(veh, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++++-                else:
+++++++++++++-                    if c.act_type == 'continuous':
+++++++++++++-                        level = act[0]
+++++++++++++-                    elif c.act_type == 'discretize':
+++++++++++++-                        level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++++++++-                    elif c.act_type == 'discrete':
+++++++++++++-                        level = act / (c.n_actions - 1)
+++++++++++++-                    ts.set_max_speed(veh, max_speed * level)
+++++++++++++-
+++++++++++++-                if c.lc_av == 'binary' and act[1] > 0.5:
+++++++++++++-                    ts.lane_change(veh, -1 if veh.lane_index % 2 else +1)
+++++++++++++-
+++++++++++++-        super().step()
+++++++++++++-
+++++++++++++-        if c.vinitsky:
+++++++++++++-            n_last_outflows = 20
+++++++++++++-            max_vehs = 4
+++++++++++++-            max_veh_outflows = np.ceil(c.sim_step * c.max_speed / 5) # 5 is the vehicle length
+++++++++++++-            obs = []
+++++++++++++-            for lane, piece_start in self.obs_lanes:
+++++++++++++-                piece_end = piece_start + c.piece_length
+++++++++++++-                lane_vehs = [veh for veh in lane.vehicles if piece_start <= veh.laneposition < piece_end]
+++++++++++++-                lane_avs = [v for v in lane_vehs if v.type is rl_type]
+++++++++++++-                lane_humans = [v for v in lane_vehs if v.type is human_type]
+++++++++++++-                obs.extend([
+++++++++++++-                    len(lane_humans) / max_vehs,
+++++++++++++-                    len(lane_avs) / max_vehs,
+++++++++++++-                    np.mean([v.speed for v in lane_humans]) / max_speed if len(lane_humans) else 0,
+++++++++++++-                    np.mean([v.speed for v in lane_avs]) / max_speed if len(lane_avs) else 0,
+++++++++++++-                ])
+++++++++++++-            if len(self.last_outflows) == n_last_outflows:
+++++++++++++-                self.last_outflows = self.last_outflows[1:]
+++++++++++++-            self.last_outflows.append(len(ts.new_arrived))
+++++++++++++-            reward = np.mean(self.last_outflows)
+++++++++++++-            obs.append(reward / max_veh_outflows)
+++++++++++++-            obs = np.array(obs, dtype=np.float32)
+++++++++++++-            assert 0 <= obs.min() and obs.max() <= 1
+++++++++++++-            return obs, reward, False, None
+++++++++++++-        route = nexti(ts.routes)
+++++++++++++-        obs, ids = [], []
+++++++++++++-        default_close = [0, max_speed]
+++++++++++++-        default_far = [max_dist, 0]
+++++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++++++++-            speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++++++++-            merge_dist = max_dist
+++++++++++++-            default_human = default_far
+++++++++++++-
+++++++++++++-            other_info = {}
+++++++++++++-            next_lane = lane.next(veh.route)
+++++++++++++-            if next_lane and next_lane.get('junction'):
+++++++++++++-                merge_dist = lane.length - veh.laneposition
+++++++++++++-                other_lane = edge.lanes[lane.index - 1 if lane.index % 2 else lane.index + 1]
+++++++++++++-                pos = other_lane.length if c.veh_junction else veh.laneposition
+++++++++++++-                # Look for veh on other lane but do not extend past that lane
+++++++++++++-                for other_veh, offset in other_lane.prev_vehicles(pos, route=None):
+++++++++++++-                    other_info.setdefault(other_veh.type, [offset + other_lane.length - pos, other_veh.speed])
+++++++++++++-                    if other_veh.type is rl_type:
+++++++++++++-                        default_human = default_close
+++++++++++++-                        break
+++++++++++++-
+++++++++++++-            obs.append([merge_dist, speed] + other_info.get(human_type, default_human) + other_info.get(rl_type, default_far))
+++++++++++++-            ids.append(veh.id)
+++++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([max_dist, max_speed] * 3)
+++++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++++++-        
+++++++++++++-        theoretical_outnum = c.flow_rate/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++++++-
+++++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++++++-
+++++++++++++-        raw_pet = self.calc_pet()
+++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++++++-        pet = np.clip(pet, -1, 1)
+++++++++++++-
+++++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++++++-        
+++++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++++++-        return returned
+++++++++++++-        
+++++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++++++-    
+++++++++++++-    def calc_ttc(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        ttcs = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            leader, headway = v.leader()
+++++++++++++-            v_speed = v.speed
+++++++++++++-            leader_speed = leader.speed
+++++++++++++-            if leader_speed < v_speed:
+++++++++++++-                ttc =  headway/(v_speed-leader_speed)
+++++++++++++-            else:
+++++++++++++-                ttc = np.nan
+++++++++++++-            ttcs.append(ttc)
+++++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++++++-        return fleet_ttc
+++++++++++++-    
+++++++++++++-    def calc_drac(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        dracs = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            leader, headway = v.leader()
+++++++++++++-            v_speed = v.speed
+++++++++++++-            leader_speed = leader.speed
+++++++++++++-            drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++++++-            dracs.append(drac)
+++++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++++++-        return fleet_drac
+++++++++++++-
+++++++++++++-    def calc_pet(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        pets = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            leader, headway = v.leader()
+++++++++++++-            v_speed = v.speed
+++++++++++++-            if v_speed > 1e-16:
+++++++++++++-                pet = headway/(v_speed)
+++++++++++++-                pets.append(pet)
+++++++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++++++-        return fleet_pet
+++++++++++++-
+++++++++++++-class BNeck(Main):
+++++++++++++-    def create_env(c):
+++++++++++++-        return BNeckEnv(c)
+++++++++++++-
+++++++++++++-    @property
+++++++++++++-    def observation_space(c):
+++++++++++++-        low = np.full(c._n_obs, c.low)
+++++++++++++-        return Box(low, np.ones_like(low))
+++++++++++++-
+++++++++++++-    @property
+++++++++++++-    def action_space(c):
+++++++++++++-        if c.vinitsky:
+++++++++++++-            return Box(low=-1, high=1, shape=(c._n_action,), dtype=np.float32)
+++++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++++++++-            assert c.lc_av in [False, 'binary']
+++++++++++++-            return Box(low=c.low, high=1, shape=(1 + bool(c.lc_av),), dtype=np.float32)
+++++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++++++++-            return Discrete(c.n_actions)
+++++++++++++-
+++++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++++++-        if c.vinitsky:
+++++++++++++-            return super().on_rollout_end(rollout, stats, ii=n_ii)
+++++++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++++++-        step_obs_ = rollout.obs
+++++++++++++-        step_obs = step_obs_[:-1]
+++++++++++++-
+++++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++++++-
+++++++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++++++-
+++++++++++++-        step_id_ = rollout.pop('id')
+++++++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++++++-        id_unique = np.unique(id)
+++++++++++++-
+++++++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++++++-
+++++++++++++-        log(**stats)
+++++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++++++-        log(
+++++++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++++++-            n_veh_unique=len(id_unique),
+++++++++++++-            
+++++++++++++-            reward_mean=np.mean(reward),
+++++++++++++-            reward_std=np.std(reward),        
+++++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++++-
+++++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++++++-            )
+++++++++++++-        return rollout
+++++++++++++-
+++++++++++++-if __name__ == '__main__':
+++++++++++++-    c = BNeck.from_args(globals(), locals()).setdefaults(
+++++++++++++-        warmup_steps=1000,
+++++++++++++-        horizon=2000,
+++++++++++++-        n_steps=100,
+++++++++++++-        step_save=5,
+++++++++++++-
+++++++++++++-        av_frac=0.2,
+++++++++++++-        sim_step=0.5,
+++++++++++++-        depart_speed=0,
+++++++++++++-        edge_lengths=[100, 100, 50],
+++++++++++++-        n_lanes=[4, 2, 1],
+++++++++++++-        max_speed=30,
+++++++++++++-
+++++++++++++-        lc_av=False,
+++++++++++++-        flow_rate=2300,
+++++++++++++-        flow_rate_range=None,
+++++++++++++-        split_flow=True,
+++++++++++++-        generic_type='rand',
+++++++++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++++++++-        lc_mode=LC_MODE.off,
+++++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++++++-
+++++++++++++-        veh_junction=False,
+++++++++++++-        act_type='accel_discrete',
+++++++++++++-        max_accel=2.6,
+++++++++++++-        max_decel=4.5,
+++++++++++++-        tau=1.0,
+++++++++++++-        min_gap=2.5,
+++++++++++++-        delta=4,
+++++++++++++-        n_actions=3,
+++++++++++++-        low=-1,
+++++++++++++-        handcraft=False,
+++++++++++++-        vinitsky=False,
+++++++++++++-
+++++++++++++-        render=False,
+++++++++++++-
+++++++++++++-        alg=PG,
+++++++++++++-        lr=1e-3,
+++++++++++++-
+++++++++++++-        gamma=0.99,
+++++++++++++-        adv_norm=False,
+++++++++++++-        batch_concat=True,
+++++++++++++-
+++++++++++++-        beta=0,
+++++++++++++-        scale_ttc=1,
+++++++++++++-        scale_drac=1,
+++++++++++++-        seed_np=False,
+++++++++++++-        seed_torch = False,
+++++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++++++-
+++++++++++++-    )
+++++++++++++-    
+++++++++++++-    if c.seed_torch:
+++++++++++++-        # Set seed for PyTorch CPU operations
+++++++++++++-        torch.manual_seed(c.seed_torch)
+++++++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++++++-        if torch.cuda.is_available():
+++++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++++++-    if c.seed_np:
+++++++++++++-        np.random.seed(c.seed_np)
+++++++++++++-        
+++++++++++++-    if c.vinitsky:
+++++++++++++-        c.piece_length = 20
+++++++++++++-        bneck_lengths = [20] + [40] * (len(c.edge_lengths) - 2) + [20]
+++++++++++++-        n_actions = [(L - Lb) // c.piece_length * n for L, Lb, n in zip(c.edge_lengths, bneck_lengths, c.n_lanes)]
+++++++++++++-        c._n_action = sum(n_actions[:-1])
+++++++++++++-        c._n_obs = sum(n_actions) * 4 + 1
+++++++++++++-        c.batch_concat = False
+++++++++++++-    else:
+++++++++++++-        c._n_obs = 2 + 2 + 2
+++++++++++++-        
+++++++++++++-    if c.mrtl:
+++++++++++++-        c._n_obs += 1 # modified for mrtl related
+++++++++++++-        
+++++++++++++-    c.redef_sumo = bool(c.flow_rate_range)
+++++++++++++-    c.run()
+++++++++++++\ No newline at end of file
+++++++++++++diff --git a/highway_ramp.py b/highway_ramp.py
+++++++++++++deleted file mode 100644
+++++++++++++index ef0358f..0000000
+++++++++++++--- a/highway_ramp.py
++++++++++++++++ /dev/null
+++++++++++++@@ -1,325 +0,0 @@
+++++++++++++-from automatic_vehicular_control.exp import *
+++++++++++++-from automatic_vehicular_control.env import *
+++++++++++++-from automatic_vehicular_control.u import *
+++++++++++++-
+++++++++++++-class RampEnv(Env):
+++++++++++++-    # https://flow-project.github.io/papers/08569485.pdf
+++++++++++++-    def def_sumo(self):
+++++++++++++-        c = self.c
+++++++++++++-        builder = NetBuilder()
+++++++++++++-        nodes = builder.add_nodes(Namespace(x=x, y=y) for x, y in [
+++++++++++++-            (0, 0),
+++++++++++++-            (c.premerge_distance, 0),
+++++++++++++-            (c.premerge_distance + c.merge_distance, 0),
+++++++++++++-            (c.premerge_distance + c.merge_distance + c.postmerge_distance, 0),
+++++++++++++-            (c.premerge_distance - 100 * np.cos(np.pi / 4), -100 * np.sin(np.pi / 4))
+++++++++++++-        ])
+++++++++++++-        builder.chain(nodes[[0, 1, 2, 3]], edge_attrs=[
+++++++++++++-            {}, {'numLanes': 2}, {}
+++++++++++++-        ], lane_maps=[
+++++++++++++-            {0: 1}, {0: 0, 1: 0}
+++++++++++++-        ], route_id='highway')
+++++++++++++-        builder.chain(nodes[[4, 1, 2, 3]], edge_attrs=[
+++++++++++++-            {}, {'numLanes': 2}, {}
+++++++++++++-        ], lane_maps=[
+++++++++++++-            {0: 0}, {0: 0, 1: 0}
+++++++++++++-        ], route_id='ramp')
+++++++++++++-        nodes, edges, connections, routes = builder.build()
+++++++++++++-        nodes[2].type = 'zipper'
+++++++++++++-
+++++++++++++-        routes = E('routes',
+++++++++++++-            *routes,
+++++++++++++-            E('flow', **FLOW(f'f_highway', type='generic', route='highway', departSpeed=c.highway_depart_speed, vehsPerHour=c.highway_flow_rate)),
+++++++++++++-            E('flow', **FLOW(f'f_ramp', type='human', route='ramp', departSpeed=c.ramp_depart_speed, vehsPerHour=c.ramp_flow_rate))
+++++++++++++-        )
+++++++++++++-        idm = {**IDM, **dict(accel=1, decel=1.5, minGap=2)}
+++++++++++++-        additional = E('additional',
+++++++++++++-            E('vType', id='generic', **idm),
+++++++++++++-            E('vType', id='rl', **idm),
+++++++++++++-            E('vType', id='human', **idm),
+++++++++++++-        )
+++++++++++++-        sumo_args = {'collision.action': COLLISION.remove}
+++++++++++++-        return super().def_sumo(nodes, edges, connections, routes, additional, sumo_args=sumo_args)
+++++++++++++-
+++++++++++++-    def step(self, action=[]):
+++++++++++++-        c = self.c
+++++++++++++-        ts = self.ts
+++++++++++++-        max_dist = (c.premerge_distance + c.merge_distance) if c.global_obs else 100
+++++++++++++-        max_speed = c.max_speed
+++++++++++++-        human_type = ts.types.human
+++++++++++++-        rl_type = ts.types.rl
+++++++++++++-
+++++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++++++-        for rl, act in zip(prev_rls, action):
+++++++++++++-            if c.handcraft:
+++++++++++++-                route, edge, lane = rl.route, rl.edge, rl.lane
+++++++++++++-                leader, dist = rl.leader()
+++++++++++++-                level = 1
+++++++++++++-                if edge.id == 'e_n_0.0_n_400.0':
+++++++++++++-                    if rl.laneposition < 100:
+++++++++++++-                        leaders = list(rl.leaders())
+++++++++++++-                        if len(leaders) > 20:
+++++++++++++-                            level = 0
+++++++++++++-                        else:
+++++++++++++-                            level = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+++++++++++++-                        ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
++++++++++++ -                continue
++++++++++++-+                continue  # If reset_sumo fails, retry the loop
++++++++++++-+            
++++++++++++-+            # Initialize the environment. If initialization is successful (obs is not None), return the observation
++++++++++++-             if (obs := self.init_env()) is not None:
++++++++++++--                return obs
++++++++++++-+                return obs  # Successfully initialized, return the observation
++++++++++++-+
++++++++++++- 
++++++++++++-     def append_step_info(self):
++++++++++++-         """
++++++++++++-@@ -1231,6 +1297,8 @@ class Env:
++++++++++++- class NormEnv(gym.Env):
++++++++++++-     """
++++++++++++-     Reward normalization with running average https://github.com/joschu/modular_rl
++++++++++++-+    self.c: Ring parameters 
++++++++++++-+    self.env: RingEnv class
++++++++++++-     """
++++++++++++-     def __init__(self, c, env):
++++++++++++-         self.c = c.setdefaults(norm_obs=False, norm_reward=False, center_reward=False, reward_clip=np.inf, obs_clip=np.inf)
++++++++++++-diff --git a/exp.py b/exp.py
++++++++++++-index ead4652..7f7cee5 100644
++++++++++++---- a/exp.py
++++++++++++-+++ b/exp.py
++++++++++++-@@ -169,9 +169,9 @@ class Main(Config):
++++++++++++- 
++++++++++++-     def on_train_start(c):
++++++++++++-         # Initialize training: environment, algorithm, model, optimizer, and logging
++++++++++++--        c.setdefaults(alg='Algorithm')
++++++++++++--        c._env = c.create_env()
++++++++++++--
++++++++++++-+        c.setdefaults(alg='Algorithm') 
++++++++++++-+        c._env = c.create_env() # Create NormEnv
++++++++++++-+ 
++++++++++++-         # Instantiate the algorithm (e.g., PPO, DQN)
++++++++++++-         c._alg = (eval(c.alg) if isinstance(c.alg, str) else c.alg)(c)
++++++++++++-         c.set_model()
++++++++++++-@@ -222,8 +222,8 @@ class Main(Config):
++++++++++++- 
++++++++++++-     def on_step_start(c, stats={}):
++++++++++++-         # Update the learning rate and log stats at the start of a training step
++++++++++++--        lr = c._lr
++++++++++++--        for g in c._opt.param_groups:
++++++++++++-+        lr = c._lr # Update Learning Rate
++++++++++++-+        for g in c._opt.param_groups: # Log Statistics
++++++++++++-             g['lr'] = float(lr)
++++++++++++-         c.log_stats(dict(**stats, **c._alg.on_step_start(), lr=lr))
++++++++++++- 
++++++++++++-@@ -285,10 +285,14 @@ class Main(Config):
++++++++++++-             ret = dict(obs=ret)
++++++++++++-         rollout = NamedArrays()
++++++++++++-         rollout.append(**ret)
++++++++++++--
++++++++++++-+        rollout_flow_each_step = []
++++++++++++-         done = False
++++++++++++-         a_space = c.action_space
++++++++++++-         step = 0
++++++++++++-+        density = 20/(250*1e-3)
++++++++++++-+        vehicle_flow = c._env.mean_speed * 3.6 * density 
++++++++++++-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at new episode")
++++++++++++-+
++++++++++++-         while step < c.horizon + c.skip_stat_steps and not done:
++++++++++++-             # Generate an action from the model's policy
++++++++++++-             pred = from_torch(c._model(to_torch(rollout.obs[-1]), value=False, policy=True, argmax=False))
++++++++++++-@@ -309,6 +313,12 @@ class Main(Config):
++++++++++++-             rollout.append(**ret)
++++++++++++-             step += 1
++++++++++++-         # Collect stats from the environment
++++++++++++-+        # rollout_flow_each_step.append(len(c._env.passed_vehicle))
++++++++++++-+        # Flow= (Number of vehicles passing a point×3600) / Simulation Time (seconds) 
++++++++++++-+        density = 20/(250 * 1e-3)
++++++++++++-+        vehicle_flow = c._env.mean_speed * density 
++++++++++++-+        print(f"Current vehicle flow: {vehicle_flow:.2f} at step : {step:.2f}")
++++++++++++-+
++++++++++++-         stats = dict(rollout_time=time() - t_start, **c.get_env_stats())
++++++++++++-         return rollout, stats
++++++++++++- 
++++++++++++-@@ -398,10 +408,10 @@ class Main(Config):
++++++++++++-         # Main training loop
++++++++++++-         c.on_train_start()
++++++++++++-         while c._i < c.n_steps:
++++++++++++--            c.on_step_start()
++++++++++++-+            c.on_step_start() # save stat 
++++++++++++-             with torch.no_grad():
++++++++++++-                 # Collect rollouts without computing gradients
++++++++++++--                rollouts = c.rollouts()
++++++++++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
++++++++++++-             gd_stats = {}
++++++++++++-             if len(rollouts.obs):
++++++++++++-                 t_start = time()
++++++++++++-@@ -410,7 +420,7 @@ class Main(Config):
++++++++++++-                 gd_stats.update(gd_time=time() - t_start)
++++++++++++-             c.on_step_end(gd_stats)
++++++++++++-             c._i += 1
++++++++++++--        c.on_step_start()  # last step
++++++++++++-+        c.on_step_start()  # save stat
++++++++++++-         gd_stats = {}
++++++++++++-         with torch.no_grad():
++++++++++++-             rollouts = c.rollouts()
++++++++++++-@@ -450,6 +460,8 @@ class Main(Config):
++++++++++++-         if hasattr(c._env, 'close'):
++++++++++++-             c._env.close()
++++++++++++- 
++++++++++++-+  
++++++++++++-+
++++++++++++-     def run(c):
++++++++++++-         # Determine whether to train or evaluate based on configuration
++++++++++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
++++++++++++-diff --git a/ring.py b/ring.py
++++++++++++-index 94d632d..ee1372b 100644
++++++++++++---- a/ring.py
++++++++++++-+++ b/ring.py
++++++++++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
++++++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++++++++-         )
++++++++++++--
++++++++++++-         # Function to generate the shape of the edges (circular arcs)
++++++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++++++- 
++++++++++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
++++++++++++-         if c.circumference_range:  # Check if the circumference should be randomized
++++++++++++-             # Randomly set the circumference within the specified range
++++++++++++-             c.circumference = np.random.randint(*c.circumference_range)
++++++++++++-+        
++++++++++++-+        if self.flow_log:
++++++++++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
++++++++++++-+            self.episode_flow.append(average_flow)
++++++++++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
++++++++++++-+        
++++++++++++-+        # Reset flow counters for the new episode
++++++++++++-+        self.flow_counter = 0
++++++++++++-+        self.flow_log = []
++++++++++++-+        self.last_vehicle_times = {}
++++++++++++-+        
++++++++++++-         return super().reset_sumo()  # Reset the simulation
++++++++++++- 
++++++++++++-     @property
++++++++++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
++++++++++++-         }
++++++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++++++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
++++++++++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
++++++++++++-         return stats
++++++++++++--
++++++++++++-+    
++++++++++++-+    def calculate_flow(self):
++++++++++++-+        """
++++++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++++++++-+        """
++++++++++++-+        current_time = self.ts.time
++++++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++++++++-+
++++++++++++-+        for vehicle in vehicles_on_edge:
++++++++++++-+            # Check if vehicle has passed the observation point since the last timestep
++++++++++++-+            if vehicle.id not in self.last_vehicle_times:
++++++++++++-+                # If the vehicle was not previously recorded, count it as a new passage
++++++++++++-+                self.flow_counter += 1
++++++++++++-+            else:
++++++++++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
++++++++++++-+                last_time = self.last_vehicle_times[vehicle.id]
++++++++++++-+                if current_time - last_time > self.c.sim_step:
++++++++++++-+                    self.flow_counter += 1
++++++++++++-+
++++++++++++-+            # Update the last time the vehicle passed the point
++++++++++++-+            self.last_vehicle_times[vehicle.id] = current_time
++++++++++++-+
++++++++++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
++++++++++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
++++++++++++-+        self.flow_log.append(flow_per_hour)
++++++++++++-+        return flow_per_hour
++++++++++++-+    
++++++++++++-     def step(self, action=None):
++++++++++++-         c = self.c  # Configuration object
++++++++++++-         ts = self.ts  # Time step object
++++++++++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
++++++++++++-                     # Change to a specific lane
++++++++++++-                     ts.lane_change_to(rl, lc)
++++++++++++- 
++++++++++++-+        # Calculate flow at the end of each step
++++++++++++-+        flow = self.calculate_flow()
++++++++++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
++++++++++++-+        
++++++++++++-         super().step()  # Advance the simulation by one step
++++++++++++- 
++++++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++++++-            if not isinstance(act, (int, np.integer)):
+++++++++++++-                act = (act - c.low) / (1 - c.low)
+++++++++++++-            if c.act_type.startswith('accel'):
+++++++++++++-                level = act[0] if c.act_type == 'accel' else act / (c.n_actions - 1)
+++++++++++++-                ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++++-            else:
+++++++++++++-                if c.act_type == 'continuous':
+++++++++++++-                    level = act[0]
+++++++++++++-                elif c.act_type == 'discretize':
+++++++++++++-                    level = min(int(act[0] * c.n_actions), c.n_actions - 1) / (c.n_actions - 1)
+++++++++++++-                elif c.act_type == 'discrete':
+++++++++++++-                    level = act / (c.n_actions - 1)
+++++++++++++-                ts.set_max_speed(rl, max_speed * level)
+++++++++++++-
+++++++++++++-        super().step()
+++++++++++++-
+++++++++++++-        route = ts.routes.highway
+++++++++++++-        obs, ids = [], []
+++++++++++++-        for veh in sorted(rl_type.vehicles, key=lambda v: v.id):
+++++++++++++-            if hasattr(veh, 'edge'):
+++++++++++++-                speed, edge, lane = veh.speed, veh.edge, veh.lane
+++++++++++++-                merge_dist = max_dist
+++++++++++++-
+++++++++++++-                lead_speed = follow_speed = other_speed = 0
+++++++++++++-                other_follow_dist = other_merge_dist = lead_dist = follow_dist = max_dist
+++++++++++++-
+++++++++++++-                leader, dist = veh.leader()
+++++++++++++-                if leader: lead_speed, lead_dist = leader.speed, dist
+++++++++++++-
+++++++++++++-                follower, dist = veh.follower()
+++++++++++++-                if follower: follow_speed, follow_dist = follower.speed, dist
+++++++++++++-
+++++++++++++-                if c.global_obs:
+++++++++++++-                    jun_edge = edge.next(route)
+++++++++++++-                    while jun_edge and not (len(jun_edge.lanes) == 2 and jun_edge.lanes[0].get('junction')):
+++++++++++++-                        jun_edge = jun_edge.next(route)
+++++++++++++-                    if jun_edge:
+++++++++++++-                        merge_dist = lane.length - veh.laneposition
+++++++++++++-                        next_edge = edge.next(route)
+++++++++++++-                        while next_edge is not jun_edge:
+++++++++++++-                            merge_dist += next_edge.length
+++++++++++++-                            next_edge = next_edge.next(route)
+++++++++++++-
+++++++++++++-                        other_lane = jun_edge.lanes[0]
+++++++++++++-                        for other_veh, other_merge_dist in other_lane.prev_vehicles(0, route=ts.routes.ramp):
+++++++++++++-                            other_speed = other_veh.speed
+++++++++++++-                            break
+++++++++++++-                    obs.append([merge_dist, speed, lead_dist, lead_speed, follow_dist, follow_speed, other_merge_dist, other_speed])
+++++++++++++-                else:
+++++++++++++-                    next_lane = lane.next(route)
+++++++++++++-                    if next_lane and next_lane.get('junction'):
+++++++++++++-                        if len(edge.lanes) == 2:
+++++++++++++-                            other_lane = edge.lanes[0]
+++++++++++++-                            pos = veh.laneposition
+++++++++++++-                            for other_veh, other_follow_dist in other_lane.prev_vehicles(pos, route=ts.routes.ramp):
+++++++++++++-                                other_speed = other_veh.speed
+++++++++++++-                                break
+++++++++++++-                    obs.append([speed, lead_dist, lead_speed, follow_dist, follow_speed, other_follow_dist, other_speed])
+++++++++++++-                ids.append(veh.id)
+++++++++++++-        obs = np.array(obs).reshape(-1, c._n_obs) / ([*lif(c.global_obs, max_dist), max_speed] + [max_dist, max_speed] * 3)
+++++++++++++-        if c.mrtl:
+++++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++++++-        obs = np.clip(obs, 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++++++-        reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++++++-        
+++++++++++++-        theoretical_outnum = (c.highway_flow_rate + c.ramp_flow_rate)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++++++-
+++++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++++++-
+++++++++++++-        raw_pet = self.calc_pet()
+++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++++++-        pet = np.clip(pet, -1, 1)
+++++++++++++-
+++++++++++++-        ssm = (c.scale_ttc*ttc - c.scale_drac*drac)/2
+++++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++++++-        
+++++++++++++-        returned = dict(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++++++-        return returned
+++++++++++++-        
+++++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++++++-    
+++++++++++++-    def calc_ttc(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        ttcs = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            if hasattr(v, 'edge'):
+++++++++++++-                leader, headway = v.leader()
+++++++++++++-                if leader:
+++++++++++++-                    v_speed = v.speed
+++++++++++++-                    leader_speed = leader.speed
+++++++++++++-                    if leader_speed < v_speed:
+++++++++++++-                        ttc =  headway/(v_speed-leader_speed)
+++++++++++++-                    else:
+++++++++++++-                        ttc = np.nan
+++++++++++++-                    ttcs.append(ttc)
+++++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++++++-        return fleet_ttc
+++++++++++++-    
+++++++++++++-    def calc_drac(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        dracs = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            if hasattr(v, 'edge'):
+++++++++++++-                leader, headway = v.leader()
+++++++++++++-                if leader:
+++++++++++++-                    v_speed = v.speed
+++++++++++++-                    leader_speed = leader.speed
+++++++++++++-                    drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++++++-                    dracs.append(drac)
+++++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++++++-        return fleet_drac
+++++++++++++-
+++++++++++++-    def calc_pet(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        pets = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            if hasattr(v, 'edge'):
+++++++++++++-                leader, headway = v.leader()
+++++++++++++-                if leader:
+++++++++++++-                    v_speed = v.speed
+++++++++++++-                    if v_speed > 1e-16:
+++++++++++++-                        pet = headway/(v_speed)
+++++++++++++-                        pets.append(pet)
+++++++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++++++-        # return fleet_pet if not np.isnan(fleet_pet) else 1
+++++++++++++-        return fleet_pet
+++++++++++++-
+++++++++++++-class Ramp(Main):
+++++++++++++-    def create_env(c):
+++++++++++++-        return RampEnv(c)
+++++++++++++-
+++++++++++++-    @property
+++++++++++++-    def observation_space(c):
+++++++++++++-        low = np.full(c._n_obs, c.low)
+++++++++++++-        return Box(low, np.ones_like(low))
+++++++++++++-
+++++++++++++-    @property
+++++++++++++-    def action_space(c):
+++++++++++++-        assert c.act_type in ['discretize', 'discrete', 'continuous', 'accel', 'accel_discrete']
+++++++++++++-        if c.act_type in ['discretize', 'continuous', 'accel']:
+++++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++++++++-        elif c.act_type in ['discrete', 'accel_discrete']:
+++++++++++++-            return Discrete(c.n_actions)
+++++++++++++-
+++++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++++++-        step_obs_ = rollout.obs
+++++++++++++-        step_obs = step_obs_[:-1]
+++++++++++++-
+++++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++++++-
+++++++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++++++-
+++++++++++++-        step_id_ = rollout.pop('id')
+++++++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++++++-        id_unique = np.unique(id)
+++++++++++++-
+++++++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++++++-
+++++++++++++-        log(**stats)
+++++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++++++-        log(
+++++++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++++++-            n_veh_unique=len(id_unique),
+++++++++++++-            
+++++++++++++-            reward_mean=np.mean(reward),
+++++++++++++-            reward_std=np.std(reward),        
+++++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++++-
+++++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++++++-            )
+++++++++++++-        return rollout
+++++++++++++-
+++++++++++++-if __name__ == '__main__':
+++++++++++++-    c = Ramp.from_args(globals(), locals()).setdefaults(
+++++++++++++-        warmup_steps=100,
+++++++++++++-        horizon=2000,
+++++++++++++-        n_steps=100,
+++++++++++++-        step_save=5,
+++++++++++++-
+++++++++++++-        premerge_distance=400,
+++++++++++++-        merge_distance=100,
+++++++++++++-        postmerge_distance=30,
+++++++++++++-        av_frac=0.1,
+++++++++++++-        sim_step=0.5,
+++++++++++++-        max_speed=30,
+++++++++++++-        highway_depart_speed=10,
+++++++++++++-        ramp_depart_speed=0,
+++++++++++++-        highway_flow_rate=2000,
+++++++++++++-        ramp_flow_rate=300,
+++++++++++++-        global_obs=False,
+++++++++++++-        handcraft=False,
+++++++++++++-
+++++++++++++-        generic_type='default',
+++++++++++++-        speed_mode=SPEED_MODE.all_checks,
+++++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++++++-
+++++++++++++-        act_type='accel_discrete',
+++++++++++++-        max_accel=1,
+++++++++++++-        max_decel=1.5,
+++++++++++++-        n_actions=3,
+++++++++++++-        low=-1,
+++++++++++++-
+++++++++++++-        render=False,
+++++++++++++-
+++++++++++++-        alg=PG,
+++++++++++++-        lr=1e-3,
+++++++++++++-
+++++++++++++-        gamma=0.99,
+++++++++++++-        adv_norm=False,
+++++++++++++-        batch_concat=True,
+++++++++++++-
+++++++++++++-        beta=0,
+++++++++++++-        scale_ttc=1,
+++++++++++++-        scale_drac=1,
+++++++++++++-        seed_np=False,
+++++++++++++-        seed_torch = False,
+++++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++++++-
+++++++++++++-    )
+++++++++++++-    
+++++++++++++-    if c.seed_torch:
+++++++++++++-        # Set seed for PyTorch CPU operations
+++++++++++++-        torch.manual_seed(c.seed_torch)
+++++++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++++++-        if torch.cuda.is_available():
+++++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++++++-    if c.seed_np:
+++++++++++++-        np.random.seed(c.seed_np)
+++++++++++++-        
+++++++++++++-    c._n_obs = c.global_obs + 1 + 2 + 2 + 2
+++++++++++++-    if c.mrtl:
+++++++++++++-        c._n_obs += 1 # modified for mrtl related
+++++++++++++-    c.run()
+++++++++++++\ No newline at end of file
+++++++++++++diff --git a/intersection.py b/intersection.py
+++++++++++++deleted file mode 100644
+++++++++++++index e38a84f..0000000
+++++++++++++--- a/intersection.py
++++++++++++++++ /dev/null
+++++++++++++@@ -1,489 +0,0 @@
+++++++++++++-from automatic_vehicular_control.u import *
+++++++++++++-from automatic_vehicular_control.exp import *
+++++++++++++-from automatic_vehicular_control.env import *
+++++++++++++-
+++++++++++++-class Platoon(Entity):
+++++++++++++-    pass
+++++++++++++-
+++++++++++++-class IntersectionEnv(Env):
+++++++++++++-    def def_sumo(self):
+++++++++++++-        c = self.c
+++++++++++++-
+++++++++++++-        types = [E('vType', id='human', **IDM, **LC2013), E('vType', id='rl', **IDM, **LC2013), E('vType', id='generic', **IDM, **LC2013)]
+++++++++++++-        default_flows = lambda flow_id, route_id, flow_rate: [E('flow', **params) for params in [
+++++++++++++-            FLOW(f'{flow_id}', type='generic', route=route_id, departSpeed=c.depart_speed, vehsPerHour=flow_rate),
+++++++++++++-        ] if params.get('vehsPerHour')]
+++++++++++++-
+++++++++++++-        builder = NetBuilder()
+++++++++++++-        xys = np.array(np.ones((c.n_rows + 2, c.n_cols + 2)).nonzero()).T * c.length
+++++++++++++-        if c.enter_length:
+++++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++++++++-            xys[1:, :, 0] += c.enter_length - c.length
+++++++++++++-            xys[:, 1:, 1] += c.enter_length - c.length
+++++++++++++-            xys = xys.reshape(-1, 2)
+++++++++++++-        if c.short_exit:
+++++++++++++-            xys = xys.reshape(c.n_rows + 2, c.n_cols + 2, 2)
+++++++++++++-            xys[-1, :, 0] += c.short_exit - c.length
+++++++++++++-            xys[:, -1, 1] += c.short_exit - c.length
+++++++++++++-            xys = xys.reshape(-1, 2)
+++++++++++++-        nodes = builder.add_nodes(
+++++++++++++-            [Namespace(x=x, y=y, type='priority') for y, x in xys]
+++++++++++++-        ).reshape(c.n_rows + 2, c.n_cols + 2)
+++++++++++++-        # import pdb; pdb.set_trace()
+++++++++++++-
+++++++++++++-        tl = c.setdefault('tl', False)
+++++++++++++-        if tl:
+++++++++++++-            c.av_frac = 0
+++++++++++++-            c.pop('av_range', None)
+++++++++++++-            c.speed_mode = SPEED_MODE.all_checks
+++++++++++++-
+++++++++++++-        flows = []
+++++++++++++-        c.setdefaults(flow_rate_h=c.flow_rate, flow_rate_v=c.flow_rate)
+++++++++++++-        priority = ['left', 'right'] if c.get('priority', 'vertical') == 'horizontal' else ['up', 'down']
+++++++++++++-        for direction in c.directions:
+++++++++++++-            chains = nodes if direction in ['left', 'right'] else nodes.T
+++++++++++++-            chains = chains if direction in ['up', 'right'] else np.fliplr(chains)
+++++++++++++-            flow_rate = c.flow_rate_h if direction in ['left', 'right'] else c.flow_rate_v
+++++++++++++-
+++++++++++++-            edge_attrs = dict(priority=int(direction in priority))
+++++++++++++-            if c.get('set_edge_speed', True):
+++++++++++++-                edge_attrs['speed'] = c.max_speed
+++++++++++++-
+++++++++++++-            for i, chain in enumerate(chains[1:-1]):
+++++++++++++-                route_id, flow_id = f'r_{direction}_{i}', f'f_{direction}_{i}'
+++++++++++++-                builder.chain(chain, route_id=route_id, edge_attrs=edge_attrs)
+++++++++++++-                flows.extend(default_flows(flow_id, route_id, flow_rate))
+++++++++++++-
+++++++++++++-        tls = []
+++++++++++++-        if tl:
+++++++++++++-            tl = 1000000 if tl == 'MaxPressure' else tl
+++++++++++++-            tl_h, tl_v = tl if isinstance(tl, tuple) else (tl, tl)
+++++++++++++-            tl_offset = c.get('tl_offset', 'auto')
+++++++++++++-            yellow = c.get('yellow', 0.5)
+++++++++++++-            if tl_offset == 'auto':
+++++++++++++-                offsets = c.length * (np.arange(c.n_rows).reshape(-1, 1) + np.arange(c.n_cols).reshape(1, -1)) / 10
+++++++++++++-            elif tl_offset == 'same':
+++++++++++++-                offsets = np.zeros(c.n_rows).reshape(-1, 1) + np.zeros(c.n_cols).reshape(1, -1)
+++++++++++++-            for node, offset in zip(nodes[1:-1, 1:-1].reshape(-1), offsets.reshape(-1)):
+++++++++++++-                node.type = 'traffic_light'
+++++++++++++-                phase_multiple = len(c.directions) // 2
+++++++++++++-                tls.append(E('tlLogic',
+++++++++++++-                    E('phase', duration=tl_v, state='Gr' * phase_multiple),
+++++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='yr' * phase_multiple)),
+++++++++++++-                    E('phase', duration=tl_h, state='rG' * phase_multiple),
+++++++++++++-                    *lif(yellow, E('phase', duration=yellow, state='ry' * phase_multiple)),
+++++++++++++-                id=node.id, offset=offset, type='static', programID='1'))
+++++++++++++-
+++++++++++++-        nodes, edges, connections, routes = builder.build()
+++++++++++++-        additional = E('additional', *types, *routes, *flows, *tls)
+++++++++++++-        return super().def_sumo(nodes, edges, connections, additional)
+++++++++++++-
+++++++++++++-    def build_platoon(self):
+++++++++++++-        ts = self.ts
+++++++++++++-        rl_type = ts.types.rl
+++++++++++++-        for route in ts.routes:
+++++++++++++-            vehs = []
+++++++++++++-            route_offset = 0
+++++++++++++-            for edge in route.edges:
+++++++++++++-                for veh in edge.vehicles:
+++++++++++++-                    veh.route_position = route_offset + veh.laneposition
+++++++++++++-                    vehs.append(veh)
+++++++++++++-                route_offset += edge.length
+++++++++++++-
+++++++++++++-            rl_mask = np.array([veh.type is rl_type for veh in vehs])
+++++++++++++-            if len(rl_mask) > 1 and c.get('merge_consecutive_avs'):
+++++++++++++-                rl_mask[1:] = rl_mask[1:] & ~rl_mask[:-1]
+++++++++++++-            rl_idxs, = rl_mask.nonzero()
+++++++++++++-            split_idxs = 1 + rl_idxs
+++++++++++++-
+++++++++++++-            prev = None
+++++++++++++-            for i, vehs_i in enumerate(np.split(vehs, split_idxs)):
+++++++++++++-                if not len(vehs_i):
+++++++++++++-                    continue # Last vehicle is RL, so the last split is empty
+++++++++++++-                platoon = Platoon(id=f'{route}.platoon_{i}', route=route,
+++++++++++++-                    vehs=vehs_i, head=vehs_i[-1], tail=vehs_i[0], prev=prev
+++++++++++++-                )
+++++++++++++-                if prev is not None:
+++++++++++++-                    prev.next = platoon
+++++++++++++-                prev = platoon
+++++++++++++-                for veh in vehs_i:
+++++++++++++-                    veh.platoon = platoon
+++++++++++++-            if prev is not None:
+++++++++++++-                prev.next = None
+++++++++++++-
+++++++++++++-    def reset(self):
+++++++++++++-        c = self.c
+++++++++++++-        if c.e is False:
+++++++++++++-            if 'length_range' in c:
+++++++++++++-                min_, max_ = c.length_range
+++++++++++++-                c.setdefaults(max_length=max_)
+++++++++++++-                c.length = np.random.randint(min_, max_ + 1)
+++++++++++++-            if 'av_range' in c:
+++++++++++++-                min_, max_ = c.av_range
+++++++++++++-                c.av_frac = np.random.uniform(min_, max_)
+++++++++++++-        self.mp_tlast = 0
+++++++++++++-        while not self.reset_sumo():
+++++++++++++-            pass
+++++++++++++-        ret = super().init_env()
+++++++++++++-        return ret
+++++++++++++-
+++++++++++++-    def step(self, action=[]):
+++++++++++++-        c = self.c
+++++++++++++-        ts = self.ts
+++++++++++++-        max_dist = c.max_dist
+++++++++++++-        depart_speed = c.depart_speed
+++++++++++++-        max_speed = c.max_speed
+++++++++++++-
+++++++++++++-        rl_type = ts.types.rl
+++++++++++++-        prev_rls = sorted(rl_type.vehicles, key=lambda x: x.id)
+++++++++++++-
+++++++++++++-        for rl, act in zip(prev_rls, action):
+++++++++++++-            if c.handcraft or c.handcraft_tl:
+++++++++++++-                route, lane = rl.route, rl.lane
+++++++++++++-                junction = lane.next_junction
+++++++++++++-                level = 1
+++++++++++++-                if junction is not ts.sentinel_junction:
+++++++++++++-                    dist = junction.route_position[route] - rl.route_position
+++++++++++++-                    if c.handcraft:
+++++++++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++++++++-                            level = 1 - int(dist < c.handcraft and cross_veh and (cross_veh.type is not rl_type or dist > cross_dist))
+++++++++++++-                    elif c.handcraft_tl and dist < 15:
+++++++++++++-                        t_h, t_v = c.handcraft_tl if isinstance(c.handcraft_tl, tuple) else (c.handcraft_tl, c.handcraft_tl)
+++++++++++++-                        yellow_time = 0
+++++++++++++-                        rem = self._step % (t_h + yellow_time + t_v + yellow_time)
+++++++++++++-                        horizontal_go = 0 <= rem < t_h
+++++++++++++-                        vertical_go = t_h + yellow_time <= rem
+++++++++++++-                        horizontal_lane = 'left' in route.id or 'right' in route.id
+++++++++++++-                        human_remain = False
+++++++++++++-                        for cross_lane in lane.next_cross_lanes:
+++++++++++++-                            cross_veh, cross_dist = cross_lane.prev_vehicle(0, route=nexti(cross_lane.from_routes))
+++++++++++++-                            human_remain = cross_veh and cross_veh.type is not rl_type
+++++++++++++-                        level = not human_remain and (horizontal_go and horizontal_lane or vertical_go and not horizontal_lane)
+++++++++++++-            elif c.act_type == 'accel':
+++++++++++++-                level = (np.clip(act, c.low, 1) - c.low) / (1 - c.low)
+++++++++++++-            else:
+++++++++++++-                level = act / (c.n_actions - 1)
+++++++++++++-            ts.accel(rl, (level * 2 - 1) * (c.max_accel if level > 0.5 else c.max_decel))
+++++++++++++-
+++++++++++++-        if c.tl == 'MaxPressure':
+++++++++++++-            self.mp_tlast += c.sim_step
+++++++++++++-            tmin = c.get('mp_tmin', 0)
+++++++++++++-            if self.mp_tlast >= tmin:
+++++++++++++-                for tl in ts.traffic_lights:
+++++++++++++-                    if ts.get_program(tl) == 'off':
+++++++++++++-                        break
+++++++++++++-                    jun = tl.junction
+++++++++++++-                    pressures = [len(p.vehicles) - len(n.vehicles) for p, n in zip(jun.prev_lanes, jun.next_lanes)]
+++++++++++++-
+++++++++++++-                    total_pressures = []
+++++++++++++-                    for phase in (ph for ph in tl.phases if 'y' not in ph.state):
+++++++++++++-                        total_pressures.append(sum(p for p, s in zip(pressures, phase.state) if s == 'G'))
+++++++++++++-
+++++++++++++-                    ts.set_phase(tl, np.argmax(total_pressures))
+++++++++++++-                self.mp_tlast = 0
+++++++++++++-
+++++++++++++-        super().step()
+++++++++++++-        self.build_platoon()
+++++++++++++-
+++++++++++++-        obs = {}
+++++++++++++-
+++++++++++++-        veh_default_close = Namespace(speed=max_speed, route_position=np.inf)
+++++++++++++-        veh_default_far = Namespace(speed=0, route_position=-np.inf)
+++++++++++++-        vehs_default = lambda: [veh_default_close] + [veh_default_far] * 2 * c.obs_next_cross_platoons
+++++++++++++-        for veh in rl_type.vehicles:
+++++++++++++-            if hasattr(veh, 'lane'):
+++++++++++++-                route, lane, platoon = veh.route, veh.lane, veh.platoon
+++++++++++++-                junction = lane.next_junction
+++++++++++++-
+++++++++++++-                head, tail = veh, platoon.tail
+++++++++++++-                route_vehs = [(route, [head, *lif(c.obs_tail, tail)])]
+++++++++++++-
+++++++++++++-                if junction is ts.sentinel_junction:
+++++++++++++-                    route_vehs.extend([(None, vehs_default())] * (len(c.directions) - 1))
+++++++++++++-                else:
+++++++++++++-                    for jun_lane in lane.next_junction_lanes:
+++++++++++++-                        # Defaults for jun_lane
+++++++++++++-                        jun_headtails = vehs_default()
+++++++++++++-
+++++++++++++-                        jun_lane_route = nexti(jun_lane.from_routes)
+++++++++++++-                        jun_veh, _ = jun_lane.prev_vehicle(0, route=jun_lane_route)
+++++++++++++-                        jun_veh = jun_veh if jun_veh and jun_veh.lane.next_junction is junction else None
+++++++++++++-
+++++++++++++-                        if jun_veh:
+++++++++++++-                            if jun_veh.type is rl_type:
+++++++++++++-                                # If jun_veh is RL or jun_veh is human and there's no RL vehicle in front of it
+++++++++++++-                                jun_headtails[1: 3] = jun_veh, jun_veh.platoon.tail
+++++++++++++-                                platoon = jun_veh.platoon.prev
+++++++++++++-                                for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++++++++-                                    if platoon is None: break
+++++++++++++-                                    jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++++++++-                                    platoon = platoon.prev
+++++++++++++-                            else:
+++++++++++++-                                # If jun_veh is a human vehicle behind some RL vehicle (in another lane)
+++++++++++++-                                jun_headtails[0] = jun_veh.platoon.tail
+++++++++++++-                                next_cross_platoon = jun_veh.platoon.prev
+++++++++++++-                                if next_cross_platoon:
+++++++++++++-                                    jun_headtails[1: 3] = next_cross_platoon.head, next_cross_platoon.tail
+++++++++++++-                                    platoon = next_cross_platoon.prev
+++++++++++++-                                    for i in 1 + 2 * np.arange(1, c.obs_next_cross_platoons):
+++++++++++++-                                        if platoon is None: break
+++++++++++++-                                        jun_headtails[i: i + 2] = platoon.head, platoon.tail
+++++++++++++-                                        platoon = platoon.prev
+++++++++++++-                        route_vehs.append((jun_lane_route, jun_headtails))
+++++++++++++-
+++++++++++++-                dist_features, speed_features = [], []
+++++++++++++-                for route, vehs in route_vehs:
+++++++++++++-                    j_pos = junction.route_position[route]
+++++++++++++-                    dist_features.extend([0 if j_pos == v.route_position else (j_pos - v.route_position) / max_dist for v in vehs])
+++++++++++++-                    speed_features.extend([v.speed / max_speed for v in vehs])
+++++++++++++-
+++++++++++++-                obs[veh.id] = np.clip([*dist_features, *speed_features], 0, 1).astype(np.float32) * (1 - c.low) + c.low
+++++++++++++-
+++++++++++++-        sort_id = lambda d: [v for k, v in sorted(d.items())]
+++++++++++++-        ids = sorted(obs)
+++++++++++++-        if c.mrtl:
+++++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++++++-        obs = arrayf(sort_id(obs)).reshape(-1, c._n_obs)
+++++++++++++-        if c.rew_type == 'outflow':
+++++++++++++-            reward = len(ts.new_arrived) - c.collision_coef * len(ts.new_collided)
+++++++++++++-        elif c.rew_type == 'time_penalty':
+++++++++++++-            reward = -c.sim_step * (len(ts.vehicles) + sum(len(f.backlog) for f in ts.flows)) - c.collision_coef * len(ts.new_collided)
+++++++++++++-        
+++++++++++++-        theoretical_outnum = 2*(c.flow_rate_h + c.flow_rate_v)/3600 * c.sim_step # units: number of vehicles. sim_step: sec, flow_rate: veh/hr
+++++++++++++-        outflow_reward=np.clip(reward/theoretical_outnum, -1, 1)
+++++++++++++-
+++++++++++++-        raw_drac = self.calc_drac()
+++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4 # empirically set small drac
+++++++++++++-        drac = np.clip(drac/10, -1, 1)
+++++++++++++-        raw_pet = self.calc_pet()
+++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6 # empirically set big pet
+++++++++++++-        pet = np.clip(pet/6, -1, 1)
+++++++++++++-
+++++++++++++-        raw_ttc = self.calc_ttc()
+++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # empirically set big ttc
+++++++++++++-        ttc = np.clip(ttc/7, -1, 1)
+++++++++++++-
+++++++++++++-        ssm = (c.scale_pet*pet - c.scale_drac*drac)/2
+++++++++++++-        reward = (1-c.beta)*outflow_reward + c.beta*ssm
+++++++++++++-
+++++++++++++-        returned = Namespace(obs=obs, id=ids, reward=reward, outflow_reward=outflow_reward, ttc=ttc, drac=drac, pet=pet, ssm=ssm, raw_ttc=raw_ttc, raw_drac=raw_drac, raw_pet=raw_pet) 
+++++++++++++-        return returned
+++++++++++++-        # return Namespace(obs=obs, id=ids, reward=reward)
+++++++++++++-        
+++++++++++++-    def calc_drac(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        dracs = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            if hasattr(v, 'lane'):
+++++++++++++-                leader, headway = v.leader()
+++++++++++++-                v_speed = v.speed
+++++++++++++-                leader_speed = leader.speed
+++++++++++++-                drac = 0.5*np.square(v_speed-leader_speed)/headway
+++++++++++++-                dracs.append(drac)
+++++++++++++-        fleet_drac = np.nanmean(np.array(dracs))
+++++++++++++-        return fleet_drac
+++++++++++++-    
+++++++++++++-    def calc_pet(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        pets = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            if hasattr(v, 'lane'):
+++++++++++++-                leader, headway = v.leader()
+++++++++++++-                v_speed = v.speed
+++++++++++++-                if v_speed > 1e-16:
+++++++++++++-                    pet = headway/(v_speed)
+++++++++++++-                    pets.append(pet)
+++++++++++++-        fleet_pet = np.nanmean(np.array(pets))
+++++++++++++-        return fleet_pet
+++++++++++++-
+++++++++++++-    def calc_ttc(self):
+++++++++++++-        cur_veh_list = self.ts.vehicles
+++++++++++++-        ttcs = []
+++++++++++++-        for v in cur_veh_list:
+++++++++++++-            if hasattr(v, 'lane'):
+++++++++++++-                leader, headway = v.leader()
+++++++++++++-                v_speed = v.speed
+++++++++++++-                leader_speed = leader.speed
+++++++++++++-                if leader_speed < v_speed:
+++++++++++++-                    ttc =  headway/(v_speed-leader_speed)
+++++++++++++-                else:
+++++++++++++-                    ttc = np.nan
+++++++++++++-                ttcs.append(ttc)
+++++++++++++-        fleet_ttc = np.nanmean(np.array(ttcs))
+++++++++++++-        return fleet_ttc
+++++++++++++-
+++++++++++++-    def append_step_info(self):
+++++++++++++-        super().append_step_info()
+++++++++++++-        self.rollout_info.append(n_veh_network=len(self.ts.vehicles))
+++++++++++++-
+++++++++++++-    @property
+++++++++++++-    def stats(self):
+++++++++++++-        c = self.c
+++++++++++++-        info = self.rollout_info[1 + c.warmup_steps + c.skip_stat_steps:]
+++++++++++++-        mean = lambda L: np.mean(L) if len(L) else np.nan
+++++++++++++-        stats = {**super().stats, **dif('length_range' in c, length=c.length), **dif('av_range' in c, av_frac=c.av_frac)}
+++++++++++++-        stats['backlog_step'] = mean(info['backlog'])
+++++++++++++-        stats['n_total_veh_step'] = mean(info['n_veh_network']) + stats['backlog_step']
+++++++++++++-
+++++++++++++-        stats['beta'] = c.beta
+++++++++++++-
+++++++++++++-        if c.multi_flowrate:
+++++++++++++-            stats['flow_horizontal'] = c.flow_rate_h
+++++++++++++-            stats['flow_vertical'] = c.flow_rate_v
+++++++++++++-        return stats
+++++++++++++-
+++++++++++++-class Intersection(Main):
+++++++++++++-    def create_env(c):
+++++++++++++-        if c.multi_flowrate:
+++++++++++++-            return NormEnv(c, IntersectionEnv(c))
+++++++++++++-        else:
+++++++++++++-            c._norm = NormEnv(c, None)
+++++++++++++-            return IntersectionEnv(c)
+++++++++++++-
+++++++++++++-    @property
+++++++++++++-    def observation_space(c):
+++++++++++++-        low = np.full(c._n_obs, c.low)
+++++++++++++-        return Box(low, np.ones_like(low))
+++++++++++++-
+++++++++++++-    @property
+++++++++++++-    def action_space(c):
+++++++++++++-        if c.act_type == 'accel':
+++++++++++++-            return Box(low=c.low, high=1, shape=(1,), dtype=np.float32)
+++++++++++++-        else:
+++++++++++++-            return Discrete(c.n_actions)
+++++++++++++-
+++++++++++++-    def on_rollout_end(c, rollout, stats, ii=None, n_ii=None):
+++++++++++++-        log = c.get_log_ii(ii, n_ii)
+++++++++++++-        step_obs_ = rollout.obs
+++++++++++++-        step_obs = step_obs_[:-1]
+++++++++++++-
+++++++++++++-        if not c.multi_flowrate:
+++++++++++++-            rollout.raw_reward = rollout.reward
+++++++++++++-            rollout.reward = [c._norm.norm_reward(r) for r in rollout.raw_reward]
+++++++++++++-
+++++++++++++-        ret, _ = calc_adv(rollout.reward, c.gamma)
+++++++++++++-
+++++++++++++-        n_veh = np.array([len(o) for o in step_obs])
+++++++++++++-        step_ret = [[r] * nv for r, nv in zip(ret, n_veh)]
+++++++++++++-        rollout.update(obs=step_obs, ret=step_ret)
+++++++++++++-
+++++++++++++-        step_id_ = rollout.pop('id')
+++++++++++++-        id = np.concatenate(step_id_[:-1])
+++++++++++++-        id_unique = np.unique(id)
+++++++++++++-
+++++++++++++-        reward = np.array(rollout.pop('reward'))
+++++++++++++-        raw_reward = np.array(rollout.pop('raw_reward'))
+++++++++++++-
+++++++++++++-        log(**stats)
+++++++++++++-        log(raw_reward_mean=raw_reward.mean(), raw_reward_sum=raw_reward.sum())
+++++++++++++-        log(reward_mean=reward.mean(), reward_sum=reward.sum())
+++++++++++++-        log(
+++++++++++++-            n_veh_step_mean=n_veh.mean(), 
+++++++++++++-            n_veh_step_sum=n_veh.sum(), 
+++++++++++++-            n_veh_unique=len(id_unique),
+++++++++++++-            
+++++++++++++-            reward_mean=np.mean(reward),
+++++++++++++-            reward_std=np.std(reward),        
+++++++++++++-            outflow_reward_mean=np.mean(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++++-            outflow_reward_std=np.std(rollout.outflow_reward) if rollout.outflow_reward else None,
+++++++++++++-            ssm_mean=np.mean(rollout.ssm),
+++++++++++++-            ssm_std=np.std(rollout.ssm),
+++++++++++++-            drac_mean=np.mean(rollout.drac) if rollout.drac else None,
+++++++++++++-            drac_std=np.std(rollout.drac) if rollout.drac else None,
+++++++++++++-            pet_mean=np.mean(rollout.pet) if rollout.pet else None,
+++++++++++++-            pet_std=np.std(rollout.pet) if rollout.pet else None,
+++++++++++++-            raw_drac_mean=np.mean(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++++-            raw_drac_std=np.std(rollout.raw_drac) if rollout.raw_drac else None,
+++++++++++++-            raw_pet_mean=np.mean(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++++-            raw_pet_std=np.std(rollout.raw_pet) if rollout.raw_pet else None,
+++++++++++++-
+++++++++++++-            ttc_mean=np.mean(rollout.ttc) if rollout.ttc else None,
+++++++++++++-            ttc_std=np.std(rollout.ttc) if rollout.ttc else None,
+++++++++++++-            raw_ttc_mean=np.mean(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++++-            raw_ttc_std=np.std(rollout.raw_ttc) if rollout.raw_ttc else None,
+++++++++++++-            # nom_action = np.mean(rollout.nom_action),
+++++++++++++-            # res_action = np.mean(rollout.res_action),
+++++++++++++-            )
+++++++++++++-        
+++++++++++++-        return rollout
+++++++++++++-
+++++++++++++-if __name__ == '__main__':
+++++++++++++-    c = Intersection.from_args(globals(), locals())
+++++++++++++-    c.setdefaults(
+++++++++++++-        n_steps=200,
+++++++++++++-        step_save=5,
+++++++++++++-
+++++++++++++-        depart_speed=0,
+++++++++++++-        max_speed=13,
+++++++++++++-        max_dist=100,
+++++++++++++-        max_accel=1.5,
+++++++++++++-        max_decel=3.5,
+++++++++++++-        sim_step=0.5,
+++++++++++++-        generic_type=True,
+++++++++++++-        n_actions=3,
+++++++++++++-
+++++++++++++-        adv_norm=False,
+++++++++++++-        batch_concat=True,
+++++++++++++-
+++++++++++++-        render=False,
+++++++++++++-
+++++++++++++-        warmup_steps=100,
+++++++++++++-        horizon=2000,
+++++++++++++-        directions='4way',
+++++++++++++-        av_frac=0.15,
+++++++++++++-        handcraft=False,
+++++++++++++-        handcraft_tl=None,
+++++++++++++-        flow_rate=700,
+++++++++++++-        length=100,
+++++++++++++-        n_rows=1,
+++++++++++++-        n_cols=1,
+++++++++++++-        speed_mode=SPEED_MODE.obey_safe_speed,
+++++++++++++-
+++++++++++++-        act_type='accel_discrete',
+++++++++++++-        low=-1,
+++++++++++++-
+++++++++++++-        alg=PG,
+++++++++++++-        n_gds=1,
+++++++++++++-        lr=1e-3,
+++++++++++++-        gamma=0.99,
+++++++++++++-        collision_coef=5, # If there's a collision, it always involves an even number of vehicles
+++++++++++++-
+++++++++++++-        enter_length=False,
+++++++++++++-        short_exit=False,
+++++++++++++-
+++++++++++++-        rew_type='outflow',
+++++++++++++-        norm_reward=True,
+++++++++++++-        center_reward=True,
+++++++++++++-        multi_flowrate=False,
+++++++++++++-        opt='RMSprop',
+++++++++++++-
+++++++++++++-        obs_tail=True,
+++++++++++++-        obs_next_cross_platoons=1,
+++++++++++++-
+++++++++++++-        beta=0,
+++++++++++++-        scale_pet=1,
+++++++++++++-        scale_drac=1,
+++++++++++++-        seed_np=False,
+++++++++++++-        seed_torch = False,
+++++++++++++-        residual_transfer=False, # this flag deals with which network to modify (nominal if False, residual if True). instantiates both.
+++++++++++++-        mrtl=False, # this flag deals with adding beta to observation vector
+++++++++++++-    )
+++++++++++++-
+++++++++++++-    if c.seed_torch:
+++++++++++++-        # Set seed for PyTorch CPU operations
+++++++++++++-        torch.manual_seed(c.seed_torch)
+++++++++++++-        # Set seed for PyTorch CUDA operations (if available)
+++++++++++++-        if torch.cuda.is_available():
+++++++++++++-            torch.cuda.manual_seed_all(c.seed_torch)
+++++++++++++-    if c.seed_np:
+++++++++++++-        np.random.seed(c.seed_np)
+++++++++++++-
+++++++++++++-    if c.directions == '4way':
+++++++++++++-        c.directions = ['up', 'right', 'down', 'left']
+++++++++++++-    c._n_obs = 2 * (1 + c.obs_tail + (1 + 2 * c.obs_next_cross_platoons) * (len(c.directions) - 1))
+++++++++++++-    if c.mrtl:
+++++++++++++-        c._n_obs += 1
+++++++++++++-    assert c.get('use_critic', False) is False, 'Not supporting value functions yet'
+++++++++++++-    c.redef_sumo = 'length_range' in c
+++++++++++++-    c.run()
+++++++++++++\ No newline at end of file
++++++++++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
++++++++++++-index 127f673..878e4c8 100644
+++++++++++++index 57ad1e2..560b5d8 100644
++++++++++++ --- a/ring_different_veh.py
++++++++++++ +++ b/ring_different_veh.py
++++++++++++-@@ -5,8 +5,15 @@
++++++++++++- from exp import *  # Import all from experimental utilities
++++++++++++- from env import *  # Import all from environment utilities
++++++++++++- from u import *    # Import all from utility functions
++++++++++++-+import os
++++++++++++- 
++++++++++++--# Define the RingEnv class which inherits from the Env class
++++++++++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++++++++-+
++++++++++++-+
++++++++++++-+'''
++++++++++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
++++++++++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
++++++++++++-+'''
++++++++++++- class RingEnv(Env):
++++++++++++-     def def_sumo(self):
++++++++++++-         c = self.c  # Access configuration object
++++++++++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
++++++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++++++++-         )
++++++++++++--
++++++++++++-         # Function to generate the shape of the edges (circular arcs)
++++++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++++++- 
++++++++++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
++++++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++++++++-         return stats
++++++++++++--
++++++++++++-+    
++++++++++++-+    def calculate_flow(self):
++++++++++++-+        """
++++++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++++++++-+        """
++++++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++++++++-+        if len(vehicles_on_edge) != 0:     
++++++++++++-+            if vehicles_on_edge[0] != self.last_vehicle:
++++++++++++-+                self.last_vehicle = vehicles_on_edge[0]
++++++++++++-+                self.passed_vehicle.append(self.last_vehicle)
++++++++++++-+
++++++++++++-+
++++++++++++-+                    
++++++++++++-     def step(self, action=None):
++++++++++++-         c = self.c  # Configuration object
++++++++++++-         ts = self.ts  # Time step object
++++++++++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
++++++++++++-                     # Change to a specific lane
++++++++++++-                     ts.lane_change_to(rl, lc)
++++++++++++- 
++++++++++++-+        
++++++++++++-         super().step()  # Advance the simulation by one step
++++++++++++- 
++++++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
++++++++++++- 
++++++++++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++++++++++- 
++++++++++++-+        # Calculate flow at the end of each step
++++++++++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++++++++++-+        
++++++++++++-         # Calculate safety surrogate measures
++++++++++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++++++++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
++++++++++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
++++++++++++-         return fleet_pet
++++++++++++- 
++++++++++++--# Define the Ring class which inherits from the Main class
++++++++++++-+
++++++++++++-+'''
++++++++++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
++++++++++++-+    It defines how the environment is created and configured, 
++++++++++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
++++++++++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
++++++++++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
++++++++++++-+'''
++++++++++++- class Ring(Main):
++++++++++++-     # Method to create and return the environment
++++++++++++-     def create_env(c):
++++++++++++-@@ -391,7 +421,7 @@ class Ring(Main):
++++++++++++- 
++++++++++++- if __name__ == '__main__':
++++++++++++-     # Run the test with different numbers of vehicles
++++++++++++--    for n_veh in range(40, 100, 10):
++++++++++++-+    for n_veh in range(20, 40, 10):
++++++++++++-         print(f"Running simulation with {n_veh} vehicles")
++++++++++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
++++++++++++-         c = Ring.from_args(globals(), locals()).setdefaults(
++++++++++++-diff --git a/u.py b/u.py
++++++++++++-index 09845aa..8e11a17 100644
++++++++++++---- a/u.py
++++++++++++-+++ b/u.py
++++++++++++-@@ -11,6 +11,8 @@ import warnings
++++++++++++- warnings.filterwarnings('ignore')
++++++++++++- 
++++++++++++- from io import StringIO
++++++++++++-+import os
++++++++++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++++++++++@@ -134,127 +134,6 @@ class RingEnv(Env):
+++++++++++++             super().step()
+++++++++++++             return c.observation_space.low, 0, False, 0
++++++++++++  
++++++++++++- def lrange(*args, **kwargs):
++++++++++++-     return list(range(*args, **kwargs))
++++++++++++\ No newline at end of file
+++++++++++++-        
+++++++++++++-        super().step()  # Advance the simulation by one step
+++++++++++++-
+++++++++++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++++++-            print('Detected collision')
+++++++++++++-            return c.observation_space.low, -c.collision_penalty, True, None
+++++++++++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
+++++++++++++-            print('Bad initialization occurred, fix the initialization function')
+++++++++++++-            return c.observation_space.low, 0, True, None
+++++++++++++-
+++++++++++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
+++++++++++++-        if c.n_lanes == 1:
+++++++++++++-            # Single-lane observation space representation
+++++++++++++-            obs = [
+++++++++++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
+++++++++++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
+++++++++++++-                dist / max_dist                 # Normalized headway distance
+++++++++++++-            ]
+++++++++++++-            if c.circ_feature:
+++++++++++++-                # Add normalized circumference feature
+++++++++++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
+++++++++++++-            if c.accel_feature:
+++++++++++++-                # Add leader acceleration feature
+++++++++++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
+++++++++++++-        elif c.n_lanes == 2:
+++++++++++++-            # Two-lane observation space representation
+++++++++++++-            lane = rl.lane
+++++++++++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
+++++++++++++-            if c.symmetric:
+++++++++++++-                # Symmetric lane observations
+++++++++++++-                other_lane = rl.lane.left or rl.lane.right
+++++++++++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++++++-                obs = np.concatenate([
+++++++++++++-                    # Normalized speeds of vehicles in the current and other lane
+++++++++++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
+++++++++++++-                    # Normalized distances to the leader and follower vehicles
+++++++++++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
+++++++++++++-                ])
+++++++++++++-            else:
+++++++++++++-                # Asymmetric lane observations
+++++++++++++-                obs = [rl.speed]
+++++++++++++-                for lane in rl.edge.lanes:
+++++++++++++-                    is_rl_lane = lane == rl.lane
+++++++++++++-                    if is_rl_lane:
+++++++++++++-                        # Observations for the lane in which RL vehicle is currently present
+++++++++++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++++++++-                    else:
+++++++++++++-                        # Observations for the other lane
+++++++++++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++++++++-                # Normalize the observations
+++++++++++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
+++++++++++++-        else:
+++++++++++++-            # Multi-lane observation space representation (for more than two lanes)
+++++++++++++-            obs = [rl.speed]
+++++++++++++-            follower, fdist = rl.follower()
+++++++++++++-            for lane in rl.edge.lanes:
+++++++++++++-                is_rl_lane = lane == rl.lane
+++++++++++++-                if is_rl_lane:
+++++++++++++-                    # Observations for the current lane
+++++++++++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++++++++-                else:
+++++++++++++-                    # Observations for other lanes
+++++++++++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++++++++-            # Normalize the observations
+++++++++++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
+++++++++++++-
+++++++++++++-        if c.mrtl:
+++++++++++++-            # If mrtl is enabled, add beta to observations
+++++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++++++-        # Clip and scale observations to the specified range
+++++++++++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
+++++++++++++-
+++++++++++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
+++++++++++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
+++++++++++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
+++++++++++++-            # Apply penalty for acceleration changes
+++++++++++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
+++++++++++++-
+++++++++++++-        self.last_speed = rl.speed  # Update last speed for next step
+++++++++++++-
+++++++++++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++++++++++-
+++++++++++++-        # Calculate flow at the end of each step
+++++++++++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++++++++-        
+++++++++++++-        # Calculate safety surrogate measures
+++++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++++++++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
+++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
+++++++++++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
+++++++++++++-
+++++++++++++-        raw_pet = self.calc_pet()
+++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
+++++++++++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
+++++++++++++-
+++++++++++++-        # Combine safety measures into a single value for the reward
+++++++++++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
+++++++++++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
+++++++++++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
+++++++++++++-
+++++++++++++-        # Return observations, reward, and other rollout information
+++++++++++++-        returned = dict(
+++++++++++++-            obs=obs.astype(np.float32),  # Observations
+++++++++++++-            reward=reward,               # Final reward value
+++++++++++++-            speed_reward=speed_reward,   # Component of reward due to speed
+++++++++++++-            ttc=ttc,                     # Time to collision value
+++++++++++++-            drac=drac,                   # Deceleration rate to avoid collision
+++++++++++++-            pet=pet,                     # Post-encroachment time
+++++++++++++-            ssm=ssm,                     # Combined safety surrogate measure
+++++++++++++-            raw_ttc=raw_ttc,             # Raw TTC value
+++++++++++++-            raw_drac=raw_drac,           # Raw DRAC value
+++++++++++++-            raw_pet=raw_pet              # Raw PET value
+++++++++++++-        )
+++++++++++++-        return returned
+++++++++++++-
+++++++++++++     # Calculate the average Time to Collision (TTC) for all vehicles
+++++++++++++     def calc_ttc(self):
+++++++++++++         cur_veh_list = self.ts.vehicles
++++++++++++\ No newline at end of file
++++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++++index 6dd4b74..b5f8d76 100644
++++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++++@@ -1 +1 @@
++++++++++++-5212a280909582c6efe2a4607d1c48e7247a3514
++++++++++++\ No newline at end of file
+++++++++++++08748e726448dbe1cefcc92787467792133761ac
++++++++++++\ No newline at end of file
++++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++++index 2c19369..def6d92 100644
++++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++++@@ -2,17 +2,11 @@ On branch main
++++++++++++ Your branch is up to date with 'origin/main'.
+++++++++++  
+++++++++++-+        # Calculate flow at the end of each step
+++++++++++-+        flow = self.calculate_flow()
+++++++++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
+++++++++++-+        
+++++++++++-         super().step()  # Advance the simulation by one step
++++++++++++ Changes not staged for commit:
++++++++++++-  (use "git add <file>..." to update what will be committed)
+++++++++++++  (use "git add/rm <file>..." to update what will be committed)
++++++++++++   (use "git restore <file>..." to discard changes in working directory)
++++++++++++-	modified:   README.md
++++++++++++-	modified:   env.py
++++++++++++-	modified:   exp.py
++++++++++++-	modified:   ring.py
+++++++++++++	deleted:    highway_bottleneck.py
+++++++++++++	deleted:    highway_ramp.py
+++++++++++++	deleted:    intersection.py
++++++++++++ 	modified:   ring_different_veh.py
++++++++++++-	modified:   u.py
++++++++++++-
++++++++++++-Untracked files:
++++++++++++-  (use "git add <file>..." to include in what will be committed)
++++++++++++-	pareto/single_ring/different_veh/
+++++++++++  
+++++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++++++ no changes added to commit (use "git add" and/or "git commit -a")
++++++++++++\ No newline at end of file
+++++++++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
+++++++++++-index 127f673..878e4c8 100644
++++++++++++index 57ad1e2..2e160eb 100644
+++++++++++ --- a/ring_different_veh.py
+++++++++++ +++ b/ring_different_veh.py
+++++++++++-@@ -5,8 +5,15 @@
+++++++++++- from exp import *  # Import all from experimental utilities
+++++++++++- from env import *  # Import all from environment utilities
+++++++++++- from u import *    # Import all from utility functions
+++++++++++-+import os
+++++++++++- 
+++++++++++--# Define the RingEnv class which inherits from the Env class
+++++++++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++++++++-+
+++++++++++-+
+++++++++++-+'''
+++++++++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
+++++++++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
+++++++++++-+'''
+++++++++++- class RingEnv(Env):
+++++++++++-     def def_sumo(self):
+++++++++++-         c = self.c  # Access configuration object
+++++++++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
+++++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++++++++@@ -81,9 +81,9 @@ class RingEnv(Env):
++++++++++++             }),
++++++++++++             # Build a closed route on the ring road with the specified number of vehicles
++++++++++++             *build_closed_route(
++++++++++++-                edges,
++++++++++++-                c.n_veh,
++++++++++++-                c.av,
+++++++++++++                edges = edges,
+++++++++++++                n_veh= c.n_veh,
+++++++++++++                av = c.av ,
++++++++++++                 space=c.initial_space
++++++++++++             )
+++++++++++          )
+++++++++++--
+++++++++++-         # Function to generate the shape of the edges (circular arcs)
+++++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++++++@@ -120,140 +120,20 @@ class RingEnv(Env):
++++++++++++                 self.last_vehicle = vehicles_on_edge[0]
++++++++++++                 self.passed_vehicle.append(self.last_vehicle)
+++++++++++  
+++++++++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
+++++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++++++++-         return stats
+++++++++++--
+++++++++++-+    
+++++++++++-+    def calculate_flow(self):
+++++++++++-+        """
+++++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++++++++-+        """
+++++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++++++++-+        if len(vehicles_on_edge) != 0:     
+++++++++++-+            if vehicles_on_edge[0] != self.last_vehicle:
+++++++++++-+                self.last_vehicle = vehicles_on_edge[0]
+++++++++++-+                self.passed_vehicle.append(self.last_vehicle)
+++++++++++-+
+++++++++++-+
+++++++++++-+                    
++++++++++++-
++++++++++++                     
+++++++++++      def step(self, action=None):
+++++++++++          c = self.c  # Configuration object
+++++++++++-         ts = self.ts  # Time step object
+++++++++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
+++++++++++-                     # Change to a specific lane
+++++++++++-                     ts.lane_change_to(rl, lc)
+++++++++++- 
+++++++++++-+        
+++++++++++-         super().step()  # Advance the simulation by one step
+++++++++++- 
+++++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
+++++++++++- 
+++++++++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++++++++- 
+++++++++++-+        # Calculate flow at the end of each step
+++++++++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++++++-+        
+++++++++++-         # Calculate safety surrogate measures
+++++++++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++++++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
+++++++++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
+++++++++++-         return fleet_pet
+++++++++++- 
+++++++++++--# Define the Ring class which inherits from the Main class
+++++++++++-+
+++++++++++-+'''
+++++++++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
+++++++++++-+    It defines how the environment is created and configured, 
+++++++++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
+++++++++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
+++++++++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
+++++++++++-+'''
+++++++++++- class Ring(Main):
+++++++++++-     # Method to create and return the environment
+++++++++++-     def create_env(c):
+++++++++++-@@ -391,7 +421,7 @@ class Ring(Main):
+++++++++++- 
+++++++++++- if __name__ == '__main__':
+++++++++++-     # Run the test with different numbers of vehicles
+++++++++++--    for n_veh in range(40, 100, 10):
+++++++++++-+    for n_veh in range(20, 40, 10):
+++++++++++-         print(f"Running simulation with {n_veh} vehicles")
+++++++++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
+++++++++++-         c = Ring.from_args(globals(), locals()).setdefaults(
+++++++++++-diff --git a/u.py b/u.py
+++++++++++-index 09845aa..8e11a17 100644
+++++++++++---- a/u.py
+++++++++++-+++ b/u.py
+++++++++++-@@ -11,6 +11,8 @@ import warnings
+++++++++++- warnings.filterwarnings('ignore')
++++++++++++-        ts = self.ts  # Time step object
++++++++++++-        max_speed = c.max_speed  # Max vehicle speed
++++++++++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
++++++++++++-        circ_min = c.circumference_min  # Min circumference for normalization
++++++++++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
++++++++++++-
++++++++++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
++++++++++++-            super().step()
++++++++++++-            return c.observation_space.low, 0, False, 0
++++++++++++-
++++++++++++-        
++++++++++++-        super().step()  # Advance the simulation by one step
++++++++++++-
++++++++++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++++++-            print('Detected collision')
++++++++++++-            return c.observation_space.low, -c.collision_penalty, True, None
++++++++++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
++++++++++++-            print('Bad initialization occurred, fix the initialization function')
++++++++++++-            return c.observation_space.low, 0, True, None
++++++++++++-
++++++++++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
++++++++++++-        if c.n_lanes == 1:
++++++++++++-            # Single-lane observation space representation
++++++++++++-            obs = [
++++++++++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
++++++++++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
++++++++++++-                dist / max_dist                 # Normalized headway distance
++++++++++++-            ]
++++++++++++-            if c.circ_feature:
++++++++++++-                # Add normalized circumference feature
++++++++++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
++++++++++++-            if c.accel_feature:
++++++++++++-                # Add leader acceleration feature
++++++++++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
++++++++++++-        elif c.n_lanes == 2:
++++++++++++-            # Two-lane observation space representation
++++++++++++-            lane = rl.lane
++++++++++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
++++++++++++-            if c.symmetric:
++++++++++++-                # Symmetric lane observations
++++++++++++-                other_lane = rl.lane.left or rl.lane.right
++++++++++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++++++-                obs = np.concatenate([
++++++++++++-                    # Normalized speeds of vehicles in the current and other lane
++++++++++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
++++++++++++-                    # Normalized distances to the leader and follower vehicles
++++++++++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
++++++++++++-                ])
++++++++++++-            else:
++++++++++++-                # Asymmetric lane observations
++++++++++++-                obs = [rl.speed]
++++++++++++-                for lane in rl.edge.lanes:
++++++++++++-                    is_rl_lane = lane == rl.lane
++++++++++++-                    if is_rl_lane:
++++++++++++-                        # Observations for the lane in which RL vehicle is currently present
++++++++++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++++++++++-                    else:
++++++++++++-                        # Observations for the other lane
++++++++++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++++++++++-                # Normalize the observations
++++++++++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
++++++++++++-        else:
++++++++++++-            # Multi-lane observation space representation (for more than two lanes)
++++++++++++-            obs = [rl.speed]
++++++++++++-            follower, fdist = rl.follower()
++++++++++++-            for lane in rl.edge.lanes:
++++++++++++-                is_rl_lane = lane == rl.lane
++++++++++++-                if is_rl_lane:
++++++++++++-                    # Observations for the current lane
++++++++++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++++++++++-                else:
++++++++++++-                    # Observations for other lanes
++++++++++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++++++++++-            # Normalize the observations
++++++++++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
++++++++++++-
++++++++++++-        if c.mrtl:
++++++++++++-            # If mrtl is enabled, add beta to observations
++++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++++++-        # Clip and scale observations to the specified range
++++++++++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
++++++++++++-
++++++++++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
++++++++++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
++++++++++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
++++++++++++-            # Apply penalty for acceleration changes
++++++++++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
++++++++++++-
++++++++++++-        self.last_speed = rl.speed  # Update last speed for next step
++++++++++++-
++++++++++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++++++++++-
++++++++++++-        # Calculate flow at the end of each step
++++++++++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++++++++++-        
++++++++++++-        # Calculate safety surrogate measures
++++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++++++++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
++++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
++++++++++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
++++++++++++-
++++++++++++-        raw_pet = self.calc_pet()
++++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
++++++++++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
++++++++++++-
++++++++++++-        # Combine safety measures into a single value for the reward
++++++++++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
++++++++++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
++++++++++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
++++++++++++-
++++++++++++-        # Return observations, reward, and other rollout information
++++++++++++-        returned = dict(
++++++++++++-            obs=obs.astype(np.float32),  # Observations
++++++++++++-            reward=reward,               # Final reward value
++++++++++++-            speed_reward=speed_reward,   # Component of reward due to speed
++++++++++++-            ttc=ttc,                     # Time to collision value
++++++++++++-            drac=drac,                   # Deceleration rate to avoid collision
++++++++++++-            pet=pet,                     # Post-encroachment time
++++++++++++-            ssm=ssm,                     # Combined safety surrogate measure
++++++++++++-            raw_ttc=raw_ttc,             # Raw TTC value
++++++++++++-            raw_drac=raw_drac,           # Raw DRAC value
++++++++++++-            raw_pet=raw_pet              # Raw PET value
++++++++++++-        )
++++++++++++-        return returned
+++++++++++++        ts = self.ts  # Traffuc state object
+++++++++++++        c, ts = self.c, self.ts
+++++++++++++        for veh in ts.types.human.vehicles:
+++++++++++++            leader, headway = veh.leader()
+++++++++++++            v = veh.speed
+++++++++++++            s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
+++++++++++++            a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
+++++++++++++            noise = np.random.normal(0, idm.sigma)
+++++++++++++            ts.accel(veh, a + noise)
+++++++++++++        self._step += 1
+++++++++++++        return c.observation_space.low, 0, False, None
+++++++++++  
+++++++++++- from io import StringIO
+++++++++++-+import os
+++++++++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++++++++     # Calculate the average Time to Collision (TTC) for all vehicles
++++++++++++     def calc_ttc(self):
++++++++++++@@ -420,26 +300,6 @@ if __name__ == '__main__':
++++++++++++                 n_veh=n_veh,  # Number of vehicles
++++++++++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
++++++++++++             )
++++++++++++-        elif c.n_lanes == 2:
++++++++++++-            c.setdefaults(
++++++++++++-                n_veh= int(n_veh*2),
++++++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++++++++-                symmetric=False,
++++++++++++-                symmetric_action=None,
++++++++++++-                lc_av=2
++++++++++++-            )
++++++++++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
++++++++++++-        elif c.n_lanes == 3:
++++++++++++-            c.setdefaults(
++++++++++++-                n_veh=66,
++++++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++++++++-                symmetric=False,
++++++++++++-                symmetric_action=None,
++++++++++++-                lc_av=3,
++++++++++++-                _n_obs=1 + 3 * (1 + 2 * 2)
++++++++++++-            )
++++++++++++-        if c.mrtl:
++++++++++++-            c._n_obs += 1  # Increase observation size for mrtl
+++++++++++  
+++++++++++- def lrange(*args, **kwargs):
+++++++++++-     return list(range(*args, **kwargs))
+++++++++++\ No newline at end of file
++++++++++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
++++++++++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
+++++++++++\ No newline at end of file
+++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++++index 6dd4b74..b5f8d76 100644
+++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++++@@ -1 +1 @@
+++++++++++-5212a280909582c6efe2a4607d1c48e7247a3514
+++++++++++\ No newline at end of file
++++++++++++08748e726448dbe1cefcc92787467792133761ac
+++++++++++\ No newline at end of file
+++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++++index 2c19369..8072657 100644
+++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++++@@ -2,17 +2,16 @@ On branch main
+++++++++++ Your branch is up to date with 'origin/main'.
++++++++++  
++++++++++-+        # Calculate flow at the end of each step
++++++++++-+        flow = self.calculate_flow()
++++++++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
++++++++++-+        
++++++++++-         super().step()  # Advance the simulation by one step
+++++++++++ Changes not staged for commit:
+++++++++++-  (use "git add <file>..." to update what will be committed)
++++++++++++  (use "git add/rm <file>..." to update what will be committed)
+++++++++++   (use "git restore <file>..." to discard changes in working directory)
+++++++++++-	modified:   README.md
+++++++++++ 	modified:   env.py
+++++++++++ 	modified:   exp.py
+++++++++++-	modified:   ring.py
++++++++++++	deleted:    highway_bottleneck.py
++++++++++++	deleted:    highway_ramp.py
++++++++++++	deleted:    intersection.py
++++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++++ 	modified:   ring_different_veh.py
+++++++++++-	modified:   u.py
+++++++++++-
+++++++++++-Untracked files:
+++++++++++-  (use "git add <file>..." to include in what will be committed)
+++++++++++-	pareto/single_ring/different_veh/
++++++++++  
++++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++++ no changes added to commit (use "git add" and/or "git commit -a")
+++++++++++\ No newline at end of file
++++++++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
++++++++++-index 127f673..878e4c8 100644
+++++++++++index 57ad1e2..6d7654e 100644
++++++++++ --- a/ring_different_veh.py
++++++++++ +++ b/ring_different_veh.py
++++++++++-@@ -5,8 +5,15 @@
++++++++++- from exp import *  # Import all from experimental utilities
++++++++++- from env import *  # Import all from environment utilities
++++++++++- from u import *    # Import all from utility functions
++++++++++-+import os
++++++++++- 
++++++++++--# Define the RingEnv class which inherits from the Env class
++++++++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++++++-+
++++++++++-+
++++++++++-+'''
++++++++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
++++++++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
++++++++++-+'''
++++++++++- class RingEnv(Env):
++++++++++-     def def_sumo(self):
++++++++++-         c = self.c  # Access configuration object
++++++++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
++++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++++++++@@ -71,7 +71,7 @@ class RingEnv(Env):
+++++++++++                 )
+++++++++++             }),
+++++++++++             # Define the vehicle type for RL-controlled vehicles
+++++++++++-            E('vType', id='human', **{
++++++++++++            E('vType', id='rl', **{
+++++++++++                 **IDM, **LC2013, **dict(
+++++++++++                     accel=1,
+++++++++++                     decel=1.5,
+++++++++++@@ -81,9 +81,9 @@ class RingEnv(Env):
+++++++++++             }),
+++++++++++             # Build a closed route on the ring road with the specified number of vehicles
+++++++++++             *build_closed_route(
+++++++++++-                edges,
+++++++++++-                c.n_veh,
+++++++++++-                c.av,
++++++++++++                edges = edges,
++++++++++++                n_veh= c.n_veh,
++++++++++++                av = c.av ,
+++++++++++                 space=c.initial_space
+++++++++++             )
++++++++++          )
++++++++++--
++++++++++-         # Function to generate the shape of the edges (circular arcs)
++++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++++++++++@@ -120,140 +120,20 @@ class RingEnv(Env):
+++++++++++                 self.last_vehicle = vehicles_on_edge[0]
+++++++++++                 self.passed_vehicle.append(self.last_vehicle)
++++++++++  
++++++++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
++++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++++++-         return stats
++++++++++--
++++++++++-+    
++++++++++-+    def calculate_flow(self):
++++++++++-+        """
++++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++++++-+        """
++++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++++++-+        if len(vehicles_on_edge) != 0:     
++++++++++-+            if vehicles_on_edge[0] != self.last_vehicle:
++++++++++-+                self.last_vehicle = vehicles_on_edge[0]
++++++++++-+                self.passed_vehicle.append(self.last_vehicle)
++++++++++-+
++++++++++-+
++++++++++-+                    
+++++++++++-
+++++++++++                     
++++++++++      def step(self, action=None):
++++++++++          c = self.c  # Configuration object
++++++++++-         ts = self.ts  # Time step object
++++++++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
++++++++++-                     # Change to a specific lane
++++++++++-                     ts.lane_change_to(rl, lc)
++++++++++- 
++++++++++-+        
++++++++++-         super().step()  # Advance the simulation by one step
++++++++++- 
++++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
++++++++++- 
++++++++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++++++++- 
++++++++++-+        # Calculate flow at the end of each step
++++++++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++++++++-+        
++++++++++-         # Calculate safety surrogate measures
++++++++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++++++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
++++++++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
++++++++++-         return fleet_pet
++++++++++- 
++++++++++--# Define the Ring class which inherits from the Main class
++++++++++-+
++++++++++-+'''
++++++++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
++++++++++-+    It defines how the environment is created and configured, 
++++++++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
++++++++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
++++++++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
++++++++++-+'''
++++++++++- class Ring(Main):
++++++++++-     # Method to create and return the environment
++++++++++-     def create_env(c):
++++++++++-@@ -391,7 +421,7 @@ class Ring(Main):
++++++++++- 
++++++++++- if __name__ == '__main__':
++++++++++-     # Run the test with different numbers of vehicles
++++++++++--    for n_veh in range(40, 100, 10):
++++++++++-+    for n_veh in range(20, 40, 10):
++++++++++-         print(f"Running simulation with {n_veh} vehicles")
++++++++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
++++++++++-         c = Ring.from_args(globals(), locals()).setdefaults(
++++++++++-diff --git a/u.py b/u.py
++++++++++-index 09845aa..8e11a17 100644
++++++++++---- a/u.py
++++++++++-+++ b/u.py
++++++++++-@@ -11,6 +11,8 @@ import warnings
++++++++++- warnings.filterwarnings('ignore')
+++++++++++-        ts = self.ts  # Time step object
+++++++++++-        max_speed = c.max_speed  # Max vehicle speed
+++++++++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
+++++++++++-        circ_min = c.circumference_min  # Min circumference for normalization
+++++++++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
+++++++++++-
+++++++++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
+++++++++++-            super().step()
+++++++++++-            return c.observation_space.low, 0, False, 0
+++++++++++-
+++++++++++-        
+++++++++++-        super().step()  # Advance the simulation by one step
+++++++++++-
+++++++++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++++-            print('Detected collision')
+++++++++++-            return c.observation_space.low, -c.collision_penalty, True, None
+++++++++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
+++++++++++-            print('Bad initialization occurred, fix the initialization function')
+++++++++++-            return c.observation_space.low, 0, True, None
+++++++++++-
+++++++++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
+++++++++++-        if c.n_lanes == 1:
+++++++++++-            # Single-lane observation space representation
+++++++++++-            obs = [
+++++++++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
+++++++++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
+++++++++++-                dist / max_dist                 # Normalized headway distance
+++++++++++-            ]
+++++++++++-            if c.circ_feature:
+++++++++++-                # Add normalized circumference feature
+++++++++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
+++++++++++-            if c.accel_feature:
+++++++++++-                # Add leader acceleration feature
+++++++++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
+++++++++++-        elif c.n_lanes == 2:
+++++++++++-            # Two-lane observation space representation
+++++++++++-            lane = rl.lane
+++++++++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
+++++++++++-            if c.symmetric:
+++++++++++-                # Symmetric lane observations
+++++++++++-                other_lane = rl.lane.left or rl.lane.right
+++++++++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++++-                obs = np.concatenate([
+++++++++++-                    # Normalized speeds of vehicles in the current and other lane
+++++++++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
+++++++++++-                    # Normalized distances to the leader and follower vehicles
+++++++++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
+++++++++++-                ])
+++++++++++-            else:
+++++++++++-                # Asymmetric lane observations
+++++++++++-                obs = [rl.speed]
+++++++++++-                for lane in rl.edge.lanes:
+++++++++++-                    is_rl_lane = lane == rl.lane
+++++++++++-                    if is_rl_lane:
+++++++++++-                        # Observations for the lane in which RL vehicle is currently present
+++++++++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++++++-                    else:
+++++++++++-                        # Observations for the other lane
+++++++++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++++++-                # Normalize the observations
+++++++++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
+++++++++++-        else:
+++++++++++-            # Multi-lane observation space representation (for more than two lanes)
+++++++++++-            obs = [rl.speed]
+++++++++++-            follower, fdist = rl.follower()
+++++++++++-            for lane in rl.edge.lanes:
+++++++++++-                is_rl_lane = lane == rl.lane
+++++++++++-                if is_rl_lane:
+++++++++++-                    # Observations for the current lane
+++++++++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++++++-                else:
+++++++++++-                    # Observations for other lanes
+++++++++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++++++-            # Normalize the observations
+++++++++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
+++++++++++-
+++++++++++-        if c.mrtl:
+++++++++++-            # If mrtl is enabled, add beta to observations
+++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++++-        # Clip and scale observations to the specified range
+++++++++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
+++++++++++-
+++++++++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
+++++++++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
+++++++++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
+++++++++++-            # Apply penalty for acceleration changes
+++++++++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
+++++++++++-
+++++++++++-        self.last_speed = rl.speed  # Update last speed for next step
+++++++++++-
+++++++++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++++++++-
+++++++++++-        # Calculate flow at the end of each step
+++++++++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++++++-        
+++++++++++-        # Calculate safety surrogate measures
+++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++++++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
+++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
+++++++++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
+++++++++++-
+++++++++++-        raw_pet = self.calc_pet()
+++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
+++++++++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
+++++++++++-
+++++++++++-        # Combine safety measures into a single value for the reward
+++++++++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
+++++++++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
+++++++++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
+++++++++++-
+++++++++++-        # Return observations, reward, and other rollout information
+++++++++++-        returned = dict(
+++++++++++-            obs=obs.astype(np.float32),  # Observations
+++++++++++-            reward=reward,               # Final reward value
+++++++++++-            speed_reward=speed_reward,   # Component of reward due to speed
+++++++++++-            ttc=ttc,                     # Time to collision value
+++++++++++-            drac=drac,                   # Deceleration rate to avoid collision
+++++++++++-            pet=pet,                     # Post-encroachment time
+++++++++++-            ssm=ssm,                     # Combined safety surrogate measure
+++++++++++-            raw_ttc=raw_ttc,             # Raw TTC value
+++++++++++-            raw_drac=raw_drac,           # Raw DRAC value
+++++++++++-            raw_pet=raw_pet              # Raw PET value
+++++++++++-        )
+++++++++++-        return returned
++++++++++++        ts = self.ts  # Traffuc state object
++++++++++++        c, ts = self.c, self.ts
++++++++++++        for veh in ts.types.human.vehicles:
++++++++++++            leader, headway = veh.leader()
++++++++++++            v = veh.speed
++++++++++++            s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
++++++++++++            a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
++++++++++++            noise = np.random.normal(0, idm.sigma)
++++++++++++            ts.accel(veh, a + noise)
++++++++++++        self._step += 1
++++++++++++        return c.observation_space.low, 0, False, None
++++++++++  
++++++++++- from io import StringIO
++++++++++-+import os
++++++++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++++++++     # Calculate the average Time to Collision (TTC) for all vehicles
+++++++++++     def calc_ttc(self):
+++++++++++@@ -420,26 +300,6 @@ if __name__ == '__main__':
+++++++++++                 n_veh=n_veh,  # Number of vehicles
+++++++++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
+++++++++++             )
+++++++++++-        elif c.n_lanes == 2:
+++++++++++-            c.setdefaults(
+++++++++++-                n_veh= int(n_veh*2),
+++++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++++++++-                symmetric=False,
+++++++++++-                symmetric_action=None,
+++++++++++-                lc_av=2
+++++++++++-            )
+++++++++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
+++++++++++-        elif c.n_lanes == 3:
+++++++++++-            c.setdefaults(
+++++++++++-                n_veh=66,
+++++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++++++++-                symmetric=False,
+++++++++++-                symmetric_action=None,
+++++++++++-                lc_av=3,
+++++++++++-                _n_obs=1 + 3 * (1 + 2 * 2)
+++++++++++-            )
+++++++++++-        if c.mrtl:
+++++++++++-            c._n_obs += 1  # Increase observation size for mrtl
++++++++++  
++++++++++- def lrange(*args, **kwargs):
++++++++++-     return list(range(*args, **kwargs))
++++++++++\ No newline at end of file
+++++++++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
+++++++++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
++++++++++\ No newline at end of file
++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++index 6dd4b74..b5f8d76 100644
++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++@@ -1 +1 @@
++++++++++-5212a280909582c6efe2a4607d1c48e7247a3514
++++++++++\ No newline at end of file
+++++++++++08748e726448dbe1cefcc92787467792133761ac
++++++++++\ No newline at end of file
++++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++index 2c19369..8072657 100644
++++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++@@ -2,17 +2,16 @@ On branch main
++++++++++ Your branch is up to date with 'origin/main'.
+++++++++  
+++++++++-+        # Calculate flow at the end of each step
+++++++++-+        flow = self.calculate_flow()
+++++++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
+++++++++-+        
+++++++++-         super().step()  # Advance the simulation by one step
++++++++++ Changes not staged for commit:
++++++++++-  (use "git add <file>..." to update what will be committed)
+++++++++++  (use "git add/rm <file>..." to update what will be committed)
++++++++++   (use "git restore <file>..." to discard changes in working directory)
++++++++++-	modified:   README.md
++++++++++ 	modified:   env.py
++++++++++ 	modified:   exp.py
++++++++++-	modified:   ring.py
+++++++++++	deleted:    highway_bottleneck.py
+++++++++++	deleted:    highway_ramp.py
+++++++++++	deleted:    intersection.py
+++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++ 	modified:   ring_different_veh.py
++++++++++-	modified:   u.py
++++++++++-
++++++++++-Untracked files:
++++++++++-  (use "git add <file>..." to include in what will be committed)
++++++++++-	pareto/single_ring/different_veh/
+++++++++  
+++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++++ no changes added to commit (use "git add" and/or "git commit -a")
++++++++++\ No newline at end of file
+++++++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
+++++++++-index 127f673..878e4c8 100644
++++++++++index 57ad1e2..6d7654e 100644
+++++++++ --- a/ring_different_veh.py
+++++++++ +++ b/ring_different_veh.py
+++++++++-@@ -5,8 +5,15 @@
+++++++++- from exp import *  # Import all from experimental utilities
+++++++++- from env import *  # Import all from environment utilities
+++++++++- from u import *    # Import all from utility functions
+++++++++-+import os
+++++++++- 
+++++++++--# Define the RingEnv class which inherits from the Env class
+++++++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++++++-+
+++++++++-+
+++++++++-+'''
+++++++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
+++++++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
+++++++++-+'''
+++++++++- class RingEnv(Env):
+++++++++-     def def_sumo(self):
+++++++++-         c = self.c  # Access configuration object
+++++++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
+++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++++++@@ -71,7 +71,7 @@ class RingEnv(Env):
++++++++++                 )
++++++++++             }),
++++++++++             # Define the vehicle type for RL-controlled vehicles
++++++++++-            E('vType', id='human', **{
+++++++++++            E('vType', id='rl', **{
++++++++++                 **IDM, **LC2013, **dict(
++++++++++                     accel=1,
++++++++++                     decel=1.5,
++++++++++@@ -81,9 +81,9 @@ class RingEnv(Env):
++++++++++             }),
++++++++++             # Build a closed route on the ring road with the specified number of vehicles
++++++++++             *build_closed_route(
++++++++++-                edges,
++++++++++-                c.n_veh,
++++++++++-                c.av,
+++++++++++                edges = edges,
+++++++++++                n_veh= c.n_veh,
+++++++++++                av = c.av ,
++++++++++                 space=c.initial_space
++++++++++             )
+++++++++          )
+++++++++--
+++++++++-         # Function to generate the shape of the edges (circular arcs)
+++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++++@@ -120,140 +120,20 @@ class RingEnv(Env):
++++++++++                 self.last_vehicle = vehicles_on_edge[0]
++++++++++                 self.passed_vehicle.append(self.last_vehicle)
+++++++++  
+++++++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
+++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++++++-         return stats
+++++++++--
+++++++++-+    
+++++++++-+    def calculate_flow(self):
+++++++++-+        """
+++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++++++-+        """
+++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++++++-+        if len(vehicles_on_edge) != 0:     
+++++++++-+            if vehicles_on_edge[0] != self.last_vehicle:
+++++++++-+                self.last_vehicle = vehicles_on_edge[0]
+++++++++-+                self.passed_vehicle.append(self.last_vehicle)
+++++++++-+
+++++++++-+
+++++++++-+                    
++++++++++-
++++++++++                     
+++++++++      def step(self, action=None):
+++++++++          c = self.c  # Configuration object
+++++++++-         ts = self.ts  # Time step object
+++++++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
+++++++++-                     # Change to a specific lane
+++++++++-                     ts.lane_change_to(rl, lc)
+++++++++- 
+++++++++-+        
+++++++++-         super().step()  # Advance the simulation by one step
+++++++++- 
+++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
+++++++++- 
+++++++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++++++- 
+++++++++-+        # Calculate flow at the end of each step
+++++++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++++-+        
+++++++++-         # Calculate safety surrogate measures
+++++++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
+++++++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
+++++++++-         return fleet_pet
+++++++++- 
+++++++++--# Define the Ring class which inherits from the Main class
+++++++++-+
+++++++++-+'''
+++++++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
+++++++++-+    It defines how the environment is created and configured, 
+++++++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
+++++++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
+++++++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
+++++++++-+'''
+++++++++- class Ring(Main):
+++++++++-     # Method to create and return the environment
+++++++++-     def create_env(c):
+++++++++-@@ -391,7 +421,7 @@ class Ring(Main):
+++++++++- 
+++++++++- if __name__ == '__main__':
+++++++++-     # Run the test with different numbers of vehicles
+++++++++--    for n_veh in range(40, 100, 10):
+++++++++-+    for n_veh in range(20, 40, 10):
+++++++++-         print(f"Running simulation with {n_veh} vehicles")
+++++++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
+++++++++-         c = Ring.from_args(globals(), locals()).setdefaults(
+++++++++-diff --git a/u.py b/u.py
+++++++++-index 09845aa..8e11a17 100644
+++++++++---- a/u.py
+++++++++-+++ b/u.py
+++++++++-@@ -11,6 +11,8 @@ import warnings
+++++++++- warnings.filterwarnings('ignore')
++++++++++-        ts = self.ts  # Time step object
++++++++++-        max_speed = c.max_speed  # Max vehicle speed
++++++++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
++++++++++-        circ_min = c.circumference_min  # Min circumference for normalization
++++++++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
++++++++++-
++++++++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
++++++++++-            super().step()
++++++++++-            return c.observation_space.low, 0, False, 0
++++++++++-
++++++++++-        
++++++++++-        super().step()  # Advance the simulation by one step
++++++++++-
++++++++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++++-            print('Detected collision')
++++++++++-            return c.observation_space.low, -c.collision_penalty, True, None
++++++++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
++++++++++-            print('Bad initialization occurred, fix the initialization function')
++++++++++-            return c.observation_space.low, 0, True, None
++++++++++-
++++++++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
++++++++++-        if c.n_lanes == 1:
++++++++++-            # Single-lane observation space representation
++++++++++-            obs = [
++++++++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
++++++++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
++++++++++-                dist / max_dist                 # Normalized headway distance
++++++++++-            ]
++++++++++-            if c.circ_feature:
++++++++++-                # Add normalized circumference feature
++++++++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
++++++++++-            if c.accel_feature:
++++++++++-                # Add leader acceleration feature
++++++++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
++++++++++-        elif c.n_lanes == 2:
++++++++++-            # Two-lane observation space representation
++++++++++-            lane = rl.lane
++++++++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
++++++++++-            if c.symmetric:
++++++++++-                # Symmetric lane observations
++++++++++-                other_lane = rl.lane.left or rl.lane.right
++++++++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++++-                obs = np.concatenate([
++++++++++-                    # Normalized speeds of vehicles in the current and other lane
++++++++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
++++++++++-                    # Normalized distances to the leader and follower vehicles
++++++++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
++++++++++-                ])
++++++++++-            else:
++++++++++-                # Asymmetric lane observations
++++++++++-                obs = [rl.speed]
++++++++++-                for lane in rl.edge.lanes:
++++++++++-                    is_rl_lane = lane == rl.lane
++++++++++-                    if is_rl_lane:
++++++++++-                        # Observations for the lane in which RL vehicle is currently present
++++++++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++++++++-                    else:
++++++++++-                        # Observations for the other lane
++++++++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++++++++-                # Normalize the observations
++++++++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
++++++++++-        else:
++++++++++-            # Multi-lane observation space representation (for more than two lanes)
++++++++++-            obs = [rl.speed]
++++++++++-            follower, fdist = rl.follower()
++++++++++-            for lane in rl.edge.lanes:
++++++++++-                is_rl_lane = lane == rl.lane
++++++++++-                if is_rl_lane:
++++++++++-                    # Observations for the current lane
++++++++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++++++++-                else:
++++++++++-                    # Observations for other lanes
++++++++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++++++++-            # Normalize the observations
++++++++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
++++++++++-
++++++++++-        if c.mrtl:
++++++++++-            # If mrtl is enabled, add beta to observations
++++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++++-        # Clip and scale observations to the specified range
++++++++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
++++++++++-
++++++++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
++++++++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
++++++++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
++++++++++-            # Apply penalty for acceleration changes
++++++++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
++++++++++-
++++++++++-        self.last_speed = rl.speed  # Update last speed for next step
++++++++++-
++++++++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++++++++-
++++++++++-        # Calculate flow at the end of each step
++++++++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++++++++-        
++++++++++-        # Calculate safety surrogate measures
++++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++++++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
++++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
++++++++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
++++++++++-
++++++++++-        raw_pet = self.calc_pet()
++++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
++++++++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
++++++++++-
++++++++++-        # Combine safety measures into a single value for the reward
++++++++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
++++++++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
++++++++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
++++++++++-
++++++++++-        # Return observations, reward, and other rollout information
++++++++++-        returned = dict(
++++++++++-            obs=obs.astype(np.float32),  # Observations
++++++++++-            reward=reward,               # Final reward value
++++++++++-            speed_reward=speed_reward,   # Component of reward due to speed
++++++++++-            ttc=ttc,                     # Time to collision value
++++++++++-            drac=drac,                   # Deceleration rate to avoid collision
++++++++++-            pet=pet,                     # Post-encroachment time
++++++++++-            ssm=ssm,                     # Combined safety surrogate measure
++++++++++-            raw_ttc=raw_ttc,             # Raw TTC value
++++++++++-            raw_drac=raw_drac,           # Raw DRAC value
++++++++++-            raw_pet=raw_pet              # Raw PET value
++++++++++-        )
++++++++++-        return returned
+++++++++++        ts = self.ts  # Traffuc state object
+++++++++++        c, ts = self.c, self.ts
+++++++++++        for veh in ts.types.human.vehicles:
+++++++++++            leader, headway = veh.leader()
+++++++++++            v = veh.speed
+++++++++++            s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
+++++++++++            a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
+++++++++++            noise = np.random.normal(0, idm.sigma)
+++++++++++            ts.accel(veh, a + noise)
+++++++++++        self._step += 1
+++++++++++        return c.observation_space.low, 0, False, None
+++++++++  
+++++++++- from io import StringIO
+++++++++-+import os
+++++++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++++++     # Calculate the average Time to Collision (TTC) for all vehicles
++++++++++     def calc_ttc(self):
++++++++++@@ -420,26 +300,6 @@ if __name__ == '__main__':
++++++++++                 n_veh=n_veh,  # Number of vehicles
++++++++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
++++++++++             )
++++++++++-        elif c.n_lanes == 2:
++++++++++-            c.setdefaults(
++++++++++-                n_veh= int(n_veh*2),
++++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++++++-                symmetric=False,
++++++++++-                symmetric_action=None,
++++++++++-                lc_av=2
++++++++++-            )
++++++++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
++++++++++-        elif c.n_lanes == 3:
++++++++++-            c.setdefaults(
++++++++++-                n_veh=66,
++++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++++++-                symmetric=False,
++++++++++-                symmetric_action=None,
++++++++++-                lc_av=3,
++++++++++-                _n_obs=1 + 3 * (1 + 2 * 2)
++++++++++-            )
++++++++++-        if c.mrtl:
++++++++++-            c._n_obs += 1  # Increase observation size for mrtl
+++++++++  
+++++++++- def lrange(*args, **kwargs):
+++++++++-     return list(range(*args, **kwargs))
+++++++++\ No newline at end of file
++++++++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
++++++++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
+++++++++\ No newline at end of file
+++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++index 6dd4b74..b5f8d76 100644
+++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++@@ -1 +1 @@
+++++++++-5212a280909582c6efe2a4607d1c48e7247a3514
+++++++++\ No newline at end of file
++++++++++08748e726448dbe1cefcc92787467792133761ac
+++++++++\ No newline at end of file
+++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++index 2c19369..8072657 100644
+++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++@@ -2,17 +2,16 @@ On branch main
+++++++++ Your branch is up to date with 'origin/main'.
++++++++  
++++++++-+        # Calculate flow at the end of each step
++++++++-+        flow = self.calculate_flow()
++++++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
++++++++-+        
++++++++-         super().step()  # Advance the simulation by one step
+++++++++ Changes not staged for commit:
+++++++++-  (use "git add <file>..." to update what will be committed)
++++++++++  (use "git add/rm <file>..." to update what will be committed)
+++++++++   (use "git restore <file>..." to discard changes in working directory)
+++++++++-	modified:   README.md
+++++++++ 	modified:   env.py
+++++++++ 	modified:   exp.py
+++++++++-	modified:   ring.py
++++++++++	deleted:    highway_bottleneck.py
++++++++++	deleted:    highway_ramp.py
++++++++++	deleted:    intersection.py
++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++ 	modified:   ring_different_veh.py
+++++++++-	modified:   u.py
+++++++++-
+++++++++-Untracked files:
+++++++++-  (use "git add <file>..." to include in what will be committed)
+++++++++-	pareto/single_ring/different_veh/
++++++++  
++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++ no changes added to commit (use "git add" and/or "git commit -a")
+++++++++\ No newline at end of file
++++++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
++++++++-index 127f673..878e4c8 100644
+++++++++index 57ad1e2..6d7654e 100644
++++++++ --- a/ring_different_veh.py
++++++++ +++ b/ring_different_veh.py
++++++++-@@ -5,8 +5,15 @@
++++++++- from exp import *  # Import all from experimental utilities
++++++++- from env import *  # Import all from environment utilities
++++++++- from u import *    # Import all from utility functions
++++++++-+import os
++++++++- 
++++++++--# Define the RingEnv class which inherits from the Env class
++++++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++++-+
++++++++-+
++++++++-+'''
++++++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
++++++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
++++++++-+'''
++++++++- class RingEnv(Env):
++++++++-     def def_sumo(self):
++++++++-         c = self.c  # Access configuration object
++++++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
++++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++++++@@ -71,7 +71,7 @@ class RingEnv(Env):
+++++++++                 )
+++++++++             }),
+++++++++             # Define the vehicle type for RL-controlled vehicles
+++++++++-            E('vType', id='human', **{
++++++++++            E('vType', id='rl', **{
+++++++++                 **IDM, **LC2013, **dict(
+++++++++                     accel=1,
+++++++++                     decel=1.5,
+++++++++@@ -81,9 +81,9 @@ class RingEnv(Env):
+++++++++             }),
+++++++++             # Build a closed route on the ring road with the specified number of vehicles
+++++++++             *build_closed_route(
+++++++++-                edges,
+++++++++-                c.n_veh,
+++++++++-                c.av,
++++++++++                edges = edges,
++++++++++                n_veh= c.n_veh,
++++++++++                av = c.av ,
+++++++++                 space=c.initial_space
+++++++++             )
++++++++          )
++++++++--
++++++++-         # Function to generate the shape of the edges (circular arcs)
++++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++++++++@@ -120,140 +120,20 @@ class RingEnv(Env):
+++++++++                 self.last_vehicle = vehicles_on_edge[0]
+++++++++                 self.passed_vehicle.append(self.last_vehicle)
++++++++  
++++++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
++++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++++-         return stats
++++++++--
++++++++-+    
++++++++-+    def calculate_flow(self):
++++++++-+        """
++++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++++-+        """
++++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++++-+        if len(vehicles_on_edge) != 0:     
++++++++-+            if vehicles_on_edge[0] != self.last_vehicle:
++++++++-+                self.last_vehicle = vehicles_on_edge[0]
++++++++-+                self.passed_vehicle.append(self.last_vehicle)
++++++++-+
++++++++-+
++++++++-+                    
+++++++++-
+++++++++                     
++++++++      def step(self, action=None):
++++++++          c = self.c  # Configuration object
++++++++-         ts = self.ts  # Time step object
++++++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
++++++++-                     # Change to a specific lane
++++++++-                     ts.lane_change_to(rl, lc)
++++++++- 
++++++++-+        
++++++++-         super().step()  # Advance the simulation by one step
++++++++- 
++++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
++++++++- 
++++++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++++++- 
++++++++-+        # Calculate flow at the end of each step
++++++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++++++-+        
++++++++-         # Calculate safety surrogate measures
++++++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
++++++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
++++++++-         return fleet_pet
++++++++- 
++++++++--# Define the Ring class which inherits from the Main class
++++++++-+
++++++++-+'''
++++++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
++++++++-+    It defines how the environment is created and configured, 
++++++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
++++++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
++++++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
++++++++-+'''
++++++++- class Ring(Main):
++++++++-     # Method to create and return the environment
++++++++-     def create_env(c):
++++++++-@@ -391,7 +421,7 @@ class Ring(Main):
++++++++- 
++++++++- if __name__ == '__main__':
++++++++-     # Run the test with different numbers of vehicles
++++++++--    for n_veh in range(40, 100, 10):
++++++++-+    for n_veh in range(20, 40, 10):
++++++++-         print(f"Running simulation with {n_veh} vehicles")
++++++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
++++++++-         c = Ring.from_args(globals(), locals()).setdefaults(
++++++++-diff --git a/u.py b/u.py
++++++++-index 09845aa..8e11a17 100644
++++++++---- a/u.py
++++++++-+++ b/u.py
++++++++-@@ -11,6 +11,8 @@ import warnings
++++++++- warnings.filterwarnings('ignore')
+++++++++-        ts = self.ts  # Time step object
+++++++++-        max_speed = c.max_speed  # Max vehicle speed
+++++++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
+++++++++-        circ_min = c.circumference_min  # Min circumference for normalization
+++++++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
+++++++++-
+++++++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
+++++++++-            super().step()
+++++++++-            return c.observation_space.low, 0, False, 0
+++++++++-
+++++++++-        
+++++++++-        super().step()  # Advance the simulation by one step
+++++++++-
+++++++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++++-            print('Detected collision')
+++++++++-            return c.observation_space.low, -c.collision_penalty, True, None
+++++++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
+++++++++-            print('Bad initialization occurred, fix the initialization function')
+++++++++-            return c.observation_space.low, 0, True, None
+++++++++-
+++++++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
+++++++++-        if c.n_lanes == 1:
+++++++++-            # Single-lane observation space representation
+++++++++-            obs = [
+++++++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
+++++++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
+++++++++-                dist / max_dist                 # Normalized headway distance
+++++++++-            ]
+++++++++-            if c.circ_feature:
+++++++++-                # Add normalized circumference feature
+++++++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
+++++++++-            if c.accel_feature:
+++++++++-                # Add leader acceleration feature
+++++++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
+++++++++-        elif c.n_lanes == 2:
+++++++++-            # Two-lane observation space representation
+++++++++-            lane = rl.lane
+++++++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
+++++++++-            if c.symmetric:
+++++++++-                # Symmetric lane observations
+++++++++-                other_lane = rl.lane.left or rl.lane.right
+++++++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++-                obs = np.concatenate([
+++++++++-                    # Normalized speeds of vehicles in the current and other lane
+++++++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
+++++++++-                    # Normalized distances to the leader and follower vehicles
+++++++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
+++++++++-                ])
+++++++++-            else:
+++++++++-                # Asymmetric lane observations
+++++++++-                obs = [rl.speed]
+++++++++-                for lane in rl.edge.lanes:
+++++++++-                    is_rl_lane = lane == rl.lane
+++++++++-                    if is_rl_lane:
+++++++++-                        # Observations for the lane in which RL vehicle is currently present
+++++++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++++-                    else:
+++++++++-                        # Observations for the other lane
+++++++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++++-                # Normalize the observations
+++++++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
+++++++++-        else:
+++++++++-            # Multi-lane observation space representation (for more than two lanes)
+++++++++-            obs = [rl.speed]
+++++++++-            follower, fdist = rl.follower()
+++++++++-            for lane in rl.edge.lanes:
+++++++++-                is_rl_lane = lane == rl.lane
+++++++++-                if is_rl_lane:
+++++++++-                    # Observations for the current lane
+++++++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++++-                else:
+++++++++-                    # Observations for other lanes
+++++++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++++-            # Normalize the observations
+++++++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
+++++++++-
+++++++++-        if c.mrtl:
+++++++++-            # If mrtl is enabled, add beta to observations
+++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++++-        # Clip and scale observations to the specified range
+++++++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
+++++++++-
+++++++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
+++++++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
+++++++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
+++++++++-            # Apply penalty for acceleration changes
+++++++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
+++++++++-
+++++++++-        self.last_speed = rl.speed  # Update last speed for next step
+++++++++-
+++++++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++++++-
+++++++++-        # Calculate flow at the end of each step
+++++++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++++-        
+++++++++-        # Calculate safety surrogate measures
+++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
+++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
+++++++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
+++++++++-
+++++++++-        raw_pet = self.calc_pet()
+++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
+++++++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
+++++++++-
+++++++++-        # Combine safety measures into a single value for the reward
+++++++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
+++++++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
+++++++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
+++++++++-
+++++++++-        # Return observations, reward, and other rollout information
+++++++++-        returned = dict(
+++++++++-            obs=obs.astype(np.float32),  # Observations
+++++++++-            reward=reward,               # Final reward value
+++++++++-            speed_reward=speed_reward,   # Component of reward due to speed
+++++++++-            ttc=ttc,                     # Time to collision value
+++++++++-            drac=drac,                   # Deceleration rate to avoid collision
+++++++++-            pet=pet,                     # Post-encroachment time
+++++++++-            ssm=ssm,                     # Combined safety surrogate measure
+++++++++-            raw_ttc=raw_ttc,             # Raw TTC value
+++++++++-            raw_drac=raw_drac,           # Raw DRAC value
+++++++++-            raw_pet=raw_pet              # Raw PET value
+++++++++-        )
+++++++++-        return returned
++++++++++        ts = self.ts  # Traffuc state object
++++++++++        c, ts = self.c, self.ts
++++++++++        for veh in ts.types.human.vehicles:
++++++++++            leader, headway = veh.leader()
++++++++++            v = veh.speed
++++++++++            s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
++++++++++            a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
++++++++++            noise = np.random.normal(0, idm.sigma)
++++++++++            ts.accel(veh, a + noise)
++++++++++        self._step += 1
++++++++++        return c.observation_space.low, 0, False, None
++++++++  
++++++++- from io import StringIO
++++++++-+import os
++++++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++++++     # Calculate the average Time to Collision (TTC) for all vehicles
+++++++++     def calc_ttc(self):
+++++++++@@ -420,26 +300,6 @@ if __name__ == '__main__':
+++++++++                 n_veh=n_veh,  # Number of vehicles
+++++++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
+++++++++             )
+++++++++-        elif c.n_lanes == 2:
+++++++++-            c.setdefaults(
+++++++++-                n_veh= int(n_veh*2),
+++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++++++-                symmetric=False,
+++++++++-                symmetric_action=None,
+++++++++-                lc_av=2
+++++++++-            )
+++++++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
+++++++++-        elif c.n_lanes == 3:
+++++++++-            c.setdefaults(
+++++++++-                n_veh=66,
+++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++++++-                symmetric=False,
+++++++++-                symmetric_action=None,
+++++++++-                lc_av=3,
+++++++++-                _n_obs=1 + 3 * (1 + 2 * 2)
+++++++++-            )
+++++++++-        if c.mrtl:
+++++++++-            c._n_obs += 1  # Increase observation size for mrtl
++++++++  
++++++++- def lrange(*args, **kwargs):
++++++++-     return list(range(*args, **kwargs))
++++++++\ No newline at end of file
+++++++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
+++++++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
++++++++\ No newline at end of file
++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++index 6dd4b74..b5f8d76 100644
++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++@@ -1 +1 @@
++++++++-5212a280909582c6efe2a4607d1c48e7247a3514
++++++++\ No newline at end of file
+++++++++08748e726448dbe1cefcc92787467792133761ac
++++++++\ No newline at end of file
++++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++index 2c19369..34859e8 100644
++++++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++@@ -2,17 +2,20 @@ On branch main
++++++++ Your branch is up to date with 'origin/main'.
+++++++  
+++++++-@@ -398,10 +408,10 @@ class Main(Config):
+++++++-         # Main training loop
+++++++-         c.on_train_start()
+++++++-         while c._i < c.n_steps:
+++++++--            c.on_step_start()
+++++++-+            c.on_step_start() # save stat 
+++++++-             with torch.no_grad():
+++++++-                 # Collect rollouts without computing gradients
+++++++--                rollouts = c.rollouts()
+++++++-+                rollouts = c.rollouts() # every time collect 1 eps trajectory to update algo
+++++++-             gd_stats = {}
+++++++-             if len(rollouts.obs):
+++++++-                 t_start = time()
+++++++-@@ -410,7 +420,7 @@ class Main(Config):
+++++++-                 gd_stats.update(gd_time=time() - t_start)
+++++++-             c.on_step_end(gd_stats)
+++++++-             c._i += 1
+++++++--        c.on_step_start()  # last step
+++++++-+        c.on_step_start()  # save stat
+++++++-         gd_stats = {}
+++++++-         with torch.no_grad():
+++++++-             rollouts = c.rollouts()
+++++++-@@ -450,6 +460,8 @@ class Main(Config):
+++++++-         if hasattr(c._env, 'close'):
+++++++-             c._env.close()
++++++++ Changes not staged for commit:
++++++++-  (use "git add <file>..." to update what will be committed)
+++++++++  (use "git add/rm <file>..." to update what will be committed)
++++++++   (use "git restore <file>..." to discard changes in working directory)
++++++++-	modified:   README.md
++++++++ 	modified:   env.py
++++++++ 	modified:   exp.py
++++++++-	modified:   ring.py
+++++++++	deleted:    highway_bottleneck.py
+++++++++	deleted:    highway_ramp.py
+++++++++	deleted:    intersection.py
+++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++ 	modified:   ring_different_veh.py
++++++++-	modified:   u.py
+++++++  
+++++++-+  
+++++++-+
+++++++-     def run(c):
+++++++-         # Determine whether to train or evaluate based on configuration
+++++++-         c.log(format_yaml({k: v for k, v in c.items() if not k.startswith('_')}))
+++++++-diff --git a/ring.py b/ring.py
+++++++-index 94d632d..ee1372b 100644
+++++++---- a/ring.py
+++++++-+++ b/ring.py
+++++++-@@ -15,7 +15,6 @@ class RingEnv(Env):
+++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++++-         )
+++++++--
+++++++-         # Function to generate the shape of the edges (circular arcs)
+++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++ Untracked files:
++++++++   (use "git add <file>..." to include in what will be committed)
++++++++-	pareto/single_ring/different_veh/
+++++++++	ring_2.py
+++++++  
+++++++-@@ -88,6 +87,17 @@ class RingEnv(Env):
++++++++ no changes added to commit (use "git add" and/or "git commit -a")
++++++++\ No newline at end of file
++++++++diff --git a/ring_different_veh.py b/ring_different_veh.py
++++++++index 57ad1e2..224121d 100644
++++++++--- a/ring_different_veh.py
+++++++++++ b/ring_different_veh.py
++++++++@@ -71,7 +71,7 @@ class RingEnv(Env):
++++++++                 )
++++++++             }),
++++++++             # Define the vehicle type for RL-controlled vehicles
++++++++-            E('vType', id='human', **{
+++++++++            E('vType', id='rl', **{
++++++++                 **IDM, **LC2013, **dict(
++++++++                     accel=1,
++++++++                     decel=1.5,
++++++++@@ -94,8 +94,7 @@ class RingEnv(Env):
+++++++          if c.circumference_range:  # Check if the circumference should be randomized
+++++++              # Randomly set the circumference within the specified range
+++++++              c.circumference = np.random.randint(*c.circumference_range)
++++++++-        return super().reset_sumo()  # Reset the simulation
++++++++-
+++++++ +        
+++++++-+        if self.flow_log:
+++++++-+            average_flow = sum(self.flow_log) / len(self.flow_log)
+++++++-+            self.episode_flow.append(average_flow)
+++++++-+            print(f"Average vehicle flow for the episode: {average_flow:.2f} vehicles/hour")
+++++++-+        
+++++++-+        # Reset flow counters for the new episode
+++++++-+        self.flow_counter = 0
+++++++-+        self.flow_log = []
+++++++-+        self.last_vehicle_times = {}
+++++++-+        
+++++++-         return super().reset_sumo()  # Reset the simulation
+++++++- 
+++++++      @property
+++++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
+++++++-         }
+++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
+++++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
+++++++-         return stats
+++++++--
+++++++-+    
+++++++-+    def calculate_flow(self):
+++++++-+        """
+++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++++-+        """
+++++++-+        current_time = self.ts.time
+++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++++-+
+++++++-+        for vehicle in vehicles_on_edge:
+++++++-+            # Check if vehicle has passed the observation point since the last timestep
+++++++-+            if vehicle.id not in self.last_vehicle_times:
+++++++-+                # If the vehicle was not previously recorded, count it as a new passage
+++++++-+                self.flow_counter += 1
+++++++-+            else:
+++++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
+++++++-+                last_time = self.last_vehicle_times[vehicle.id]
+++++++-+                if current_time - last_time > self.c.sim_step:
+++++++-+                    self.flow_counter += 1
+++++++-+
+++++++-+            # Update the last time the vehicle passed the point
+++++++-+            self.last_vehicle_times[vehicle.id] = current_time
+++++++-+
+++++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
+++++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
+++++++-+        self.flow_log.append(flow_per_hour)
+++++++-+        return flow_per_hour
+++++++-+    
+++++++-     def step(self, action=None):
+++++++-         c = self.c  # Configuration object
+++++++-         ts = self.ts  # Time step object
+++++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
+++++++-                     # Change to a specific lane
+++++++-                     ts.lane_change_to(rl, lc)
+++++++- 
+++++++-+        # Calculate flow at the end of each step
+++++++-+        flow = self.calculate_flow()
+++++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
+++++++-+        
+++++++-         super().step()  # Advance the simulation by one step
+++++++- 
+++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++-diff --git a/ring_different_veh.py b/ring_different_veh.py
+++++++-index 127f673..878e4c8 100644
+++++++---- a/ring_different_veh.py
+++++++-+++ b/ring_different_veh.py
+++++++-@@ -5,8 +5,15 @@
+++++++- from exp import *  # Import all from experimental utilities
+++++++- from env import *  # Import all from environment utilities
+++++++- from u import *    # Import all from utility functions
+++++++-+import os
+++++++- 
+++++++--# Define the RingEnv class which inherits from the Env class
+++++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++++-+
+++++++-+
+++++++-+'''
+++++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
+++++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
+++++++-+'''
+++++++- class RingEnv(Env):
+++++++-     def def_sumo(self):
+++++++-         c = self.c  # Access configuration object
+++++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
+++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++++-         )
+++++++--
+++++++-         # Function to generate the shape of the edges (circular arcs)
+++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++++     def stats(self):
++++++++         c = self.c # Get the configuration object
++++++++@@ -120,140 +119,20 @@ class RingEnv(Env):
++++++++                 self.last_vehicle = vehicles_on_edge[0]
++++++++                 self.passed_vehicle.append(self.last_vehicle)
+++++++  
+++++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
+++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++++-         return stats
+++++++--
+++++++-+    
+++++++-+    def calculate_flow(self):
+++++++-+        """
+++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++++-+        """
+++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++++-+        if len(vehicles_on_edge) != 0:     
+++++++-+            if vehicles_on_edge[0] != self.last_vehicle:
+++++++-+                self.last_vehicle = vehicles_on_edge[0]
+++++++-+                self.passed_vehicle.append(self.last_vehicle)
+++++++-+
+++++++-+
+++++++-+                    
++++++++-
++++++++                     
+++++++      def step(self, action=None):
+++++++          c = self.c  # Configuration object
+++++++-         ts = self.ts  # Time step object
+++++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
+++++++-                     # Change to a specific lane
+++++++-                     ts.lane_change_to(rl, lc)
+++++++- 
+++++++-+        
+++++++-         super().step()  # Advance the simulation by one step
+++++++- 
+++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
+++++++- 
+++++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++++- 
+++++++-+        # Calculate flow at the end of each step
+++++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++-+        
+++++++-         # Calculate safety surrogate measures
+++++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
+++++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
+++++++-         return fleet_pet
+++++++- 
+++++++--# Define the Ring class which inherits from the Main class
+++++++-+
+++++++-+'''
+++++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
+++++++-+    It defines how the environment is created and configured, 
+++++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
+++++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
+++++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
+++++++-+'''
+++++++- class Ring(Main):
+++++++-     # Method to create and return the environment
+++++++-     def create_env(c):
+++++++-@@ -391,7 +421,7 @@ class Ring(Main):
+++++++- 
+++++++- if __name__ == '__main__':
+++++++-     # Run the test with different numbers of vehicles
+++++++--    for n_veh in range(40, 100, 10):
+++++++-+    for n_veh in range(20, 40, 10):
+++++++-         print(f"Running simulation with {n_veh} vehicles")
+++++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
+++++++-         c = Ring.from_args(globals(), locals()).setdefaults(
+++++++-diff --git a/u.py b/u.py
+++++++-index 09845aa..8e11a17 100644
+++++++---- a/u.py
+++++++-+++ b/u.py
+++++++-@@ -11,6 +11,8 @@ import warnings
+++++++- warnings.filterwarnings('ignore')
++++++++-        ts = self.ts  # Time step object
++++++++-        max_speed = c.max_speed  # Max vehicle speed
++++++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
++++++++-        circ_min = c.circumference_min  # Min circumference for normalization
++++++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
++++++++-
++++++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
++++++++-            super().step()
++++++++-            return c.observation_space.low, 0, False, 0
++++++++-
++++++++-        
++++++++-        super().step()  # Advance the simulation by one step
++++++++-
++++++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++++-            print('Detected collision')
++++++++-            return c.observation_space.low, -c.collision_penalty, True, None
++++++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
++++++++-            print('Bad initialization occurred, fix the initialization function')
++++++++-            return c.observation_space.low, 0, True, None
++++++++-
++++++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
++++++++-        if c.n_lanes == 1:
++++++++-            # Single-lane observation space representation
++++++++-            obs = [
++++++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
++++++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
++++++++-                dist / max_dist                 # Normalized headway distance
++++++++-            ]
++++++++-            if c.circ_feature:
++++++++-                # Add normalized circumference feature
++++++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
++++++++-            if c.accel_feature:
++++++++-                # Add leader acceleration feature
++++++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
++++++++-        elif c.n_lanes == 2:
++++++++-            # Two-lane observation space representation
++++++++-            lane = rl.lane
++++++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
++++++++-            if c.symmetric:
++++++++-                # Symmetric lane observations
++++++++-                other_lane = rl.lane.left or rl.lane.right
++++++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++-                obs = np.concatenate([
++++++++-                    # Normalized speeds of vehicles in the current and other lane
++++++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
++++++++-                    # Normalized distances to the leader and follower vehicles
++++++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
++++++++-                ])
++++++++-            else:
++++++++-                # Asymmetric lane observations
++++++++-                obs = [rl.speed]
++++++++-                for lane in rl.edge.lanes:
++++++++-                    is_rl_lane = lane == rl.lane
++++++++-                    if is_rl_lane:
++++++++-                        # Observations for the lane in which RL vehicle is currently present
++++++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++++++-                    else:
++++++++-                        # Observations for the other lane
++++++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++++++-                # Normalize the observations
++++++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
++++++++-        else:
++++++++-            # Multi-lane observation space representation (for more than two lanes)
++++++++-            obs = [rl.speed]
++++++++-            follower, fdist = rl.follower()
++++++++-            for lane in rl.edge.lanes:
++++++++-                is_rl_lane = lane == rl.lane
++++++++-                if is_rl_lane:
++++++++-                    # Observations for the current lane
++++++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++++++-                else:
++++++++-                    # Observations for other lanes
++++++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++++++-            # Normalize the observations
++++++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
++++++++-
++++++++-        if c.mrtl:
++++++++-            # If mrtl is enabled, add beta to observations
++++++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++++++-        # Clip and scale observations to the specified range
++++++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
++++++++-
++++++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
++++++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
++++++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
++++++++-            # Apply penalty for acceleration changes
++++++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
++++++++-
++++++++-        self.last_speed = rl.speed  # Update last speed for next step
++++++++-
++++++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++++++-
++++++++-        # Calculate flow at the end of each step
++++++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++++++-        
++++++++-        # Calculate safety surrogate measures
++++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
++++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
++++++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
++++++++-
++++++++-        raw_pet = self.calc_pet()
++++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
++++++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
++++++++-
++++++++-        # Combine safety measures into a single value for the reward
++++++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
++++++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
++++++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
++++++++-
++++++++-        # Return observations, reward, and other rollout information
++++++++-        returned = dict(
++++++++-            obs=obs.astype(np.float32),  # Observations
++++++++-            reward=reward,               # Final reward value
++++++++-            speed_reward=speed_reward,   # Component of reward due to speed
++++++++-            ttc=ttc,                     # Time to collision value
++++++++-            drac=drac,                   # Deceleration rate to avoid collision
++++++++-            pet=pet,                     # Post-encroachment time
++++++++-            ssm=ssm,                     # Combined safety surrogate measure
++++++++-            raw_ttc=raw_ttc,             # Raw TTC value
++++++++-            raw_drac=raw_drac,           # Raw DRAC value
++++++++-            raw_pet=raw_pet              # Raw PET value
++++++++-        )
++++++++-        return returned
+++++++++        ts = self.ts  # Traffuc state object
+++++++++        c, ts = self.c, self.ts
+++++++++        for veh in ts.types.human.vehicles:
+++++++++            leader, headway = veh.leader()
+++++++++            v = veh.speed
+++++++++            s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
+++++++++            a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
+++++++++            noise = np.random.normal(0, idm.sigma)
+++++++++            ts.accel(veh, a + noise)
+++++++++        self._step += 1
+++++++++        return c.observation_space.low, 0, False, None
+++++++  
+++++++- from io import StringIO
+++++++-+import os
+++++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++++     # Calculate the average Time to Collision (TTC) for all vehicles
++++++++     def calc_ttc(self):
++++++++@@ -420,26 +299,6 @@ if __name__ == '__main__':
++++++++                 n_veh=n_veh,  # Number of vehicles
++++++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
++++++++             )
++++++++-        elif c.n_lanes == 2:
++++++++-            c.setdefaults(
++++++++-                n_veh= int(n_veh*2),
++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++++-                symmetric=False,
++++++++-                symmetric_action=None,
++++++++-                lc_av=2
++++++++-            )
++++++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
++++++++-        elif c.n_lanes == 3:
++++++++-            c.setdefaults(
++++++++-                n_veh=66,
++++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++++-                symmetric=False,
++++++++-                symmetric_action=None,
++++++++-                lc_av=3,
++++++++-                _n_obs=1 + 3 * (1 + 2 * 2)
++++++++-            )
++++++++-        if c.mrtl:
++++++++-            c._n_obs += 1  # Increase observation size for mrtl
+++++++  
+++++++- def lrange(*args, **kwargs):
+++++++-     return list(range(*args, **kwargs))
+++++++\ No newline at end of file
++++++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
++++++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
+++++++\ No newline at end of file
+++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++index 6dd4b74..b5f8d76 100644
+++++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++@@ -1 +1 @@
+++++++-5212a280909582c6efe2a4607d1c48e7247a3514
+++++++\ No newline at end of file
++++++++08748e726448dbe1cefcc92787467792133761ac
+++++++\ No newline at end of file
+++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++index 2c19369..34859e8 100644
+++++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++@@ -2,17 +2,20 @@ On branch main
+++++++ Your branch is up to date with 'origin/main'.
++++++  
++++++-     @property
++++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
++++++-         }
++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
++++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
++++++-         return stats
++++++--
++++++-+    
++++++-+    def calculate_flow(self):
++++++-+        """
++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++-+        """
++++++-+        current_time = self.ts.time
++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++-+
++++++-+        for vehicle in vehicles_on_edge:
++++++-+            # Check if vehicle has passed the observation point since the last timestep
++++++-+            if vehicle.id not in self.last_vehicle_times:
++++++-+                # If the vehicle was not previously recorded, count it as a new passage
++++++-+                self.flow_counter += 1
++++++-+            else:
++++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
++++++-+                last_time = self.last_vehicle_times[vehicle.id]
++++++-+                if current_time - last_time > self.c.sim_step:
++++++-+                    self.flow_counter += 1
++++++-+
++++++-+            # Update the last time the vehicle passed the point
++++++-+            self.last_vehicle_times[vehicle.id] = current_time
++++++-+
++++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
++++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
++++++-+        self.flow_log.append(flow_per_hour)
++++++-+        return flow_per_hour
++++++-+    
++++++-     def step(self, action=None):
++++++-         c = self.c  # Configuration object
++++++-         ts = self.ts  # Time step object
++++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
++++++-                     # Change to a specific lane
++++++-                     ts.lane_change_to(rl, lc)
+++++++ Changes not staged for commit:
+++++++-  (use "git add <file>..." to update what will be committed)
++++++++  (use "git add/rm <file>..." to update what will be committed)
+++++++   (use "git restore <file>..." to discard changes in working directory)
+++++++-	modified:   README.md
+++++++ 	modified:   env.py
+++++++ 	modified:   exp.py
+++++++-	modified:   ring.py
++++++++	deleted:    highway_bottleneck.py
++++++++	deleted:    highway_ramp.py
++++++++	deleted:    intersection.py
++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++ 	modified:   ring_different_veh.py
+++++++-	modified:   u.py
++++++  
++++++-+        # Calculate flow at the end of each step
++++++-+        flow = self.calculate_flow()
++++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
++++++-+        
++++++-         super().step()  # Advance the simulation by one step
+++++++ Untracked files:
+++++++   (use "git add <file>..." to include in what will be committed)
+++++++-	pareto/single_ring/different_veh/
++++++++	ring_2.py
++++++  
++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++ no changes added to commit (use "git add" and/or "git commit -a")
+++++++\ No newline at end of file
++++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
++++++-index 127f673..878e4c8 100644
+++++++index 57ad1e2..aaaae1e 100644
++++++ --- a/ring_different_veh.py
++++++ +++ b/ring_different_veh.py
++++++-@@ -5,8 +5,15 @@
++++++- from exp import *  # Import all from experimental utilities
++++++- from env import *  # Import all from environment utilities
++++++- from u import *    # Import all from utility functions
++++++-+import os
+++++++@@ -71,7 +71,7 @@ class RingEnv(Env):
+++++++                 )
+++++++             }),
+++++++             # Define the vehicle type for RL-controlled vehicles
+++++++-            E('vType', id='human', **{
++++++++            E('vType', id='rl', **{
+++++++                 **IDM, **LC2013, **dict(
+++++++                     accel=1,
+++++++                     decel=1.5,
+++++++@@ -120,140 +120,20 @@ class RingEnv(Env):
+++++++                 self.last_vehicle = vehicles_on_edge[0]
+++++++                 self.passed_vehicle.append(self.last_vehicle)
++++++  
++++++--# Define the RingEnv class which inherits from the Env class
++++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++-+
++++++-+
++++++-+'''
++++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
++++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
++++++-+'''
++++++- class RingEnv(Env):
++++++-     def def_sumo(self):
++++++-         c = self.c  # Access configuration object
++++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
++++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++++-         )
++++++--
++++++-         # Function to generate the shape of the edges (circular arcs)
++++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++++- 
++++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
++++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++++-         return stats
++++++--
++++++-+    
++++++-+    def calculate_flow(self):
++++++-+        """
++++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++++-+        """
++++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++++-+        if len(vehicles_on_edge) != 0:     
++++++-+            if vehicles_on_edge[0] != self.last_vehicle:
++++++-+                self.last_vehicle = vehicles_on_edge[0]
++++++-+                self.passed_vehicle.append(self.last_vehicle)
++++++-+
++++++-+
++++++-+                    
+++++++-
+++++++                     
++++++      def step(self, action=None):
++++++          c = self.c  # Configuration object
++++++-         ts = self.ts  # Time step object
++++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
++++++-                     # Change to a specific lane
++++++-                     ts.lane_change_to(rl, lc)
++++++- 
++++++-+        
++++++-         super().step()  # Advance the simulation by one step
++++++- 
++++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
++++++- 
++++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++++- 
++++++-+        # Calculate flow at the end of each step
++++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++++-+        
++++++-         # Calculate safety surrogate measures
++++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
++++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
++++++-         return fleet_pet
++++++- 
++++++--# Define the Ring class which inherits from the Main class
++++++-+
++++++-+'''
++++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
++++++-+    It defines how the environment is created and configured, 
++++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
++++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
++++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
++++++-+'''
++++++- class Ring(Main):
++++++-     # Method to create and return the environment
++++++-     def create_env(c):
++++++-@@ -391,7 +421,7 @@ class Ring(Main):
++++++- 
++++++- if __name__ == '__main__':
++++++-     # Run the test with different numbers of vehicles
++++++--    for n_veh in range(40, 100, 10):
++++++-+    for n_veh in range(20, 40, 10):
++++++-         print(f"Running simulation with {n_veh} vehicles")
++++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
++++++-         c = Ring.from_args(globals(), locals()).setdefaults(
++++++-diff --git a/u.py b/u.py
++++++-index 09845aa..8e11a17 100644
++++++---- a/u.py
++++++-+++ b/u.py
++++++-@@ -11,6 +11,8 @@ import warnings
++++++- warnings.filterwarnings('ignore')
+++++++-        ts = self.ts  # Time step object
+++++++-        max_speed = c.max_speed  # Max vehicle speed
+++++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
+++++++-        circ_min = c.circumference_min  # Min circumference for normalization
+++++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
+++++++-
+++++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
+++++++-            super().step()
+++++++-            return c.observation_space.low, 0, False, 0
+++++++-
+++++++-        
+++++++-        super().step()  # Advance the simulation by one step
+++++++-
+++++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++++-            print('Detected collision')
+++++++-            return c.observation_space.low, -c.collision_penalty, True, None
+++++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
+++++++-            print('Bad initialization occurred, fix the initialization function')
+++++++-            return c.observation_space.low, 0, True, None
+++++++-
+++++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
+++++++-        if c.n_lanes == 1:
+++++++-            # Single-lane observation space representation
+++++++-            obs = [
+++++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
+++++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
+++++++-                dist / max_dist                 # Normalized headway distance
+++++++-            ]
+++++++-            if c.circ_feature:
+++++++-                # Add normalized circumference feature
+++++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
+++++++-            if c.accel_feature:
+++++++-                # Add leader acceleration feature
+++++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
+++++++-        elif c.n_lanes == 2:
+++++++-            # Two-lane observation space representation
+++++++-            lane = rl.lane
+++++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
+++++++-            if c.symmetric:
+++++++-                # Symmetric lane observations
+++++++-                other_lane = rl.lane.left or rl.lane.right
+++++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++-                obs = np.concatenate([
+++++++-                    # Normalized speeds of vehicles in the current and other lane
+++++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
+++++++-                    # Normalized distances to the leader and follower vehicles
+++++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
+++++++-                ])
+++++++-            else:
+++++++-                # Asymmetric lane observations
+++++++-                obs = [rl.speed]
+++++++-                for lane in rl.edge.lanes:
+++++++-                    is_rl_lane = lane == rl.lane
+++++++-                    if is_rl_lane:
+++++++-                        # Observations for the lane in which RL vehicle is currently present
+++++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++-                    else:
+++++++-                        # Observations for the other lane
+++++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++-                # Normalize the observations
+++++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
+++++++-        else:
+++++++-            # Multi-lane observation space representation (for more than two lanes)
+++++++-            obs = [rl.speed]
+++++++-            follower, fdist = rl.follower()
+++++++-            for lane in rl.edge.lanes:
+++++++-                is_rl_lane = lane == rl.lane
+++++++-                if is_rl_lane:
+++++++-                    # Observations for the current lane
+++++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++++-                else:
+++++++-                    # Observations for other lanes
+++++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++++-            # Normalize the observations
+++++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
+++++++-
+++++++-        if c.mrtl:
+++++++-            # If mrtl is enabled, add beta to observations
+++++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++++-        # Clip and scale observations to the specified range
+++++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
+++++++-
+++++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
+++++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
+++++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
+++++++-            # Apply penalty for acceleration changes
+++++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
+++++++-
+++++++-        self.last_speed = rl.speed  # Update last speed for next step
+++++++-
+++++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++++-
+++++++-        # Calculate flow at the end of each step
+++++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++-        
+++++++-        # Calculate safety surrogate measures
+++++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
+++++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
+++++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
+++++++-
+++++++-        raw_pet = self.calc_pet()
+++++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
+++++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
+++++++-
+++++++-        # Combine safety measures into a single value for the reward
+++++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
+++++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
+++++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
+++++++-
+++++++-        # Return observations, reward, and other rollout information
+++++++-        returned = dict(
+++++++-            obs=obs.astype(np.float32),  # Observations
+++++++-            reward=reward,               # Final reward value
+++++++-            speed_reward=speed_reward,   # Component of reward due to speed
+++++++-            ttc=ttc,                     # Time to collision value
+++++++-            drac=drac,                   # Deceleration rate to avoid collision
+++++++-            pet=pet,                     # Post-encroachment time
+++++++-            ssm=ssm,                     # Combined safety surrogate measure
+++++++-            raw_ttc=raw_ttc,             # Raw TTC value
+++++++-            raw_drac=raw_drac,           # Raw DRAC value
+++++++-            raw_pet=raw_pet              # Raw PET value
+++++++-        )
+++++++-        return returned
++++++++        ts = self.ts  # Traffuc state object
++++++++        c, ts = self.c, self.ts
++++++++        for veh in ts.types.human.vehicles:
++++++++            leader, headway = veh.leader()
++++++++            v = veh.speed
++++++++            s_star = 0 if leader is None else idm.minGap + max(0, v * idm.tau + v * (v - leader.speed) / (2 * np.sqrt(idm.accel * idm.decel)))
++++++++            a = idm.accel * (1 - (v / idm.maxSpeed) ** idm.delta - (s_star / (headway - leader.length)) ** 2)
++++++++            noise = np.random.normal(0, idm.sigma)
++++++++            ts.accel(veh, a + noise)
++++++++        self._step += 1
++++++++        return c.observation_space.low, 0, False, None
++++++  
++++++- from io import StringIO
++++++-+import os
++++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++++     # Calculate the average Time to Collision (TTC) for all vehicles
+++++++     def calc_ttc(self):
+++++++@@ -420,26 +300,6 @@ if __name__ == '__main__':
+++++++                 n_veh=n_veh,  # Number of vehicles
+++++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
+++++++             )
+++++++-        elif c.n_lanes == 2:
+++++++-            c.setdefaults(
+++++++-                n_veh= int(n_veh*2),
+++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++++-                symmetric=False,
+++++++-                symmetric_action=None,
+++++++-                lc_av=2
+++++++-            )
+++++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
+++++++-        elif c.n_lanes == 3:
+++++++-            c.setdefaults(
+++++++-                n_veh=66,
+++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++++-                symmetric=False,
+++++++-                symmetric_action=None,
+++++++-                lc_av=3,
+++++++-                _n_obs=1 + 3 * (1 + 2 * 2)
+++++++-            )
+++++++-        if c.mrtl:
+++++++-            c._n_obs += 1  # Increase observation size for mrtl
++++++  
++++++- def lrange(*args, **kwargs):
++++++-     return list(range(*args, **kwargs))
++++++\ No newline at end of file
+++++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
+++++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
++++++\ No newline at end of file
++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++index 6dd4b74..b5f8d76 100644
++++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++@@ -1 +1 @@
++++++-5212a280909582c6efe2a4607d1c48e7247a3514
++++++\ No newline at end of file
+++++++08748e726448dbe1cefcc92787467792133761ac
++++++\ No newline at end of file
++++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++index 2c19369..34859e8 100644
++++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++@@ -2,17 +2,20 @@ On branch main
++++++ Your branch is up to date with 'origin/main'.
+++++  
+++++-     @property
+++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
+++++-         }
+++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
+++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
+++++-         return stats
+++++--
+++++-+    
+++++-+    def calculate_flow(self):
+++++-+        """
+++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++-+        """
+++++-+        current_time = self.ts.time
+++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++-+
+++++-+        for vehicle in vehicles_on_edge:
+++++-+            # Check if vehicle has passed the observation point since the last timestep
+++++-+            if vehicle.id not in self.last_vehicle_times:
+++++-+                # If the vehicle was not previously recorded, count it as a new passage
+++++-+                self.flow_counter += 1
+++++-+            else:
+++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
+++++-+                last_time = self.last_vehicle_times[vehicle.id]
+++++-+                if current_time - last_time > self.c.sim_step:
+++++-+                    self.flow_counter += 1
+++++-+
+++++-+            # Update the last time the vehicle passed the point
+++++-+            self.last_vehicle_times[vehicle.id] = current_time
+++++-+
+++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
+++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
+++++-+        self.flow_log.append(flow_per_hour)
+++++-+        return flow_per_hour
+++++-+    
+++++-     def step(self, action=None):
+++++-         c = self.c  # Configuration object
+++++-         ts = self.ts  # Time step object
+++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
+++++-                     # Change to a specific lane
+++++-                     ts.lane_change_to(rl, lc)
++++++ Changes not staged for commit:
++++++-  (use "git add <file>..." to update what will be committed)
+++++++  (use "git add/rm <file>..." to update what will be committed)
++++++   (use "git restore <file>..." to discard changes in working directory)
++++++-	modified:   README.md
++++++ 	modified:   env.py
++++++ 	modified:   exp.py
++++++-	modified:   ring.py
+++++++	deleted:    highway_bottleneck.py
+++++++	deleted:    highway_ramp.py
+++++++	deleted:    intersection.py
+++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++ 	modified:   ring_different_veh.py
++++++-	modified:   u.py
+++++  
+++++-+        # Calculate flow at the end of each step
+++++-+        flow = self.calculate_flow()
+++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
+++++-+        
+++++-         super().step()  # Advance the simulation by one step
++++++ Untracked files:
++++++   (use "git add <file>..." to include in what will be committed)
++++++-	pareto/single_ring/different_veh/
+++++++	ring_2.py
+++++  
+++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++++ no changes added to commit (use "git add" and/or "git commit -a")
++++++\ No newline at end of file
+++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
+++++-index 127f673..878e4c8 100644
++++++index 57ad1e2..bff8e18 100644
+++++ --- a/ring_different_veh.py
+++++ +++ b/ring_different_veh.py
+++++-@@ -5,8 +5,15 @@
+++++- from exp import *  # Import all from experimental utilities
+++++- from env import *  # Import all from environment utilities
+++++- from u import *    # Import all from utility functions
+++++-+import os
++++++@@ -71,7 +71,7 @@ class RingEnv(Env):
++++++                 )
++++++             }),
++++++             # Define the vehicle type for RL-controlled vehicles
++++++-            E('vType', id='human', **{
+++++++            E('vType', id='rl', **{
++++++                 **IDM, **LC2013, **dict(
++++++                     accel=1,
++++++                     decel=1.5,
++++++@@ -120,7 +120,6 @@ class RingEnv(Env):
++++++                 self.last_vehicle = vehicles_on_edge[0]
++++++                 self.passed_vehicle.append(self.last_vehicle)
+++++  
+++++--# Define the RingEnv class which inherits from the Env class
+++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++-+
+++++-+
+++++-+'''
+++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
+++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
+++++-+'''
+++++- class RingEnv(Env):
+++++-     def def_sumo(self):
+++++-         c = self.c  # Access configuration object
+++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
+++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++++-         )
+++++ -
+++++-         # Function to generate the shape of the edges (circular arcs)
+++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++++- 
+++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
+++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++++-         stats['beta'] = c.beta                    # Add the beta parameter
+++++-         return stats
+++++--
+++++-+    
+++++-+    def calculate_flow(self):
+++++-+        """
+++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++++-+        """
+++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++++-+        if len(vehicles_on_edge) != 0:     
+++++-+            if vehicles_on_edge[0] != self.last_vehicle:
+++++-+                self.last_vehicle = vehicles_on_edge[0]
+++++-+                self.passed_vehicle.append(self.last_vehicle)
+++++-+
+++++-+
+++++-+                    
++++++                     
+++++      def step(self, action=None):
+++++          c = self.c  # Configuration object
+++++-         ts = self.ts  # Time step object
+++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
+++++-                     # Change to a specific lane
+++++-                     ts.lane_change_to(rl, lc)
+++++- 
+++++-+        
+++++-         super().step()  # Advance the simulation by one step
++++++@@ -134,6 +133,72 @@ class RingEnv(Env):
++++++             super().step()
++++++             return c.observation_space.low, 0, False, 0
+++++  
+++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
+++++- 
+++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++- 
+++++-+        # Calculate flow at the end of each step
+++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++++        rl = nexti(rl_type.vehicles)  # Get the first RL-controlled vehicle
+++++ +        
+++++-         # Calculate safety surrogate measures
+++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
+++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
+++++-         return fleet_pet
+++++- 
+++++--# Define the Ring class which inherits from the Main class
+++++++        if action is not None:  # If an action is provided
+++++++            ts.tc.vehicle.setMinGap(rl.id, 0)  # Set minimal gap to prevent collisions
+++++++            # Extract acceleration and lane change components from the action
+++++++            accel, lc = (
+++++++                (action, None) if not c.lc_av else # This part is executed if lane change actions are not available (c.lc_av is False).
+++++++                action if c.lc_act_type == 'continuous' else # This part is executed if lane change actions are continuous.  Here, action is expected to already include both acceleration and lane change information in a form that can be directly used.
+++++++                (action['accel'], action['lc']) # This part is executed when lane change actions exist and are not continuous.
+++++++            )
+++++++            if isinstance(accel, np.ndarray): accel = accel.item()  # Convert np.array to scalar
+++++++            if isinstance(lc, np.ndarray): lc = lc.item()
+++++++            if c.norm_action and isinstance(accel, (float, np.floating)):
+++++++                # Normalize acceleration action
+++++++                accel = (accel - c.low) / (c.high - c.low)
+++++++            if c.norm_action and isinstance(lc, (float, np.floating)):
+++++++                # Normalize lane change action
+++++++                lc = bool(np.round((lc - c.low) / (c.high - c.low)))
+++++ +
+++++-+'''
+++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
+++++-+    It defines how the environment is created and configured, 
+++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
+++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
+++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
+++++-+'''
+++++- class Ring(Main):
+++++-     # Method to create and return the environment
+++++-     def create_env(c):
+++++-@@ -391,7 +421,7 @@ class Ring(Main):
+++++- 
+++++- if __name__ == '__main__':
+++++-     # Run the test with different numbers of vehicles
+++++--    for n_veh in range(40, 100, 10):
+++++-+    for n_veh in range(20, 40, 10):
+++++-         print(f"Running simulation with {n_veh} vehicles")
+++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
+++++-         c = Ring.from_args(globals(), locals()).setdefaults(
+++++-diff --git a/u.py b/u.py
+++++-index 09845aa..8e11a17 100644
+++++---- a/u.py
+++++-+++ b/u.py
+++++-@@ -11,6 +11,8 @@ import warnings
+++++- warnings.filterwarnings('ignore')
+++++++            if c.get('handcraft'):  # Apply handcrafted control if specified
+++++++                accel = (0.75 * np.sign(c.handcraft - rl.speed) + 1) / 2
+++++++                lc = True
+++++++                if c.get('handcraft_lc'):
+++++++                    if c.handcraft_lc == 'off':  # No lane change
+++++++                        lc = False
+++++++                    elif c.handcraft_lc == 'stabilize':  # Stabilize the lane
+++++++                        other_lane = rl.lane.left or rl.lane.right
+++++++                        oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+++++++                        ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++++                        if odist + ofdist < 7 and odist > 3:
+++++++                            lc = True
+++++++                        else:
+++++++                            lc = False
+++++++
+++++++            # Apply acceleration or speed control based on the action type
+++++++            if c.act_type == 'accel_discrete':
+++++++                ts.accel(rl, accel / (c.n_actions - 1))  # Discrete acceleration
+++++++            elif c.act_type == 'accel':
+++++++                if c.norm_action:
+++++++                    # Scale the acceleration to match the maximum acceleration or deceleration
+++++++                    accel = (accel * 2 - 1) * (
+++++++                        c.max_accel if accel > 0.5 else c.max_decel
+++++++                    )
+++++++                ts.accel(rl, accel)  # Continuous acceleration
+++++++            else:
+++++++                # Set the vehicle's maximum speed based on the action
+++++++                if c.act_type == 'continuous':
+++++++                    level = accel
+++++++                elif c.act_type == 'discretize':
+++++++                    level = min(
+++++++                        int(accel * c.n_actions),
+++++++                        c.n_actions - 1
+++++++                    ) / (c.n_actions - 1)
+++++++                elif c.act_type == 'discrete':
+++++++                    level = accel / (c.n_actions - 1)
+++++++                ts.set_max_speed(rl, max_speed * level)
+++++++                
+++++++            if c.n_lanes > 1:  # Handle lane changes if there are multiple lanes
+++++++                if c.symmetric_action if c.symmetric_action is not None else c.symmetric:
+++++++                    if lc:
+++++++                        # Perform a symmetric lane change (left or right based on lane index)
+++++++                        ts.lane_change(rl, -1 if rl.lane_index % 2 else +1)
+++++++                else:
+++++++                    # Change to a specific lane
+++++++                    ts.lane_change_to(rl, lc)
+++++++
++++++         
++++++         super().step()  # Advance the simulation by one step
+++++  
+++++- from io import StringIO
+++++-+import os
+++++-+os.environ['F'] = 'automatic_vehicular_control'
++++++@@ -254,7 +319,6 @@ class RingEnv(Env):
++++++             raw_pet=raw_pet              # Raw PET value
++++++         )
++++++         return returned
++++++-
++++++     # Calculate the average Time to Collision (TTC) for all vehicles
++++++     def calc_ttc(self):
++++++         cur_veh_list = self.ts.vehicles
++++++@@ -420,26 +484,6 @@ if __name__ == '__main__':
++++++                 n_veh=n_veh,  # Number of vehicles
++++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
++++++             )
++++++-        elif c.n_lanes == 2:
++++++-            c.setdefaults(
++++++-                n_veh= int(n_veh*2),
++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++-                symmetric=False,
++++++-                symmetric_action=None,
++++++-                lc_av=2
++++++-            )
++++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
++++++-        elif c.n_lanes == 3:
++++++-            c.setdefaults(
++++++-                n_veh=66,
++++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++++-                symmetric=False,
++++++-                symmetric_action=None,
++++++-                lc_av=3,
++++++-                _n_obs=1 + 3 * (1 + 2 * 2)
++++++-            )
++++++-        if c.mrtl:
++++++-            c._n_obs += 1  # Increase observation size for mrtl
+++++  
+++++- def lrange(*args, **kwargs):
+++++-     return list(range(*args, **kwargs))
+++++\ No newline at end of file
++++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
++++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
+++++\ No newline at end of file
+++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++index 6dd4b74..b5f8d76 100644
+++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++@@ -1 +1 @@
+++++-5212a280909582c6efe2a4607d1c48e7247a3514
+++++\ No newline at end of file
++++++08748e726448dbe1cefcc92787467792133761ac
+++++\ No newline at end of file
+++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++index 2c19369..34859e8 100644
+++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++@@ -2,17 +2,20 @@ On branch main
+++++ Your branch is up to date with 'origin/main'.
++++  
++++-     @property
++++-@@ -101,8 +111,37 @@ class RingEnv(Env):
++++-         }
++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
++++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
++++-         return stats
++++--
++++-+    
++++-+    def calculate_flow(self):
++++-+        """
++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++-+        """
++++-+        current_time = self.ts.time
++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++-+
++++-+        for vehicle in vehicles_on_edge:
++++-+            # Check if vehicle has passed the observation point since the last timestep
++++-+            if vehicle.id not in self.last_vehicle_times:
++++-+                # If the vehicle was not previously recorded, count it as a new passage
++++-+                self.flow_counter += 1
++++-+            else:
++++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
++++-+                last_time = self.last_vehicle_times[vehicle.id]
++++-+                if current_time - last_time > self.c.sim_step:
++++-+                    self.flow_counter += 1
++++-+
++++-+            # Update the last time the vehicle passed the point
++++-+            self.last_vehicle_times[vehicle.id] = current_time
++++-+
++++-+        # Calculate flow as vehicles per hour equivalent based on timestep
++++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
++++-+        self.flow_log.append(flow_per_hour)
++++-+        return flow_per_hour
++++-+    
++++-     def step(self, action=None):
++++-         c = self.c  # Configuration object
++++-         ts = self.ts  # Time step object
++++-@@ -181,6 +220,10 @@ class RingEnv(Env):
++++-                     # Change to a specific lane
++++-                     ts.lane_change_to(rl, lc)
+++++ Changes not staged for commit:
+++++-  (use "git add <file>..." to update what will be committed)
++++++  (use "git add/rm <file>..." to update what will be committed)
+++++   (use "git restore <file>..." to discard changes in working directory)
+++++-	modified:   README.md
+++++ 	modified:   env.py
+++++ 	modified:   exp.py
+++++-	modified:   ring.py
++++++	deleted:    highway_bottleneck.py
++++++	deleted:    highway_ramp.py
++++++	deleted:    intersection.py
++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++ 	modified:   ring_different_veh.py
+++++-	modified:   u.py
++++  
++++-+        # Calculate flow at the end of each step
++++-+        flow = self.calculate_flow()
++++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
++++-+        
++++-         super().step()  # Advance the simulation by one step
+++++ Untracked files:
+++++   (use "git add <file>..." to include in what will be committed)
+++++-	pareto/single_ring/different_veh/
++++++	ring_2.py
++++  
++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++ no changes added to commit (use "git add" and/or "git commit -a")
+++++\ No newline at end of file
++++ diff --git a/ring_different_veh.py b/ring_different_veh.py
++++-index 127f673..878e4c8 100644
+++++index 57ad1e2..d915ee3 100644
++++ --- a/ring_different_veh.py
++++ +++ b/ring_different_veh.py
++++-@@ -5,8 +5,15 @@
++++- from exp import *  # Import all from experimental utilities
++++- from env import *  # Import all from environment utilities
++++- from u import *    # Import all from utility functions
++++-+import os
+++++@@ -71,7 +71,7 @@ class RingEnv(Env):
+++++                 )
+++++             }),
+++++             # Define the vehicle type for RL-controlled vehicles
+++++-            E('vType', id='human', **{
++++++            E('vType', id='rl', **{
+++++                 **IDM, **LC2013, **dict(
+++++                     accel=1,
+++++                     decel=1.5,
+++++@@ -120,140 +120,13 @@ class RingEnv(Env):
+++++                 self.last_vehicle = vehicles_on_edge[0]
+++++                 self.passed_vehicle.append(self.last_vehicle)
++++  
++++--# Define the RingEnv class which inherits from the Env class
++++-+os.environ['F'] = 'automatic_vehicular_control'
++++-+
++++-+
++++-+'''
++++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
++++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
++++-+'''
++++- class RingEnv(Env):
++++-     def def_sumo(self):
++++-         c = self.c  # Access configuration object
++++-@@ -15,7 +22,6 @@ class RingEnv(Env):
++++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++++-         )
++++--
++++-         # Function to generate the shape of the edges (circular arcs)
++++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++++- 
++++-@@ -102,7 +108,20 @@ class RingEnv(Env):
++++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++++-         stats['beta'] = c.beta                    # Add the beta parameter
++++-         return stats
++++--
++++-+    
++++-+    def calculate_flow(self):
++++-+        """
++++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++++-+        """
++++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++++-+        if len(vehicles_on_edge) != 0:     
++++-+            if vehicles_on_edge[0] != self.last_vehicle:
++++-+                self.last_vehicle = vehicles_on_edge[0]
++++-+                self.passed_vehicle.append(self.last_vehicle)
++++-+
++++-+
++++-+                    
+++++-
+++++                     
++++      def step(self, action=None):
++++          c = self.c  # Configuration object
++++-         ts = self.ts  # Time step object
++++-@@ -181,6 +200,7 @@ class RingEnv(Env):
++++-                     # Change to a specific lane
++++-                     ts.lane_change_to(rl, lc)
++++- 
++++-+        
++++-         super().step()  # Advance the simulation by one step
++++- 
++++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++-@@ -267,6 +287,9 @@ class RingEnv(Env):
++++- 
++++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++- 
++++-+        # Calculate flow at the end of each step
++++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++-+        
++++-         # Calculate safety surrogate measures
++++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++-@@ -340,7 +363,14 @@ class RingEnv(Env):
++++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
++++-         return fleet_pet
++++- 
++++--# Define the Ring class which inherits from the Main class
++++-+
++++-+'''
++++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
++++-+    It defines how the environment is created and configured, 
++++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
++++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
++++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
++++-+'''
++++- class Ring(Main):
++++-     # Method to create and return the environment
++++-     def create_env(c):
++++-@@ -391,7 +421,7 @@ class Ring(Main):
++++- 
++++- if __name__ == '__main__':
++++-     # Run the test with different numbers of vehicles
++++--    for n_veh in range(40, 100, 10):
++++-+    for n_veh in range(20, 40, 10):
++++-         print(f"Running simulation with {n_veh} vehicles")
++++-         # Set up the configuration for a one-lane ring road with different vehicle counts
++++-         c = Ring.from_args(globals(), locals()).setdefaults(
++++-diff --git a/u.py b/u.py
++++-index 09845aa..8e11a17 100644
++++---- a/u.py
++++-+++ b/u.py
++++-@@ -11,6 +11,8 @@ import warnings
++++- warnings.filterwarnings('ignore')
+++++-        ts = self.ts  # Time step object
+++++-        max_speed = c.max_speed  # Max vehicle speed
+++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
+++++-        circ_min = c.circumference_min  # Min circumference for normalization
+++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
+++++-
+++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
+++++-            super().step()
+++++-            return c.observation_space.low, 0, False, 0
+++++-
+++++-        
+++++-        super().step()  # Advance the simulation by one step
+++++-
+++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++++-            print('Detected collision')
+++++-            return c.observation_space.low, -c.collision_penalty, True, None
+++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
+++++-            print('Bad initialization occurred, fix the initialization function')
+++++-            return c.observation_space.low, 0, True, None
+++++-
+++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
+++++-        if c.n_lanes == 1:
+++++-            # Single-lane observation space representation
+++++-            obs = [
+++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
+++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
+++++-                dist / max_dist                 # Normalized headway distance
+++++-            ]
+++++-            if c.circ_feature:
+++++-                # Add normalized circumference feature
+++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
+++++-            if c.accel_feature:
+++++-                # Add leader acceleration feature
+++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
+++++-        elif c.n_lanes == 2:
+++++-            # Two-lane observation space representation
+++++-            lane = rl.lane
+++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
+++++-            if c.symmetric:
+++++-                # Symmetric lane observations
+++++-                other_lane = rl.lane.left or rl.lane.right
+++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++-                obs = np.concatenate([
+++++-                    # Normalized speeds of vehicles in the current and other lane
+++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
+++++-                    # Normalized distances to the leader and follower vehicles
+++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
+++++-                ])
+++++-            else:
+++++-                # Asymmetric lane observations
+++++-                obs = [rl.speed]
+++++-                for lane in rl.edge.lanes:
+++++-                    is_rl_lane = lane == rl.lane
+++++-                    if is_rl_lane:
+++++-                        # Observations for the lane in which RL vehicle is currently present
+++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++-                    else:
+++++-                        # Observations for the other lane
+++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++-                # Normalize the observations
+++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
+++++-        else:
+++++-            # Multi-lane observation space representation (for more than two lanes)
+++++-            obs = [rl.speed]
+++++-            follower, fdist = rl.follower()
+++++-            for lane in rl.edge.lanes:
+++++-                is_rl_lane = lane == rl.lane
+++++-                if is_rl_lane:
+++++-                    # Observations for the current lane
+++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++++-                else:
+++++-                    # Observations for other lanes
+++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++++-            # Normalize the observations
+++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
+++++-
+++++-        if c.mrtl:
+++++-            # If mrtl is enabled, add beta to observations
+++++-            obs = np.concatenate([obs, np.array([c.beta])])
+++++-        # Clip and scale observations to the specified range
+++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
+++++-
+++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
+++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
+++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
+++++-            # Apply penalty for acceleration changes
+++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
+++++-
+++++-        self.last_speed = rl.speed  # Update last speed for next step
+++++-
+++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++++-
+++++-        # Calculate flow at the end of each step
+++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++++-        
+++++-        # Calculate safety surrogate measures
+++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
+++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
+++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
+++++-
+++++-        raw_pet = self.calc_pet()
+++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
+++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
+++++-
+++++-        # Combine safety measures into a single value for the reward
+++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
+++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
+++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
+++++-
+++++-        # Return observations, reward, and other rollout information
+++++-        returned = dict(
+++++-            obs=obs.astype(np.float32),  # Observations
+++++-            reward=reward,               # Final reward value
+++++-            speed_reward=speed_reward,   # Component of reward due to speed
+++++-            ttc=ttc,                     # Time to collision value
+++++-            drac=drac,                   # Deceleration rate to avoid collision
+++++-            pet=pet,                     # Post-encroachment time
+++++-            ssm=ssm,                     # Combined safety surrogate measure
+++++-            raw_ttc=raw_ttc,             # Raw TTC value
+++++-            raw_drac=raw_drac,           # Raw DRAC value
+++++-            raw_pet=raw_pet              # Raw PET value
+++++-        )
+++++-        return returned
++++++        ts = self.ts  # Traffuc state object
++++++        c, ts = self.c, self.ts
++++++        super.step()
++++++        return c.observation_space.low, 0, False, None
++++  
++++- from io import StringIO
++++-+import os
++++-+os.environ['F'] = 'automatic_vehicular_control'
+++++     # Calculate the average Time to Collision (TTC) for all vehicles
+++++     def calc_ttc(self):
+++++@@ -420,26 +293,6 @@ if __name__ == '__main__':
+++++                 n_veh=n_veh,  # Number of vehicles
+++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
+++++             )
+++++-        elif c.n_lanes == 2:
+++++-            c.setdefaults(
+++++-                n_veh= int(n_veh*2),
+++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++-                symmetric=False,
+++++-                symmetric_action=None,
+++++-                lc_av=2
+++++-            )
+++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
+++++-        elif c.n_lanes == 3:
+++++-            c.setdefaults(
+++++-                n_veh=66,
+++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++++-                symmetric=False,
+++++-                symmetric_action=None,
+++++-                lc_av=3,
+++++-                _n_obs=1 + 3 * (1 + 2 * 2)
+++++-            )
+++++-        if c.mrtl:
+++++-            c._n_obs += 1  # Increase observation size for mrtl
++++  
++++- def lrange(*args, **kwargs):
++++-     return list(range(*args, **kwargs))
++++\ No newline at end of file
+++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
+++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
++++\ No newline at end of file
++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++index 6dd4b74..b5f8d76 100644
++++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++@@ -1 +1 @@
++++-5212a280909582c6efe2a4607d1c48e7247a3514
++++\ No newline at end of file
+++++08748e726448dbe1cefcc92787467792133761ac
++++\ No newline at end of file
++++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++index 2c19369..34859e8 100644
++++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++@@ -2,17 +2,20 @@ On branch main
++++ Your branch is up to date with 'origin/main'.
+++  
+++-     @property
+++-@@ -101,8 +111,37 @@ class RingEnv(Env):
+++-         }
+++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++-         stats['beta'] = c.beta                    # Add the beta parameter
+++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
+++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
+++-         return stats
+++--
+++-+    
+++-+    def calculate_flow(self):
+++-+        """
+++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++-+        """
+++-+        current_time = self.ts.time
+++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++-+
+++-+        for vehicle in vehicles_on_edge:
+++-+            # Check if vehicle has passed the observation point since the last timestep
+++-+            if vehicle.id not in self.last_vehicle_times:
+++-+                # If the vehicle was not previously recorded, count it as a new passage
+++-+                self.flow_counter += 1
+++-+            else:
+++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
+++-+                last_time = self.last_vehicle_times[vehicle.id]
+++-+                if current_time - last_time > self.c.sim_step:
+++-+                    self.flow_counter += 1
+++-+
+++-+            # Update the last time the vehicle passed the point
+++-+            self.last_vehicle_times[vehicle.id] = current_time
+++-+
+++-+        # Calculate flow as vehicles per hour equivalent based on timestep
+++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
+++-+        self.flow_log.append(flow_per_hour)
+++-+        return flow_per_hour
+++-+    
+++-     def step(self, action=None):
+++-         c = self.c  # Configuration object
+++-         ts = self.ts  # Time step object
+++-@@ -181,6 +220,10 @@ class RingEnv(Env):
+++-                     # Change to a specific lane
+++-                     ts.lane_change_to(rl, lc)
++++ Changes not staged for commit:
++++-  (use "git add <file>..." to update what will be committed)
+++++  (use "git add/rm <file>..." to update what will be committed)
++++   (use "git restore <file>..." to discard changes in working directory)
++++-	modified:   README.md
++++ 	modified:   env.py
++++ 	modified:   exp.py
++++-	modified:   ring.py
+++++	deleted:    highway_bottleneck.py
+++++	deleted:    highway_ramp.py
+++++	deleted:    intersection.py
+++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
++++ 	modified:   ring_different_veh.py
++++-	modified:   u.py
+++  
+++-+        # Calculate flow at the end of each step
+++-+        flow = self.calculate_flow()
+++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
+++-+        
+++-         super().step()  # Advance the simulation by one step
++++ Untracked files:
++++   (use "git add <file>..." to include in what will be committed)
++++-	pareto/single_ring/different_veh/
+++++	ring_2.py
+++  
+++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++ no changes added to commit (use "git add" and/or "git commit -a")
++++\ No newline at end of file
+++ diff --git a/ring_different_veh.py b/ring_different_veh.py
+++-index 127f673..878e4c8 100644
++++index 57ad1e2..95e6f10 100644
+++ --- a/ring_different_veh.py
+++ +++ b/ring_different_veh.py
+++-@@ -5,8 +5,15 @@
+++- from exp import *  # Import all from experimental utilities
+++- from env import *  # Import all from environment utilities
+++- from u import *    # Import all from utility functions
+++-+import os
++++@@ -71,7 +71,7 @@ class RingEnv(Env):
++++                 )
++++             }),
++++             # Define the vehicle type for RL-controlled vehicles
++++-            E('vType', id='human', **{
+++++            E('vType', id='rl', **{
++++                 **IDM, **LC2013, **dict(
++++                     accel=1,
++++                     decel=1.5,
++++@@ -120,140 +120,13 @@ class RingEnv(Env):
++++                 self.last_vehicle = vehicles_on_edge[0]
++++                 self.passed_vehicle.append(self.last_vehicle)
+++  
+++--# Define the RingEnv class which inherits from the Env class
+++-+os.environ['F'] = 'automatic_vehicular_control'
+++-+
+++-+
+++-+'''
+++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
+++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
+++-+'''
+++- class RingEnv(Env):
+++-     def def_sumo(self):
+++-         c = self.c  # Access configuration object
+++-@@ -15,7 +22,6 @@ class RingEnv(Env):
+++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++-         )
+++--
+++-         # Function to generate the shape of the edges (circular arcs)
+++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++- 
+++-@@ -102,7 +108,20 @@ class RingEnv(Env):
+++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+++-         stats['beta'] = c.beta                    # Add the beta parameter
+++-         return stats
+++--
+++-+    
+++-+    def calculate_flow(self):
+++-+        """
+++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+++-+        """
+++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+++-+        if len(vehicles_on_edge) != 0:     
+++-+            if vehicles_on_edge[0] != self.last_vehicle:
+++-+                self.last_vehicle = vehicles_on_edge[0]
+++-+                self.passed_vehicle.append(self.last_vehicle)
+++-+
+++-+
+++-+                    
++++-
++++                     
+++      def step(self, action=None):
+++          c = self.c  # Configuration object
+++-         ts = self.ts  # Time step object
+++-@@ -181,6 +200,7 @@ class RingEnv(Env):
+++-                     # Change to a specific lane
+++-                     ts.lane_change_to(rl, lc)
+++- 
+++-+        
+++-         super().step()  # Advance the simulation by one step
+++- 
+++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++-@@ -267,6 +287,9 @@ class RingEnv(Env):
+++- 
+++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++- 
+++-+        # Calculate flow at the end of each step
+++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++-+        
+++-         # Calculate safety surrogate measures
+++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++-@@ -340,7 +363,14 @@ class RingEnv(Env):
+++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
+++-         return fleet_pet
+++- 
+++--# Define the Ring class which inherits from the Main class
+++-+
+++-+'''
+++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
+++-+    It defines how the environment is created and configured, 
+++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
+++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
+++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
+++-+'''
+++- class Ring(Main):
+++-     # Method to create and return the environment
+++-     def create_env(c):
+++-@@ -391,7 +421,7 @@ class Ring(Main):
+++- 
+++- if __name__ == '__main__':
+++-     # Run the test with different numbers of vehicles
+++--    for n_veh in range(40, 100, 10):
+++-+    for n_veh in range(20, 40, 10):
+++-         print(f"Running simulation with {n_veh} vehicles")
+++-         # Set up the configuration for a one-lane ring road with different vehicle counts
+++-         c = Ring.from_args(globals(), locals()).setdefaults(
+++-diff --git a/u.py b/u.py
+++-index 09845aa..8e11a17 100644
+++---- a/u.py
+++-+++ b/u.py
+++-@@ -11,6 +11,8 @@ import warnings
+++- warnings.filterwarnings('ignore')
++++-        ts = self.ts  # Time step object
++++-        max_speed = c.max_speed  # Max vehicle speed
++++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
++++-        circ_min = c.circumference_min  # Min circumference for normalization
++++-        rl_type = ts.types.rl  # RL-controlled vehicle type
++++-
++++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
++++-            super().step()
++++-            return c.observation_space.low, 0, False, 0
++++-
++++-        
++++-        super().step()  # Advance the simulation by one step
++++-
++++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++++-            print('Detected collision')
++++-            return c.observation_space.low, -c.collision_penalty, True, None
++++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
++++-            print('Bad initialization occurred, fix the initialization function')
++++-            return c.observation_space.low, 0, True, None
++++-
++++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
++++-        if c.n_lanes == 1:
++++-            # Single-lane observation space representation
++++-            obs = [
++++-                rl.speed / max_speed,           # Normalized RL vehicle speed
++++-                leader.speed / max_speed,       # Normalized leader vehicle speed
++++-                dist / max_dist                 # Normalized headway distance
++++-            ]
++++-            if c.circ_feature:
++++-                # Add normalized circumference feature
++++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
++++-            if c.accel_feature:
++++-                # Add leader acceleration feature
++++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
++++-        elif c.n_lanes == 2:
++++-            # Two-lane observation space representation
++++-            lane = rl.lane
++++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
++++-            if c.symmetric:
++++-                # Symmetric lane observations
++++-                other_lane = rl.lane.left or rl.lane.right
++++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
++++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
++++-                obs = np.concatenate([
++++-                    # Normalized speeds of vehicles in the current and other lane
++++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
++++-                    # Normalized distances to the leader and follower vehicles
++++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
++++-                ])
++++-            else:
++++-                # Asymmetric lane observations
++++-                obs = [rl.speed]
++++-                for lane in rl.edge.lanes:
++++-                    is_rl_lane = lane == rl.lane
++++-                    if is_rl_lane:
++++-                        # Observations for the lane in which RL vehicle is currently present
++++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++-                    else:
++++-                        # Observations for the other lane
++++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++-                # Normalize the observations
++++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
++++-        else:
++++-            # Multi-lane observation space representation (for more than two lanes)
++++-            obs = [rl.speed]
++++-            follower, fdist = rl.follower()
++++-            for lane in rl.edge.lanes:
++++-                is_rl_lane = lane == rl.lane
++++-                if is_rl_lane:
++++-                    # Observations for the current lane
++++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++++-                else:
++++-                    # Observations for other lanes
++++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++++-            # Normalize the observations
++++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
++++-
++++-        if c.mrtl:
++++-            # If mrtl is enabled, add beta to observations
++++-            obs = np.concatenate([obs, np.array([c.beta])])
++++-        # Clip and scale observations to the specified range
++++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
++++-
++++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
++++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
++++-        if c.accel_penalty and hasattr(self, 'last_speed'):
++++-            # Apply penalty for acceleration changes
++++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
++++-
++++-        self.last_speed = rl.speed  # Update last speed for next step
++++-
++++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++++-
++++-        # Calculate flow at the end of each step
++++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++++-        
++++-        # Calculate safety surrogate measures
++++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
++++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
++++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
++++-
++++-        raw_pet = self.calc_pet()
++++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
++++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
++++-
++++-        # Combine safety measures into a single value for the reward
++++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
++++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
++++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
++++-
++++-        # Return observations, reward, and other rollout information
++++-        returned = dict(
++++-            obs=obs.astype(np.float32),  # Observations
++++-            reward=reward,               # Final reward value
++++-            speed_reward=speed_reward,   # Component of reward due to speed
++++-            ttc=ttc,                     # Time to collision value
++++-            drac=drac,                   # Deceleration rate to avoid collision
++++-            pet=pet,                     # Post-encroachment time
++++-            ssm=ssm,                     # Combined safety surrogate measure
++++-            raw_ttc=raw_ttc,             # Raw TTC value
++++-            raw_drac=raw_drac,           # Raw DRAC value
++++-            raw_pet=raw_pet              # Raw PET value
++++-        )
++++-        return returned
+++++        ts = self.ts  # Traffuc state object
+++++        c, ts = self.c, self.ts
+++++        super().step()
+++++        return c.observation_space.low, 0, False, None
+++  
+++- from io import StringIO
+++-+import os
+++-+os.environ['F'] = 'automatic_vehicular_control'
++++     # Calculate the average Time to Collision (TTC) for all vehicles
++++     def calc_ttc(self):
++++@@ -420,26 +293,6 @@ if __name__ == '__main__':
++++                 n_veh=n_veh,  # Number of vehicles
++++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
++++             )
++++-        elif c.n_lanes == 2:
++++-            c.setdefaults(
++++-                n_veh= int(n_veh*2),
++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++-                symmetric=False,
++++-                symmetric_action=None,
++++-                lc_av=2
++++-            )
++++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
++++-        elif c.n_lanes == 3:
++++-            c.setdefaults(
++++-                n_veh=66,
++++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++++-                symmetric=False,
++++-                symmetric_action=None,
++++-                lc_av=3,
++++-                _n_obs=1 + 3 * (1 + 2 * 2)
++++-            )
++++-        if c.mrtl:
++++-            c._n_obs += 1  # Increase observation size for mrtl
+++  
+++- def lrange(*args, **kwargs):
+++-     return list(range(*args, **kwargs))
+++\ No newline at end of file
++++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
++++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
+++\ No newline at end of file
+++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++index 6dd4b74..b5f8d76 100644
+++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++@@ -1 +1 @@
+++-5212a280909582c6efe2a4607d1c48e7247a3514
+++\ No newline at end of file
++++08748e726448dbe1cefcc92787467792133761ac
+++\ No newline at end of file
+++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++index 2c19369..34859e8 100644
+++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++@@ -2,17 +2,20 @@ On branch main
+++ Your branch is up to date with 'origin/main'.
++  
++-     @property
++-@@ -101,8 +111,37 @@ class RingEnv(Env):
++-         }
++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++-         stats['beta'] = c.beta                    # Add the beta parameter
++-+        stats['vehicle_flow'] = self.flow_log[-1] if self.flow_log else 0  # Add flow rate to stats
++-+        stats['average_episode_flow'] = self.episode_flow[-1] if self.episode_flow else 0  # Add average flow for the episode to stats
++-         return stats
++--
++-+    
++-+    def calculate_flow(self):
++-+        """
++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++-+        """
++-+        current_time = self.ts.time
++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++-+
++-+        for vehicle in vehicles_on_edge:
++-+            # Check if vehicle has passed the observation point since the last timestep
++-+            if vehicle.id not in self.last_vehicle_times:
++-+                # If the vehicle was not previously recorded, count it as a new passage
++-+                self.flow_counter += 1
++-+            else:
++-+                # If recorded, ensure sufficient time has passed to consider it as a new count
++-+                last_time = self.last_vehicle_times[vehicle.id]
++-+                if current_time - last_time > self.c.sim_step:
++-+                    self.flow_counter += 1
++-+
++-+            # Update the last time the vehicle passed the point
++-+            self.last_vehicle_times[vehicle.id] = current_time
++-+
++-+        # Calculate flow as vehicles per hour equivalent based on timestep
++-+        flow_per_hour = (self.flow_counter / (current_time + 1e-6)) * 3600
++-+        self.flow_log.append(flow_per_hour)
++-+        return flow_per_hour
++-+    
++-     def step(self, action=None):
++-         c = self.c  # Configuration object
++-         ts = self.ts  # Time step object
++-@@ -181,6 +220,10 @@ class RingEnv(Env):
++-                     # Change to a specific lane
++-                     ts.lane_change_to(rl, lc)
+++ Changes not staged for commit:
+++-  (use "git add <file>..." to update what will be committed)
++++  (use "git add/rm <file>..." to update what will be committed)
+++   (use "git restore <file>..." to discard changes in working directory)
+++-	modified:   README.md
+++ 	modified:   env.py
+++ 	modified:   exp.py
+++-	modified:   ring.py
++++	deleted:    highway_bottleneck.py
++++	deleted:    highway_ramp.py
++++	deleted:    intersection.py
++++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
++++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
+++ 	modified:   ring_different_veh.py
+++-	modified:   u.py
++  
++-+        # Calculate flow at the end of each step
++-+        flow = self.calculate_flow()
++-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
++-+        
++-         super().step()  # Advance the simulation by one step
+++ Untracked files:
+++   (use "git add <file>..." to include in what will be committed)
+++-	pareto/single_ring/different_veh/
++++	ring_2.py
++  
++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++ no changes added to commit (use "git add" and/or "git commit -a")
+++\ No newline at end of file
++ diff --git a/ring_different_veh.py b/ring_different_veh.py
++-index 127f673..878e4c8 100644
+++index 57ad1e2..fdc70c8 100644
++ --- a/ring_different_veh.py
++ +++ b/ring_different_veh.py
++-@@ -5,8 +5,15 @@
++- from exp import *  # Import all from experimental utilities
++- from env import *  # Import all from environment utilities
++- from u import *    # Import all from utility functions
++-+import os
++- 
++--# Define the RingEnv class which inherits from the Env class
++-+os.environ['F'] = 'automatic_vehicular_control'
++-+
++-+
++-+'''
++-+    RingEnv is a subclass of the Env class and represents the simulation environment 
++-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
++-+'''
++- class RingEnv(Env):
++-     def def_sumo(self):
++-         c = self.c  # Access configuration object
++-@@ -15,7 +22,6 @@ class RingEnv(Env):
++-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
++-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+++@@ -71,19 +71,19 @@ class RingEnv(Env):
+++                 )
+++             }),
+++             # Define the vehicle type for RL-controlled vehicles
+++-            E('vType', id='human', **{
+++-                **IDM, **LC2013, **dict(
+++-                    accel=1,
+++-                    decel=1.5,
+++-                    minGap=2,
+++-                    sigma=0  # No randomness in RL vehicles
+++-                )
+++-            }),
++++            # E('vType', id='rl', **{
++++            #     **IDM, **LC2013, **dict(
++++            #         accel=1,
++++            #         decel=1.5,
++++            #         minGap=2,
++++            #         sigma=0  # No randomness in RL vehicles
++++            #     )
++++            # }),
+++             # Build a closed route on the ring road with the specified number of vehicles
+++             *build_closed_route(
+++                 edges,
+++                 c.n_veh,
+++-                c.av,
++++                av = 0,
+++                 space=c.initial_space
+++             )
++          )
++--
++-         # Function to generate the shape of the edges (circular arcs)
++-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+++@@ -120,140 +120,13 @@ class RingEnv(Env):
+++                 self.last_vehicle = vehicles_on_edge[0]
+++                 self.passed_vehicle.append(self.last_vehicle)
++  
++-@@ -102,7 +108,20 @@ class RingEnv(Env):
++-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
++-         stats['beta'] = c.beta                    # Add the beta parameter
++-         return stats
++--
++-+    
++-+    def calculate_flow(self):
++-+        """
++-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
++-+        """
++-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
++-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
++-+        if len(vehicles_on_edge) != 0:     
++-+            if vehicles_on_edge[0] != self.last_vehicle:
++-+                self.last_vehicle = vehicles_on_edge[0]
++-+                self.passed_vehicle.append(self.last_vehicle)
++-+
++-+
++-+                    
+++-
+++                     
++      def step(self, action=None):
++          c = self.c  # Configuration object
++-         ts = self.ts  # Time step object
++-@@ -181,6 +200,7 @@ class RingEnv(Env):
++-                     # Change to a specific lane
++-                     ts.lane_change_to(rl, lc)
++- 
++-+        
++-         super().step()  # Advance the simulation by one step
++- 
++-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++-@@ -267,6 +287,9 @@ class RingEnv(Env):
++- 
++-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++- 
++-+        # Calculate flow at the end of each step
++-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++-+        
++-         # Calculate safety surrogate measures
++-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++-@@ -340,7 +363,14 @@ class RingEnv(Env):
++-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
++-         return fleet_pet
+++-        ts = self.ts  # Time step object
+++-        max_speed = c.max_speed  # Max vehicle speed
+++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
+++-        circ_min = c.circumference_min  # Min circumference for normalization
+++-        rl_type = ts.types.rl  # RL-controlled vehicle type
+++-
+++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
+++-            super().step()
+++-            return c.observation_space.low, 0, False, 0
+++-
+++-        
+++-        super().step()  # Advance the simulation by one step
+++-
+++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+++-            print('Detected collision')
+++-            return c.observation_space.low, -c.collision_penalty, True, None
+++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
+++-            print('Bad initialization occurred, fix the initialization function')
+++-            return c.observation_space.low, 0, True, None
+++-
+++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
+++-        if c.n_lanes == 1:
+++-            # Single-lane observation space representation
+++-            obs = [
+++-                rl.speed / max_speed,           # Normalized RL vehicle speed
+++-                leader.speed / max_speed,       # Normalized leader vehicle speed
+++-                dist / max_dist                 # Normalized headway distance
+++-            ]
+++-            if c.circ_feature:
+++-                # Add normalized circumference feature
+++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
+++-            if c.accel_feature:
+++-                # Add leader acceleration feature
+++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
+++-        elif c.n_lanes == 2:
+++-            # Two-lane observation space representation
+++-            lane = rl.lane
+++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
+++-            if c.symmetric:
+++-                # Symmetric lane observations
+++-                other_lane = rl.lane.left or rl.lane.right
+++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+++-                obs = np.concatenate([
+++-                    # Normalized speeds of vehicles in the current and other lane
+++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
+++-                    # Normalized distances to the leader and follower vehicles
+++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
+++-                ])
+++-            else:
+++-                # Asymmetric lane observations
+++-                obs = [rl.speed]
+++-                for lane in rl.edge.lanes:
+++-                    is_rl_lane = lane == rl.lane
+++-                    if is_rl_lane:
+++-                        # Observations for the lane in which RL vehicle is currently present
+++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++-                    else:
+++-                        # Observations for the other lane
+++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++-                # Normalize the observations
+++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
+++-        else:
+++-            # Multi-lane observation space representation (for more than two lanes)
+++-            obs = [rl.speed]
+++-            follower, fdist = rl.follower()
+++-            for lane in rl.edge.lanes:
+++-                is_rl_lane = lane == rl.lane
+++-                if is_rl_lane:
+++-                    # Observations for the current lane
+++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+++-                else:
+++-                    # Observations for other lanes
+++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+++-            # Normalize the observations
+++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
+++-
+++-        if c.mrtl:
+++-            # If mrtl is enabled, add beta to observations
+++-            obs = np.concatenate([obs, np.array([c.beta])])
+++-        # Clip and scale observations to the specified range
+++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
+++-
+++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
+++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
+++-        if c.accel_penalty and hasattr(self, 'last_speed'):
+++-            # Apply penalty for acceleration changes
+++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
+++-
+++-        self.last_speed = rl.speed  # Update last speed for next step
+++-
+++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+++-
+++-        # Calculate flow at the end of each step
+++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+++-        
+++-        # Calculate safety surrogate measures
+++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
+++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
+++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
+++-
+++-        raw_pet = self.calc_pet()
+++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
+++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
+++-
+++-        # Combine safety measures into a single value for the reward
+++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
+++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
+++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
+++-
+++-        # Return observations, reward, and other rollout information
+++-        returned = dict(
+++-            obs=obs.astype(np.float32),  # Observations
+++-            reward=reward,               # Final reward value
+++-            speed_reward=speed_reward,   # Component of reward due to speed
+++-            ttc=ttc,                     # Time to collision value
+++-            drac=drac,                   # Deceleration rate to avoid collision
+++-            pet=pet,                     # Post-encroachment time
+++-            ssm=ssm,                     # Combined safety surrogate measure
+++-            raw_ttc=raw_ttc,             # Raw TTC value
+++-            raw_drac=raw_drac,           # Raw DRAC value
+++-            raw_pet=raw_pet              # Raw PET value
+++-        )
+++-        return returned
++++        ts = self.ts  # Traffuc state object
++++        c, ts = self.c, self.ts
++++        super().step()
++++        return c.observation_space.low, 0, False, None
++  
++--# Define the Ring class which inherits from the Main class
++-+
++-+'''
++-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
++-+    It defines how the environment is created and configured, 
++-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
++-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
++-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
++-+'''
++- class Ring(Main):
++-     # Method to create and return the environment
++-     def create_env(c):
++-@@ -391,7 +421,7 @@ class Ring(Main):
+++     # Calculate the average Time to Collision (TTC) for all vehicles
+++     def calc_ttc(self):
+++@@ -420,32 +293,12 @@ if __name__ == '__main__':
+++                 n_veh=n_veh,  # Number of vehicles
+++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
+++             )
+++-        elif c.n_lanes == 2:
+++-            c.setdefaults(
+++-                n_veh= int(n_veh*2),
+++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++-                symmetric=False,
+++-                symmetric_action=None,
+++-                lc_av=2
+++-            )
+++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
+++-        elif c.n_lanes == 3:
+++-            c.setdefaults(
+++-                n_veh=66,
+++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+++-                symmetric=False,
+++-                symmetric_action=None,
+++-                lc_av=3,
+++-                _n_obs=1 + 3 * (1 + 2 * 2)
+++-            )
+++-        if c.mrtl:
+++-            c._n_obs += 1  # Increase observation size for mrtl
++  
++- if __name__ == '__main__':
++-     # Run the test with different numbers of vehicles
++--    for n_veh in range(40, 100, 10):
++-+    for n_veh in range(20, 40, 10):
++-         print(f"Running simulation with {n_veh} vehicles")
++-         # Set up the configuration for a one-lane ring road with different vehicle counts
++-         c = Ring.from_args(globals(), locals()).setdefaults(
++-diff --git a/u.py b/u.py
++-index 09845aa..8e11a17 100644
++---- a/u.py
++-+++ b/u.py
++-@@ -11,6 +11,8 @@ import warnings
++- warnings.filterwarnings('ignore')
+++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
+++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
++  
++- from io import StringIO
++-+import os
++-+os.environ['F'] = 'automatic_vehicular_control'
+++         # Run the environment with the set configuration
+++-        c.run()  # Assuming the RingEnv class has a run method
++++        c.run_2()  # Assuming the RingEnv class has a run method
++  
++- def lrange(*args, **kwargs):
++-     return list(range(*args, **kwargs))
++\ No newline at end of file
+++         print(f"Simulation with {n_veh} vehicles completed")
+++ 
++\ No newline at end of file
++diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++index 6dd4b74..b5f8d76 100644
++--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++@@ -1 +1 @@
++-5212a280909582c6efe2a4607d1c48e7247a3514
++\ No newline at end of file
+++08748e726448dbe1cefcc92787467792133761ac
++\ No newline at end of file
++diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++index 2c19369..34859e8 100644
++--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
++@@ -2,17 +2,20 @@ On branch main
++ Your branch is up to date with 'origin/main'.
+  
+-+        # Calculate flow at the end of each step
+-+        flow = self.calculate_flow()
+-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
+-+        
+-         super().step()  # Advance the simulation by one step
++ Changes not staged for commit:
++-  (use "git add <file>..." to update what will be committed)
+++  (use "git add/rm <file>..." to update what will be committed)
++   (use "git restore <file>..." to discard changes in working directory)
++-	modified:   README.md
++ 	modified:   env.py
++ 	modified:   exp.py
++-	modified:   ring.py
+++	deleted:    highway_bottleneck.py
+++	deleted:    highway_ramp.py
+++	deleted:    intersection.py
+++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
+++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
++ 	modified:   ring_different_veh.py
++-	modified:   u.py
+  
+-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++ Untracked files:
++   (use "git add <file>..." to include in what will be committed)
++-	pareto/single_ring/different_veh/
+++	ring_2.py
++ 
++ no changes added to commit (use "git add" and/or "git commit -a")
++\ No newline at end of file
+ diff --git a/ring_different_veh.py b/ring_different_veh.py
+-index 127f673..878e4c8 100644
++index 57ad1e2..a125757 100644
+ --- a/ring_different_veh.py
+ +++ b/ring_different_veh.py
+-@@ -5,8 +5,15 @@
+- from exp import *  # Import all from experimental utilities
+- from env import *  # Import all from environment utilities
+- from u import *    # Import all from utility functions
+-+import os
+- 
+--# Define the RingEnv class which inherits from the Env class
+-+os.environ['F'] = 'automatic_vehicular_control'
+-+
+-+
+-+'''
+-+    RingEnv is a subclass of the Env class and represents the simulation environment 
+-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
+-+'''
+- class RingEnv(Env):
+-     def def_sumo(self):
+-         c = self.c  # Access configuration object
+-@@ -15,7 +22,6 @@ class RingEnv(Env):
+-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
+-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
++@@ -71,19 +71,19 @@ class RingEnv(Env):
++                 )
++             }),
++             # Define the vehicle type for RL-controlled vehicles
++-            E('vType', id='human', **{
++-                **IDM, **LC2013, **dict(
++-                    accel=1,
++-                    decel=1.5,
++-                    minGap=2,
++-                    sigma=0  # No randomness in RL vehicles
++-                )
++-            }),
+++            # E('vType', id='rl', **{
+++            #     **IDM, **LC2013, **dict(
+++            #         accel=1,
+++            #         decel=1.5,
+++            #         minGap=2,
+++            #         sigma=0  # No randomness in RL vehicles
+++            #     )
+++            # }),
++             # Build a closed route on the ring road with the specified number of vehicles
++             *build_closed_route(
++                 edges,
++                 c.n_veh,
++-                c.av,
+++                av = 0,
++                 space=c.initial_space
++             )
+          )
+--
+-         # Function to generate the shape of the edges (circular arcs)
+-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
++@@ -120,140 +120,13 @@ class RingEnv(Env):
++                 self.last_vehicle = vehicles_on_edge[0]
++                 self.passed_vehicle.append(self.last_vehicle)
+  
+-@@ -102,7 +108,20 @@ class RingEnv(Env):
+-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
+-         stats['beta'] = c.beta                    # Add the beta parameter
+-         return stats
+ -
+-+    
+-+    def calculate_flow(self):
+-+        """
+-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
+-+        """
+-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
+-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
+-+        if len(vehicles_on_edge) != 0:     
+-+            if vehicles_on_edge[0] != self.last_vehicle:
+-+                self.last_vehicle = vehicles_on_edge[0]
+-+                self.passed_vehicle.append(self.last_vehicle)
+-+
+-+
+-+                    
++                     
+      def step(self, action=None):
+          c = self.c  # Configuration object
+-         ts = self.ts  # Time step object
+-@@ -181,6 +200,7 @@ class RingEnv(Env):
+-                     # Change to a specific lane
+-                     ts.lane_change_to(rl, lc)
+- 
+-+        
+-         super().step()  # Advance the simulation by one step
+- 
+-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+-@@ -267,6 +287,9 @@ class RingEnv(Env):
+- 
+-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+- 
+-+        # Calculate flow at the end of each step
+-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+-+        
+-         # Calculate safety surrogate measures
+-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+-@@ -340,7 +363,14 @@ class RingEnv(Env):
+-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
+-         return fleet_pet
++-        ts = self.ts  # Time step object
++-        max_speed = c.max_speed  # Max vehicle speed
++-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
++-        circ_min = c.circumference_min  # Min circumference for normalization
++-        rl_type = ts.types.rl  # RL-controlled vehicle type
++-
++-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
++-            super().step()
++-            return c.observation_space.low, 0, False, 0
++-
++-        
++-        super().step()  # Advance the simulation by one step
++-
++-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
++-            print('Detected collision')
++-            return c.observation_space.low, -c.collision_penalty, True, None
++-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
++-            print('Bad initialization occurred, fix the initialization function')
++-            return c.observation_space.low, 0, True, None
++-
++-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
++-        if c.n_lanes == 1:
++-            # Single-lane observation space representation
++-            obs = [
++-                rl.speed / max_speed,           # Normalized RL vehicle speed
++-                leader.speed / max_speed,       # Normalized leader vehicle speed
++-                dist / max_dist                 # Normalized headway distance
++-            ]
++-            if c.circ_feature:
++-                # Add normalized circumference feature
++-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
++-            if c.accel_feature:
++-                # Add leader acceleration feature
++-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
++-        elif c.n_lanes == 2:
++-            # Two-lane observation space representation
++-            lane = rl.lane
++-            follower, fdist = rl.follower()  # Get follower vehicle and distance
++-            if c.symmetric:
++-                # Symmetric lane observations
++-                other_lane = rl.lane.left or rl.lane.right
++-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
++-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
++-                obs = np.concatenate([
++-                    # Normalized speeds of vehicles in the current and other lane
++-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
++-                    # Normalized distances to the leader and follower vehicles
++-                    np.array([dist, odist, fdist, ofdist]) / max_dist
++-                ])
++-            else:
++-                # Asymmetric lane observations
++-                obs = [rl.speed]
++-                for lane in rl.edge.lanes:
++-                    is_rl_lane = lane == rl.lane
++-                    if is_rl_lane:
++-                        # Observations for the lane in which RL vehicle is currently present
++-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++-                    else:
++-                        # Observations for the other lane
++-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++-                # Normalize the observations
++-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
++-        else:
++-            # Multi-lane observation space representation (for more than two lanes)
++-            obs = [rl.speed]
++-            follower, fdist = rl.follower()
++-            for lane in rl.edge.lanes:
++-                is_rl_lane = lane == rl.lane
++-                if is_rl_lane:
++-                    # Observations for the current lane
++-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
++-                else:
++-                    # Observations for other lanes
++-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
++-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
++-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
++-            # Normalize the observations
++-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
++-
++-        if c.mrtl:
++-            # If mrtl is enabled, add beta to observations
++-            obs = np.concatenate([obs, np.array([c.beta])])
++-        # Clip and scale observations to the specified range
++-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
++-
++-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
++-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
++-        if c.accel_penalty and hasattr(self, 'last_speed'):
++-            # Apply penalty for acceleration changes
++-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
++-
++-        self.last_speed = rl.speed  # Update last speed for next step
++-
++-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
++-
++-        # Calculate flow at the end of each step
++-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
++-        
++-        # Calculate safety surrogate measures
++-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
++-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
++-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
++-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
++-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
++-
++-        raw_pet = self.calc_pet()
++-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
++-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
++-
++-        # Combine safety measures into a single value for the reward
++-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
++-        # Compute the final reward by combining speed and safety rewards, weighted by beta
++-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
++-
++-        # Return observations, reward, and other rollout information
++-        returned = dict(
++-            obs=obs.astype(np.float32),  # Observations
++-            reward=reward,               # Final reward value
++-            speed_reward=speed_reward,   # Component of reward due to speed
++-            ttc=ttc,                     # Time to collision value
++-            drac=drac,                   # Deceleration rate to avoid collision
++-            pet=pet,                     # Post-encroachment time
++-            ssm=ssm,                     # Combined safety surrogate measure
++-            raw_ttc=raw_ttc,             # Raw TTC value
++-            raw_drac=raw_drac,           # Raw DRAC value
++-            raw_pet=raw_pet              # Raw PET value
++-        )
++-        return returned
+++        ts = self.ts  # Traffuc state object
+++        c, ts = self.c, self.ts
+++        super().step_2()
+++        return c.observation_space.low, 0, False, None
+  
+--# Define the Ring class which inherits from the Main class
+-+
+-+'''
+-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
+-+    It defines how the environment is created and configured, 
+-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
+-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
+-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
+-+'''
+- class Ring(Main):
+-     # Method to create and return the environment
+-     def create_env(c):
+-@@ -391,7 +421,7 @@ class Ring(Main):
++     # Calculate the average Time to Collision (TTC) for all vehicles
++     def calc_ttc(self):
++@@ -420,32 +293,12 @@ if __name__ == '__main__':
++                 n_veh=n_veh,  # Number of vehicles
++                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
++             )
++-        elif c.n_lanes == 2:
++-            c.setdefaults(
++-                n_veh= int(n_veh*2),
++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++-                symmetric=False,
++-                symmetric_action=None,
++-                lc_av=2
++-            )
++-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
++-        elif c.n_lanes == 3:
++-            c.setdefaults(
++-                n_veh=66,
++-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
++-                symmetric=False,
++-                symmetric_action=None,
++-                lc_av=3,
++-                _n_obs=1 + 3 * (1 + 2 * 2)
++-            )
++-        if c.mrtl:
++-            c._n_obs += 1  # Increase observation size for mrtl
+  
+- if __name__ == '__main__':
+-     # Run the test with different numbers of vehicles
+--    for n_veh in range(40, 100, 10):
+-+    for n_veh in range(20, 40, 10):
+-         print(f"Running simulation with {n_veh} vehicles")
+-         # Set up the configuration for a one-lane ring road with different vehicle counts
+-         c = Ring.from_args(globals(), locals()).setdefaults(
+-diff --git a/u.py b/u.py
+-index 09845aa..8e11a17 100644
+---- a/u.py
+-+++ b/u.py
+-@@ -11,6 +11,8 @@ import warnings
+- warnings.filterwarnings('ignore')
++         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
++         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
+  
+- from io import StringIO
+-+import os
+-+os.environ['F'] = 'automatic_vehicular_control'
++         # Run the environment with the set configuration
++-        c.run()  # Assuming the RingEnv class has a run method
+++        c.run_2()  # Assuming the RingEnv class has a run method
+  
+- def lrange(*args, **kwargs):
+-     return list(range(*args, **kwargs))
+\ No newline at end of file
++         print(f"Simulation with {n_veh} vehicles completed")
++ 
+\ No newline at end of file
+diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+index 6dd4b74..b5f8d76 100644
+--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
++++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+@@ -1 +1 @@
+-5212a280909582c6efe2a4607d1c48e7247a3514
+\ No newline at end of file
++08748e726448dbe1cefcc92787467792133761ac
+\ No newline at end of file
+diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+index 2c19369..34859e8 100644
+--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
++++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
+@@ -2,17 +2,20 @@ On branch main
+ Your branch is up to date with 'origin/main'.
  
-+        # Calculate flow at the end of each step
-+        flow = self.calculate_flow()
-+        print(f"Current vehicle flow: {flow:.2f} vehicles/hour")
-+        
-         super().step()  # Advance the simulation by one step
+ Changes not staged for commit:
+-  (use "git add <file>..." to update what will be committed)
++  (use "git add/rm <file>..." to update what will be committed)
+   (use "git restore <file>..." to discard changes in working directory)
+-	modified:   README.md
+ 	modified:   env.py
+ 	modified:   exp.py
+-	modified:   ring.py
++	deleted:    highway_bottleneck.py
++	deleted:    highway_ramp.py
++	deleted:    intersection.py
++	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
++	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
++	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
+ 	modified:   ring_different_veh.py
+-	modified:   u.py
+ 
+ Untracked files:
+   (use "git add <file>..." to include in what will be committed)
+-	pareto/single_ring/different_veh/
++	ring_2.py
  
-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+ no changes added to commit (use "git add" and/or "git commit -a")
+\ No newline at end of file
 diff --git a/ring_different_veh.py b/ring_different_veh.py
-index 127f673..878e4c8 100644
+index 57ad1e2..a125757 100644
 --- a/ring_different_veh.py
 +++ b/ring_different_veh.py
-@@ -5,8 +5,15 @@
- from exp import *  # Import all from experimental utilities
- from env import *  # Import all from environment utilities
- from u import *    # Import all from utility functions
-+import os
- 
--# Define the RingEnv class which inherits from the Env class
-+os.environ['F'] = 'automatic_vehicular_control'
-+
-+
-+'''
-+    RingEnv is a subclass of the Env class and represents the simulation environment 
-+    where the vehicles (human-driven or RL-controlled) interact on a ring road.
-+'''
- class RingEnv(Env):
-     def def_sumo(self):
-         c = self.c  # Access configuration object
-@@ -15,7 +22,6 @@ class RingEnv(Env):
-             E('node', id='bottom', x=0, y=-r),  # Define bottom node at coordinates (0, -r)
-             E('node', id='top', x=0, y=r),      # Define top node at coordinates (0, r)
+@@ -71,19 +71,19 @@ class RingEnv(Env):
+                 )
+             }),
+             # Define the vehicle type for RL-controlled vehicles
+-            E('vType', id='human', **{
+-                **IDM, **LC2013, **dict(
+-                    accel=1,
+-                    decel=1.5,
+-                    minGap=2,
+-                    sigma=0  # No randomness in RL vehicles
+-                )
+-            }),
++            # E('vType', id='rl', **{
++            #     **IDM, **LC2013, **dict(
++            #         accel=1,
++            #         decel=1.5,
++            #         minGap=2,
++            #         sigma=0  # No randomness in RL vehicles
++            #     )
++            # }),
+             # Build a closed route on the ring road with the specified number of vehicles
+             *build_closed_route(
+                 edges,
+                 c.n_veh,
+-                c.av,
++                av = 0,
+                 space=c.initial_space
+             )
          )
--
-         # Function to generate the shape of the edges (circular arcs)
-         get_shape = lambda start_angle, end_angle: ' '.join('%.5f,%.5f' % (r * np.cos(i), r * np.sin(i)) for i in np.linspace(start_angle, end_angle, 80))
+@@ -120,140 +120,13 @@ class RingEnv(Env):
+                 self.last_vehicle = vehicles_on_edge[0]
+                 self.passed_vehicle.append(self.last_vehicle)
  
-@@ -102,7 +108,20 @@ class RingEnv(Env):
-         stats['circumference'] = c.circumference  # Add the current circumference to the stats
-         stats['beta'] = c.beta                    # Add the beta parameter
-         return stats
 -
-+    
-+    def calculate_flow(self):
-+        """
-+        Calculate the flow rate by counting vehicles passing a reference point on the ring road.
-+        """
-+        observation_edge = 'right'  # Example: observe vehicles passing the 'right' edge
-+        vehicles_on_edge = [v for v in self.ts.vehicles if v.edge.id == observation_edge]
-+        if len(vehicles_on_edge) != 0:     
-+            if vehicles_on_edge[0] != self.last_vehicle:
-+                self.last_vehicle = vehicles_on_edge[0]
-+                self.passed_vehicle.append(self.last_vehicle)
-+
-+
-+                    
+                     
      def step(self, action=None):
          c = self.c  # Configuration object
-         ts = self.ts  # Time step object
-@@ -181,6 +200,7 @@ class RingEnv(Env):
-                     # Change to a specific lane
-                     ts.lane_change_to(rl, lc)
- 
-+        
-         super().step()  # Advance the simulation by one step
- 
-         if len(ts.new_arrived | ts.new_collided):  # Check for collisions
-@@ -267,6 +287,9 @@ class RingEnv(Env):
- 
-         speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
- 
-+        # Calculate flow at the end of each step
-+        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
-+        
-         # Calculate safety surrogate measures
-         raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
-         ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
-@@ -340,7 +363,14 @@ class RingEnv(Env):
-         fleet_pet = np.nanmean(np.array(pets))  # Average PET, ignoring NaN values
-         return fleet_pet
+-        ts = self.ts  # Time step object
+-        max_speed = c.max_speed  # Max vehicle speed
+-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
+-        circ_min = c.circumference_min  # Min circumference for normalization
+-        rl_type = ts.types.rl  # RL-controlled vehicle type
+-
+-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
+-            super().step()
+-            return c.observation_space.low, 0, False, 0
+-
+-        
+-        super().step()  # Advance the simulation by one step
+-
+-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
+-            print('Detected collision')
+-            return c.observation_space.low, -c.collision_penalty, True, None
+-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
+-            print('Bad initialization occurred, fix the initialization function')
+-            return c.observation_space.low, 0, True, None
+-
+-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
+-        if c.n_lanes == 1:
+-            # Single-lane observation space representation
+-            obs = [
+-                rl.speed / max_speed,           # Normalized RL vehicle speed
+-                leader.speed / max_speed,       # Normalized leader vehicle speed
+-                dist / max_dist                 # Normalized headway distance
+-            ]
+-            if c.circ_feature:
+-                # Add normalized circumference feature
+-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
+-            if c.accel_feature:
+-                # Add leader acceleration feature
+-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
+-        elif c.n_lanes == 2:
+-            # Two-lane observation space representation
+-            lane = rl.lane
+-            follower, fdist = rl.follower()  # Get follower vehicle and distance
+-            if c.symmetric:
+-                # Symmetric lane observations
+-                other_lane = rl.lane.left or rl.lane.right
+-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
+-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
+-                obs = np.concatenate([
+-                    # Normalized speeds of vehicles in the current and other lane
+-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
+-                    # Normalized distances to the leader and follower vehicles
+-                    np.array([dist, odist, fdist, ofdist]) / max_dist
+-                ])
+-            else:
+-                # Asymmetric lane observations
+-                obs = [rl.speed]
+-                for lane in rl.edge.lanes:
+-                    is_rl_lane = lane == rl.lane
+-                    if is_rl_lane:
+-                        # Observations for the lane in which RL vehicle is currently present
+-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+-                    else:
+-                        # Observations for the other lane
+-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+-                # Normalize the observations
+-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
+-        else:
+-            # Multi-lane observation space representation (for more than two lanes)
+-            obs = [rl.speed]
+-            follower, fdist = rl.follower()
+-            for lane in rl.edge.lanes:
+-                is_rl_lane = lane == rl.lane
+-                if is_rl_lane:
+-                    # Observations for the current lane
+-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
+-                else:
+-                    # Observations for other lanes
+-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
+-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
+-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
+-            # Normalize the observations
+-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
+-
+-        if c.mrtl:
+-            # If mrtl is enabled, add beta to observations
+-            obs = np.concatenate([obs, np.array([c.beta])])
+-        # Clip and scale observations to the specified range
+-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
+-
+-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
+-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
+-        if c.accel_penalty and hasattr(self, 'last_speed'):
+-            # Apply penalty for acceleration changes
+-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
+-
+-        self.last_speed = rl.speed  # Update last speed for next step
+-
+-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
+-
+-        # Calculate flow at the end of each step
+-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
+-        
+-        # Calculate safety surrogate measures
+-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
+-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
+-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
+-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
+-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
+-
+-        raw_pet = self.calc_pet()
+-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
+-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
+-
+-        # Combine safety measures into a single value for the reward
+-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
+-        # Compute the final reward by combining speed and safety rewards, weighted by beta
+-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
+-
+-        # Return observations, reward, and other rollout information
+-        returned = dict(
+-            obs=obs.astype(np.float32),  # Observations
+-            reward=reward,               # Final reward value
+-            speed_reward=speed_reward,   # Component of reward due to speed
+-            ttc=ttc,                     # Time to collision value
+-            drac=drac,                   # Deceleration rate to avoid collision
+-            pet=pet,                     # Post-encroachment time
+-            ssm=ssm,                     # Combined safety surrogate measure
+-            raw_ttc=raw_ttc,             # Raw TTC value
+-            raw_drac=raw_drac,           # Raw DRAC value
+-            raw_pet=raw_pet              # Raw PET value
+-        )
+-        return returned
++        ts = self.ts  # Traffuc state object
++        c, ts = self.c, self.ts
++        super().step_2()
++        return c.observation_space.low, 0, False, None
  
--# Define the Ring class which inherits from the Main class
-+
-+'''
-+    Ring is a subclass of Main, and it represents the configuration and control structure for running the simulation. 
-+    It defines how the environment is created and configured, 
-+    including parameters such as number of vehicles, observation space, action space, and various simulation settings.
-+    This class is primarily responsible for setting up and managing the parameters and settings of the environment (RingEnv) before running the simulation. 
-+    It configures the simulation based on arguments passed at runtime and ensures that the environment is properly set up for training or testing.
-+'''
- class Ring(Main):
-     # Method to create and return the environment
-     def create_env(c):
-@@ -391,7 +421,7 @@ class Ring(Main):
+     # Calculate the average Time to Collision (TTC) for all vehicles
+     def calc_ttc(self):
+@@ -420,32 +293,12 @@ if __name__ == '__main__':
+                 n_veh=n_veh,  # Number of vehicles
+                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
+             )
+-        elif c.n_lanes == 2:
+-            c.setdefaults(
+-                n_veh= int(n_veh*2),
+-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+-                symmetric=False,
+-                symmetric_action=None,
+-                lc_av=2
+-            )
+-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
+-        elif c.n_lanes == 3:
+-            c.setdefaults(
+-                n_veh=66,
+-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
+-                symmetric=False,
+-                symmetric_action=None,
+-                lc_av=3,
+-                _n_obs=1 + 3 * (1 + 2 * 2)
+-            )
+-        if c.mrtl:
+-            c._n_obs += 1  # Increase observation size for mrtl
  
- if __name__ == '__main__':
-     # Run the test with different numbers of vehicles
--    for n_veh in range(40, 100, 10):
-+    for n_veh in range(20, 40, 10):
-         print(f"Running simulation with {n_veh} vehicles")
-         # Set up the configuration for a one-lane ring road with different vehicle counts
-         c = Ring.from_args(globals(), locals()).setdefaults(
-diff --git a/u.py b/u.py
-index 09845aa..8e11a17 100644
---- a/u.py
-+++ b/u.py
-@@ -11,6 +11,8 @@ import warnings
- warnings.filterwarnings('ignore')
+         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
+         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
  
- from io import StringIO
-+import os
-+os.environ['F'] = 'automatic_vehicular_control'
+         # Run the environment with the set configuration
+-        c.run()  # Assuming the RingEnv class has a run method
++        c.run_2()  # Assuming the RingEnv class has a run method
  
- def lrange(*args, **kwargs):
-     return list(range(*args, **kwargs))
\ No newline at end of file
+         print(f"Simulation with {n_veh} vehicles completed")
+ 
\ No newline at end of file
diff --git a/pareto/single_ring/different_veh/veh_20/commit/hash.txt b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
index 6dd4b74..b5f8d76 100644
--- a/pareto/single_ring/different_veh/veh_20/commit/hash.txt
+++ b/pareto/single_ring/different_veh/veh_20/commit/hash.txt
@@ -1 +1 @@
-5212a280909582c6efe2a4607d1c48e7247a3514
\ No newline at end of file
+08748e726448dbe1cefcc92787467792133761ac
\ No newline at end of file
diff --git a/pareto/single_ring/different_veh/veh_20/commit/status.txt b/pareto/single_ring/different_veh/veh_20/commit/status.txt
index 2c19369..e5a78b7 100644
--- a/pareto/single_ring/different_veh/veh_20/commit/status.txt
+++ b/pareto/single_ring/different_veh/veh_20/commit/status.txt
@@ -2,17 +2,21 @@ On branch main
 Your branch is up to date with 'origin/main'.
 
 Changes not staged for commit:
-  (use "git add <file>..." to update what will be committed)
+  (use "git add/rm <file>..." to update what will be committed)
   (use "git restore <file>..." to discard changes in working directory)
-	modified:   README.md
 	modified:   env.py
 	modified:   exp.py
-	modified:   ring.py
+	deleted:    highway_bottleneck.py
+	deleted:    highway_ramp.py
+	deleted:    intersection.py
+	modified:   pareto/single_ring/different_veh/veh_20/commit/diff.txt
+	modified:   pareto/single_ring/different_veh/veh_20/commit/hash.txt
+	modified:   pareto/single_ring/different_veh/veh_20/commit/status.txt
 	modified:   ring_different_veh.py
-	modified:   u.py
 
 Untracked files:
   (use "git add <file>..." to include in what will be committed)
-	pareto/single_ring/different_veh/
+	pareto/single_ring/different_veh/veh_30/
+	ring_2.py
 
 no changes added to commit (use "git add" and/or "git commit -a")
\ No newline at end of file
diff --git a/ring_different_veh.py b/ring_different_veh.py
index 57ad1e2..a125757 100644
--- a/ring_different_veh.py
+++ b/ring_different_veh.py
@@ -71,19 +71,19 @@ class RingEnv(Env):
                 )
             }),
             # Define the vehicle type for RL-controlled vehicles
-            E('vType', id='human', **{
-                **IDM, **LC2013, **dict(
-                    accel=1,
-                    decel=1.5,
-                    minGap=2,
-                    sigma=0  # No randomness in RL vehicles
-                )
-            }),
+            # E('vType', id='rl', **{
+            #     **IDM, **LC2013, **dict(
+            #         accel=1,
+            #         decel=1.5,
+            #         minGap=2,
+            #         sigma=0  # No randomness in RL vehicles
+            #     )
+            # }),
             # Build a closed route on the ring road with the specified number of vehicles
             *build_closed_route(
                 edges,
                 c.n_veh,
-                c.av,
+                av = 0,
                 space=c.initial_space
             )
         )
@@ -120,140 +120,13 @@ class RingEnv(Env):
                 self.last_vehicle = vehicles_on_edge[0]
                 self.passed_vehicle.append(self.last_vehicle)
 
-
                     
     def step(self, action=None):
         c = self.c  # Configuration object
-        ts = self.ts  # Time step object
-        max_speed = c.max_speed  # Max vehicle speed
-        circ_max = max_dist = c.circumference_max  # Max circumference for normalization
-        circ_min = c.circumference_min  # Min circumference for normalization
-        rl_type = ts.types.rl  # RL-controlled vehicle type
-
-        if not rl_type.vehicles:  # If no RL vehicles are present, proceed without action
-            super().step()
-            return c.observation_space.low, 0, False, 0
-
-        
-        super().step()  # Advance the simulation by one step
-
-        if len(ts.new_arrived | ts.new_collided):  # Check for collisions
-            print('Detected collision')
-            return c.observation_space.low, -c.collision_penalty, True, None
-        elif len(ts.vehicles) < c.n_veh:  # Check for missing vehicles
-            print('Bad initialization occurred, fix the initialization function')
-            return c.observation_space.low, 0, True, None
-
-        leader, dist = rl.leader()  # Get the leader vehicle and headway distance
-        if c.n_lanes == 1:
-            # Single-lane observation space representation
-            obs = [
-                rl.speed / max_speed,           # Normalized RL vehicle speed
-                leader.speed / max_speed,       # Normalized leader vehicle speed
-                dist / max_dist                 # Normalized headway distance
-            ]
-            if c.circ_feature:
-                # Add normalized circumference feature
-                obs.append((c.circumference - circ_min) / (circ_max - circ_min))
-            if c.accel_feature:
-                # Add leader acceleration feature
-                obs.append(0 if leader.prev_speed is None else (leader.speed - leader.speed) / max_speed)
-        elif c.n_lanes == 2:
-            # Two-lane observation space representation
-            lane = rl.lane
-            follower, fdist = rl.follower()  # Get follower vehicle and distance
-            if c.symmetric:
-                # Symmetric lane observations
-                other_lane = rl.lane.left or rl.lane.right
-                oleader, odist = other_lane.next_vehicle(rl.laneposition, route=rl.route)
-                ofollower, ofdist = other_lane.prev_vehicle(rl.laneposition, route=rl.route)
-                obs = np.concatenate([
-                    # Normalized speeds of vehicles in the current and other lane
-                    np.array([rl.speed, leader.speed, oleader.speed, follower.speed, ofollower.speed]) / max_speed,
-                    # Normalized distances to the leader and follower vehicles
-                    np.array([dist, odist, fdist, ofdist]) / max_dist
-                ])
-            else:
-                # Asymmetric lane observations
-                obs = [rl.speed]
-                for lane in rl.edge.lanes:
-                    is_rl_lane = lane == rl.lane
-                    if is_rl_lane:
-                        # Observations for the lane in which RL vehicle is currently present
-                        obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
-                    else:
-                        # Observations for the other lane
-                        oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
-                        ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
-                        obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
-                # Normalize the observations
-                obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 2)]
-        else:
-            # Multi-lane observation space representation (for more than two lanes)
-            obs = [rl.speed]
-            follower, fdist = rl.follower()
-            for lane in rl.edge.lanes:
-                is_rl_lane = lane == rl.lane
-                if is_rl_lane:
-                    # Observations for the current lane
-                    obs.extend([is_rl_lane, dist, leader.speed, fdist, follower.speed])
-                else:
-                    # Observations for other lanes
-                    oleader, odist = lane.next_vehicle(rl.laneposition, route=rl.route)
-                    ofollower, ofdist = lane.prev_vehicle(rl.laneposition, route=rl.route)
-                    obs.extend([is_rl_lane, odist, oleader.speed, ofdist, ofollower.speed])
-            # Normalize the observations
-            obs = np.array(obs) / [max_speed, *([1, max_dist, max_speed, max_dist, max_speed] * 3)]
-
-        if c.mrtl:
-            # If mrtl is enabled, add beta to observations
-            obs = np.concatenate([obs, np.array([c.beta])])
-        # Clip and scale observations to the specified range
-        obs = np.clip(obs, 0, 1) * (1 - c.low) + c.low
-
-        # Compute reward based on average speed of all vehicles or only RL-controlled vehicles
-        reward = np.mean([v.speed for v in (ts.vehicles if c.global_reward else rl_type.vehicles)])
-        if c.accel_penalty and hasattr(self, 'last_speed'):
-            # Apply penalty for acceleration changes
-            reward -= c.accel_penalty * np.abs(rl.speed - self.last_speed) / c.sim_step
-
-        self.last_speed = rl.speed  # Update last speed for next step
-
-        speed_reward = np.clip(reward / max_speed, -1, 1)  # Normalize speed reward to range [-1, 1]
-
-        # Calculate flow at the end of each step
-        self.mean_speed = np.mean([v.speed for v in self.ts.vehicles])
-        
-        # Calculate safety surrogate measures
-        raw_ttc, raw_drac = self.calc_ttc(), self.calc_drac()
-        ttc = np.log10(raw_ttc) if not np.isnan(raw_ttc) else 7  # Log-transform TTC; default value if NaN
-        ttc = np.clip(ttc / 7, -1, 1)  # Normalize TTC to range [-1, 1]
-        drac = np.log10(raw_drac) if not np.isnan(raw_drac) else 1e-4  # Log-transform DRAC; default value if NaN
-        drac = np.clip(drac / 10, -1, 1)  # Normalize DRAC to range [-1, 1]
-
-        raw_pet = self.calc_pet()
-        pet = np.log10(raw_pet) if not np.isnan(raw_pet) else 6  # Log-transform PET; default value if NaN
-        pet = np.clip(pet, -1, 1)  # Normalize PET to range [-1, 1]
-
-        # Combine safety measures into a single value for the reward
-        ssm = (c.scale_ttc * ttc - c.scale_drac * drac) / 2
-        # Compute the final reward by combining speed and safety rewards, weighted by beta
-        reward = (1 - c.beta) * speed_reward + c.beta * ssm
-
-        # Return observations, reward, and other rollout information
-        returned = dict(
-            obs=obs.astype(np.float32),  # Observations
-            reward=reward,               # Final reward value
-            speed_reward=speed_reward,   # Component of reward due to speed
-            ttc=ttc,                     # Time to collision value
-            drac=drac,                   # Deceleration rate to avoid collision
-            pet=pet,                     # Post-encroachment time
-            ssm=ssm,                     # Combined safety surrogate measure
-            raw_ttc=raw_ttc,             # Raw TTC value
-            raw_drac=raw_drac,           # Raw DRAC value
-            raw_pet=raw_pet              # Raw PET value
-        )
-        return returned
+        ts = self.ts  # Traffuc state object
+        c, ts = self.c, self.ts
+        super().step_2()
+        return c.observation_space.low, 0, False, None
 
     # Calculate the average Time to Collision (TTC) for all vehicles
     def calc_ttc(self):
@@ -420,32 +293,12 @@ if __name__ == '__main__':
                 n_veh=n_veh,  # Number of vehicles
                 _n_obs=3 + c.circ_feature + c.accel_feature  # Observation size
             )
-        elif c.n_lanes == 2:
-            c.setdefaults(
-                n_veh= int(n_veh*2),
-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
-                symmetric=False,
-                symmetric_action=None,
-                lc_av=2
-            )
-            c._n_obs = (1 + 2 * 2 * 2) if c.symmetric else (1 + 2 * 5)
-        elif c.n_lanes == 3:
-            c.setdefaults(
-                n_veh=66,
-                lc_mode=LC_MODE.no_lat_collide, # No lateral collision mode
-                symmetric=False,
-                symmetric_action=None,
-                lc_av=3,
-                _n_obs=1 + 3 * (1 + 2 * 2)
-            )
-        if c.mrtl:
-            c._n_obs += 1  # Increase observation size for mrtl
 
         c.step_save = c.step_save or min(5, c.n_steps // 10)  # Set step save interval
         c.redef_sumo = bool(c.circumference_range)  # Redefine sumo if random circumference range is given
 
         # Run the environment with the set configuration
-        c.run()  # Assuming the RingEnv class has a run method
+        c.run_2()  # Assuming the RingEnv class has a run method
 
         print(f"Simulation with {n_veh} vehicles completed")
 